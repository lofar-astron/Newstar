C+ NCLCDT.FOR
C  WNB 921202
C
C  Revisions:
C	WNB 921207	Some changes to source handling
C	HjV 921228	Line too long for HP
C	WNB 930108	Typo re-patch
C	WNB 930407	Keep correct noise
C	WNB 930928	Add instrument
C	CMV 950616	Account for DATAFAC in map limits
C
	SUBROUTINE NCLCDT(MPHP,APHP)
C
C  Do data cleaning
C
C  Result:
C	CALL NCLCDT( MPHP_J:I, APHP_J:I)
C				Do a data clean.
C				MPHP and APHP are the
C				map and beam header pointers.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'MPH_O_DEF'	!MAP HEADER
	INCLUDE 'MDH_O_DEF'	!MODEL HEADER
	INCLUDE 'NCL_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MPHP		!MAP HEADER POINTER
	INTEGER APHP		!BEAM HEADER POINTER
C
C  Function references:
C
	LOGICAL WNGGVM		!GET VIRTUAL MEMORY
	LOGICAL WNFOP		!OPEN FILE
	LOGICAL WNFRD		!READ DISK
	CHARACTER*20 WNFFNM	!GET FILE NAME
	LOGICAL NMOSLG		!GET SOURCE SPACE
C
C  Data declarations:
C
	INTEGER RMPP		!RESIDUAL/RESTORE MAP POINTER
	INTEGER RSNAM(0:7)	!RESTORE SET NAME
	INTEGER BMSIZ,MPSIZ	!PATCH BUFFER SIZES
	INTEGER BMPAD,MPPAD	!PATCH BUFFER ADDRESSES
	INTEGER FCATMP		!TEMP. FILE FOR RESTORE
	REAL SUMGL		!GRATING LOBE SUM
	INTEGER MDHJ(0:MDHHDL/4-1) !MODEL HEADER
	  REAL MDHE(0:MDHHDL/4-1)
	  DOUBLE PRECISION MDHD(0:MDHHDL/8-1)
	  EQUIVALENCE (MDHJ,MDHE,MDHD)
	BYTE MPH(0:MPHHDL-1)	!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1)
	  INTEGER MPHJ(0:MPHHDL/4-1)
	  REAL MPHE(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	BYTE RMPH(0:MPHHDL-1)	!RESIDUAL MAP HEADER
	  INTEGER RMPHJ(0:MPHHDL/4-1)
	  REAL RMPHE(0:MPHHDL/4-1)
	  EQUIVALENCE (RMPH,RMPHJ,RMPHE)
	BYTE APH(0:MPHHDL-1)	!BEAM HEADER
	INTEGER RG(0:1)		!SOURCE RANGE
	  DATA RG/1,1000000/
C-
C
C INIT
C
	IF (.NOT.WNFRD(FCAMAP,MPHHDL,MPH,MPHP)) THEN !READ MAP HEADER
	  CALL WNCTXT(F_TP,'Error reading map header')
	  CALL WNGEX				!STOP
	END IF
	MINLIM=MAX(ABS(MPHE(MPH_MAX_E)*DATAFAC),
	1		ABS(MPHE(MPH_MIN_E)*DATAFAC)) !SET MAP MAX
	IF (APHP.NE.0) THEN			!BEAM PRESENT
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,APH,APHP)) THEN !READ BEAM HEADER
	    CALL WNCTXT(F_TP,'Error reading beam header')
	    CALL WNGEX				!STOP
	  END IF
	ELSE					!NO BEAM
	  CALL WNGMV(MPHHDL,MPH,APH)		!MAKE SURE DATA PRESENT
	END IF
C
C GET HISTOGRAMS AND PATCH DATA
C
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'Histogramming')
	CALL NCLHID(MPHP,APHP)			!GET BEAM PATCH, SHOW HISTO
	CALL WNCTXT(F_P,'!^')
C
C INIT SOURCE LISTS
C
	DO I=4,5				!MINOR LIST; TOTAL LIST
	  CALL NMOHMF(I,MDHJ)			!GET HEADER
	  CALL NMOHZD(MDHJ)			!CLEAR SOURCES
	  MDHD(MDH_RA_D)=MPHD(MPH_RA_D)		!SET MAP RA
	  MDHD(MDH_DEC_D)=MPHD(MPH_DEC_D)	!SET MAP DEC
	  MDHD(MDH_FRQ_D)=MPHD(MPH_FRQ_D)	!SET MAP FREQ.
	  IF (MPHI(MPH_EPT_I).EQ.1) THEN	!1950 COORDINATES
	    MDHJ(MDH_TYP_J)=2			!EPOCH TYPE
	    MDHE(MDH_EPOCH_E)=MPHE(MPH_EPO_E)	!EPOCH
	  ELSE					!APPARENT
	    MDHJ(MDH_TYP_J)=1			!EPOCH TYPE
	    MDHE(MDH_EPOCH_E)=0.		!EPOCH
	  END IF
	  MDHJ(MDH_BITS_J)=MPHJ(MPH_INST_J)	!SET INSTRUMENT
	  IF (.NOT.NMOSLG(SRCLIM,MDHJ)) THEN	!GET AREA
	    CALL WNCTXT(F_TP,'No space for clean source list')
	    CALL WNGEX				!STOP
	  END IF
	  CALL NMOHMT(MDHJ,I)			!SAVE LIST
	END DO
C
C GET PATCH BUFFER
C
 10	CONTINUE
	BMSIZ=LB_E*(2*BEMPAT+1)*(BEMPAT+1)	!BEAM BUFFER SIZE
	MPSIZ=(LB_E+2*LB_I)*MAPPAT		!MAP BUFFER SIZE
	JS=WNGGVM(BMSIZ,BMPAD)			!GET BEAM PATCH BUF
	IF (JS) JS=WNGGVM(MPSIZ,MPPAD)		!GET MAP POINT BUFFER
	IF (.NOT.JS) THEN
	  CALL WNCTXT(F_TP,'Cannot obtain beam and/or map patch buffers')
	  CALL WNGEX				!STOP
	END IF
	CALL WNCTXT(F_TP,'!/Beam patch of !UJ points, '//
	1		'!UJ mappoints down to !E10.3 W.U. (!E7.2%)!/',
	1		2*BEMPAT+1,MAPPAT,MAPLIM,100.*MAPLIM/MINLIM)
C
C READ DATA
C
	CALL NCLCRD(FCAMAP,APH,A_B(BMPAD-A_OB),FCAMAP,
	1		MPHJ(MPH_MDP_J),
	1		MPH,A_B(MPPAD-A_OB),A_B(MPPAD-A_OB)) !BEAM, MAP PATCH
C
C DO CLEAN
C
	CALL NMOHMF(4,MDHJ)			!GET NEW TOTAL LIST
	CALL WNCCSX(F_TP,'Cleaning')
	J=MDHJ(MDH_NSRC_J)+1			!START SOURCE
	SUMGL=0					!START GRATING RESPONSE
	DO WHILE (CURMAX.GT.MAPLIM .AND.
	1		MDHJ(MDH_NSRC_J).LT.SRCLIM .AND.
	1		CURMAX.GE.SUMGL)
	  CALL NCLCCL(A_B(BMPAD-A_OB),A_B(MPPAD-A_OB),A_B(MPPAD-A_OB),
	1		J,MDHJ,MPH,SUMGL)	!CLEAN CYCLE
	END DO
C
C SHOW SOURCES
C
	CALL NMOHMT(MDHJ,4)			!SET HEADER 4
	CALL NMORDA(4,5,J)			!ADD TO TOTAL LIST
	CALL NMOAM1(5)				!MERGE TOTAL LIST
	CALL NMOPTI(F_TP,RG,5)			!SHOW TOTAL TILL NOW
C
C RELEASE PATCH BUFFERS
C
	CALL WNGFVM(BMSIZ,BMPAD)
	CALL WNGFVM(MPSIZ,MPPAD)
C
C CLEAN MAJOR CYCLE
C
	CALL NMORDA(4,-1,J)			!SET SOURCES IN GENERAL LIST
	CALL NMAMAC(MPHP,MAPNAM)		!MAKE NEW MAP
C
C RECYCLE
C
	IF (MDHJ(MDH_NSRC_J).LT.SRCLIM) THEN
	  CALL NCLHM0(MPHAD,MPHP)		!NEW AREA MAP HISTOGRAM
	  CALL WNMHS7(MPHAD,I1,I2,MPHMXI,R0)	!GET NEW MAX.
	  IF (MPHMXI.GT.CLLIM*MINLIM .AND. 
	1		MDHJ(MDH_NSRC_J).LT.SRCLIM) THEN
	    CALL NCLHIE(MPHP,APHP)		!GET PATCH DATA
	    GOTO 10				!MORE TO DO
	  END IF
	END IF
C
C FINISH SOURCE LIST
C
	CALL NMOAMG				!MERGE COMPONENTS
	CALL NMOPTT(F_TP,RG)			!SHOW TOTAL FLUX
	IF (FCAAP.EQ.0) THEN			!NO MODEL FILE GIVEN
	  CALL NMODAX(J)			!LET USER ACT
	ELSE
	  CALL NMOWRI(FCAAP,-1)			!WRITE SOURCE MODEL
	END IF
C
C RESTORE MAP
C
 20	CONTINUE
	IF (RSTMDL) THEN			!RESTORE MAP
	  CALL NMOHMF(-1,MDHJ)			!SOURCES
          IF (.NOT.WNFOP(FCATMP,WNFFNM('NCL','TMP'),'WT')) THEN
            CALL WNCTXT(F_TP,'Cannot open temporary restore file')
            CALL WNGEX				!STOP
          END IF
	  CALL NCLCWR(FCAMAP,MPH,RMPP,RSNAM)	!START RESTORED MAP
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,MPH,MPHP)) THEN !READ RESIDUAL HEADER
	    CALL WNCTXT(F_TP,'Error reading residual map header')
	    CALL WNGEX				!STOP
	  END IF
	  R0=MPHE(MPH_NOS_E)			!KEEP NOISE
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,RMPH,RMPP)) THEN !READ RESTORED HEADER
	    CALL WNCTXT(F_TP,'Error reading restored map header')
	    CALL WNGEX				!STOP
	  END IF
	  RMPHE(MPH_NOS_E)=R0			!SET NOISE
	  CALL WNCCSX(F_TP,'Restoring')
	  CALL NCLUCL(1,MDHJ(MDH_NSRC_J),FCATMP,0,FCAMAP,FCAMAP,
	1		MDHJ,MPHJ(MPH_MDP_J),RMPP,RMPH,APH)
	  CALL WNCTXT(F_P,'!^')
	  CALL NMAPMH(F_TP,RMPH,RSNAM,NODMAP)	!SHOW RESIDUAL HEADER
	END IF
C
C READY
C
	CALL NCLHIX(MPHP,APHP)			!DELETE BEAM HISTO
	CALL WNFCL(FCATMP)			!CLOSE AND DELETE TMP FILE
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'End')
	CALL WNCTXT(F_TP,' ')
C
	RETURN
C
C
	END

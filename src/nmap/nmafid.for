C+ NMAFID.FOR
C  WNB 910815
C
C  Revisions:
C	WNB 910911	Add type 5 and weights
C	WNB 910912	Add types 1* and band, frequency etc.
C	WNB 910927	Add bandwidths
C	WNB 911105	Change de-beam factors
C	WNB 911115	Change minimum beam factor
C	HjV 920520	HP does not allow extended source lines
C	WNB 920626	FSUM error for 2nd negative factor
C	WNB 920626	Beam/Debeam scale error
C	WNB 920812	Change types < 10 to iterate across 2nd sets
C	WNB 920812	Add loops for SUM
C	WNB 920818	Do not set new noise for copy/extract
C	WNB 920828	Update for line velocities
C	HjV 930311	Change some text 
C	WNB 930602	Use BEMLIM
C	WNB 930826	New beam factors
C	WNB 930928	Multiple instruments for beaming
C	WNB 930930	Use Fiddle codes
C       WNB 940628      Change sign field shift RA
C	CMV 940808	Retain original comment for COPy
C	CMV 940815	Correct call to WNDSTI (FCA(0), not FCA(2))
C	CMV 940929	Clear JSS pointer in output map if different file
C	CMV 941017	Change fieldsize for extract 
C	CMV 951127	Implement CSUM and RSUM
C	CMV 951204	Add RMVAL and weights for RSUM
C       WNB 951212	Correct typo's in MOD(real,integer) funtions
C
	SUBROUTINE NMAFID(TYP)
C
C  Combine/extract/replace maps
C
C  Result:
C
C	CALL NMAFID ( TYP_J:I)		Combine maps:
C					TYP=ADD	Add:	Mout=(F1*M1+F2*M2)
C					TYP=AVE	Average	Mout=(F1*M1+F2*M2)/norm
C					TYP=POL	Pol:	Mout=sqrt(M1**2+M2**2)
C					TYP=ANG	Angle:	Mout=.5*atan(M1,M2)
C					TYP=SUM	Sum:	Mout=sum(Mi)
C					TYP=NSU	Nsum:	Mout=norm. sum(Mi)
C					TYP=BSU	Bsum:	Mout=band sum(Mi)
C					TYP=BNS	BNsum:	Mout=band+norm. sum(Mi)
C					TYP=FSU	Fsum:	Mout=factored sum(Mi)
C					TYP=NSS	Nssum:	Mout=noised sum(Mi)
C					TYP=EXT	Extract	Mout=Area(M1)
C					TYP=COP	Copy:	Mout=M1
C					TYP=BEA	Beam:	M1=M1/primary_beam
C					TYP=DEB	Debeam:	M1=M1*primary_beam
C					TYP=FAC	Factor:	M1=F1*M1
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'GFH_O_DEF'		!FILE HEADER
	INCLUDE 'SGH_O_DEF'		!SUB-GROUP HEADER
	INCLUDE 'MPH_O_DEF'		!MAP HEADER
	INCLUDE 'NMA_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER TYP			!TYPE OF OPERATION
C
C  Function references:
C
	LOGICAL WNFOP			!OPEN FILE
	INTEGER WNFEOF			!FILE LENGTH
	LOGICAL WNFWR			!WRITE DISK
	LOGICAL WNFRD			!READ DISK
	LOGICAL WNDLNF,WNDLNG,WNDLNK	!LINK MAPS
	CHARACTER*32 WNTTSG		!MAP NAME
	LOGICAL NMASTG,NMASTL		!GET SET
	LOGICAL WNDSTR			!RESET SET SEARCH
	LOGICAL NMOBMF			!GET BEAM RANGE
	DOUBLE PRECISION NMOBMV		!BEAM VALUES
C
C  Data declarations:
C
	INTEGER FCA(0:2)		!FILE AREAS
	INTEGER HIST			!MAP HISTOGRAM ADDRESS
	LOGICAL LINK			!NEW LINK?
	LOGICAL LFIRST			!FIRST LINK?
	CHARACTER*32 TXT,CS1,CS2	!TEXT DATA
	DOUBLE PRECISION NORM		!NORMALISATION
	REAL NADD
C
	DOUBLE PRECISION FRQ0		!REFERENCE FRQ FOR RSUM
	DOUBLE PRECISION SAVFRQ		!SAVE FRQ FOR RSUM TEST
	DOUBLE PRECISION THETA		!ROT.ANGLE FOR RSUM
	INTEGER IRM			!LOOP OVER ROT.MEASURES FOR RSUM
	LOGICAL DO_IM			!FLAG RE/IM FOR CSUM/RSUM
	INTEGER POLRE,POLIM		!POLARIZATIONS OF RE and IM MAP
	CHARACTER*2 CPOLRE,CPOLIM	! ALSO AS CHARACTERS
	INTEGER LPSAV(0:7)		!SAVE LOOP VALUES FOR RSUM/CSUM
C
	DOUBLE PRECISION FAC(0:2)	!FACTORS
	INTEGER FAREA(0:3)		!FULL AREA
	INTEGER TAREA(0:3,0:1)		!TOTAL AREA (CENTRE, EDGE)
	INTEGER PAREA(0:3,1,0:1)	!PARTIAL AREAS
	INTEGER MXAREA (0:3)		!MAX. AREA
	INTEGER BORDER(0:1,0:1)		!MAP OUTPUT BORDERS
	INTEGER LSIZE			!LINE SIZE
	INTEGER OUTP			!OUTPUT POINTER
	INTEGER SNAM(0:7,0:2)		!SET NAME
	INTEGER MPHP(0:2)		!MAP HEADER POINTER
	BYTE MPH(0:MPHHDL-1,0:2)		!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1,0:2)
	  INTEGER MPHJ(0:MPHHDL/4-1,0:2)
	  REAL MPHE(0:MPHHDL/4-1,0:2)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1,0:2)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	REAL DAT(0:8191,0:1)		!MAP LINE INPUT
	REAL ODAT(0:8191)		!MAP LINE OUTPUT
C-
C
C INIT
C
	CALL WNCTXT(F_T,'Initialising files and histograms')
	DO I=0,7				!SAVE LOOP INFO
	  LPSAV(I)=LPOFF(I)
	END DO
	LFIRST=.TRUE.				!FIRST LINK
	IRM=0					!FOR LOOP OVER ROT.MEASURES
	IF (.NOT.WNFOP(FCA(0),FILIN(1),'U')) THEN !OPEN INPUT/OUTPUT
	  CALL WNCTXT(F_TP,'Cannot open !AS',FILIN(1))
	  GOTO 900
	END IF
	FCA(1)=FCA(0)				!ASSUME SAME
	IF (TYP.LT.FID_BEA) THEN		!COULD BE SECOND
	  IF (FILIN(2).NE.'*') THEN		!NOT SAME
	    FCA(1)=0				!SET EMPTY
	    IF (TYP.GE.FID_EXT) THEN		!OUTPUT
	      JS=WNFOP(FCA(1),FILIN(2),'U')
	    ELSE
	      JS=WNFOP(FCA(1),FILIN(2),'R')
	    END IF
	    IF (.NOT.JS) THEN
	      CALL WNCTXT(F_TP,'Cannot open !AS',FILIN(2))
	      GOTO 900
	    END IF
	  END IF
	END IF
C
C OUTER LOOP FOR COMPLEX SUMMATION (quick and dirty)
C
	DO_IM=.FALSE.				!FIRST REAL PART
  100	CONTINUE
	NADD=0					!SUMMING	
	CALL WNMHS8(HIST,1,1E0)			!INIT HISTO
	J0=WNDSTR(FCA(0),SETS)			!RESET SET SEARCH
	DO I=0,7				!RESTORE LOOP INFO
	  LPOFF(I)=LPSAV(I)
	END DO
C
C GET SETS
C
	CALL WNCTXT(F_T,'Starting operations...')
	DO WHILE(NMASTL(FCA(0),SETS(0,0,1),MPH(0,0),
	1		MPHP(0),SNAM(0,0),LPOFF)) !GET A SET (LOOPED)
	  IF (TYP.LT.FID_SUM) THEN		!NEED SECOND SET
	    IF (.NOT.NMASTG(FCA(1),SETS(0,0,2),MPH(0,1),
	1		MPHP(1),SNAM(0,1))) THEN !NO SECOND, RECYCLE
	      IF (.NOT.NMASTG(FCA(1),SETS(0,0,2),MPH(0,1),
	1		MPHP(1),SNAM(0,1))) GOTO 900 !NO SECOND, READY
	    END IF
	  ELSE IF (TYP.LT.FID_EXT) THEN		!SUMMATION
	    IF (NADD.EQ.0) THEN			!FIRST ADDITION
	      IF (.NOT.NMASTL(FCA(0),SETS(0,0,1),MPH(0,1),
	1		MPHP(1),SNAM(0,1))) GOTO 900 !GET A SET
	      IF (TYP.EQ.FID_CSU .OR. TYP.EQ.FID_RSU) THEN
	         FRQ0=MPHD(MPH_FRQ_D,0)		!REF FRQ (RSUM)
	         POLRE=SNAM(3,0)		!SAVE POL. CHANNELS
	         POLIM=SNAM(3,1)
	         CALL WNGMFS(MPH_POL_N,MPH(MPH_POL_1,0),CPOLRE)
	         CALL WNGMFS(MPH_POL_N,MPH(MPH_POL_1,1),CPOLIM)
	         IF (DO_IM) THEN
	            CALL WNCTXT(F_TP,
	1		'Making imaginary part (!A2)',CPOLIM)
	         ELSE
	            CALL WNCTXT(F_TP,
	1	        'Making real part (!A2)',CPOLRE)
	         END IF
	      END IF
	    ELSE				!MORE ADDITIONS
	      MPHP(1)=MPHP(2)			!INPUT=OUTPUT
	      CALL WNGMV(MPHHDL,MPH(0,2),MPH(0,1))
 	      CALL WNGMV(8*LB_J,SNAM(0,2),SNAM(0,1))
	      FCA(1)=FCA(2)
	      IF (TYP.EQ.FID_CSU .OR. TYP.EQ.FID_RSU) THEN
	         IF (MOD(NADD+1,2.).EQ.1 .AND.
	1	     SNAM(3,0).NE.POLIM) THEN
	            CALL WNCTXT(F_TP,
	1		'Unexpected pol. !UJ for Im(U) map',
	1		SNAM(3,0))
	         ELSE IF (MOD(NADD+1,2.).EQ.0 .AND.
	1	          SNAM(3,0).NE.POLRE) THEN
	            CALL WNCTXT(F_TP,
	1		'Unexpected pol. !UJ for Re(Q) map',
	1		SNAM(3,0))
	         END IF
	      END IF
	    END IF
	  END IF
C
C CHECK IF CAN DO
C
	  IF (TYP.LT.FID_EXT) THEN		!NEED 2 EQUAL SIZES
	    IF (MPHJ(MPH_NRA_J,0).NE.MPHJ(MPH_NRA_J,1) .OR.
	1		MPHJ(MPH_NDEC_J,0).NE.MPHJ(MPH_NDEC_J,1)) THEN
	      CALL WNCTXT(F_TP,'Unequal map sizes in Sets !AS and !AS',
	1		WNTTSG(SNAM(0,0),0),WNTTSG(SNAM(0,1),0))
	      GOTO 10				!TRY NEXT PAIR
	    END IF
	  END IF
C
C GET AREA
C
	  IF (TYP.EQ.FID_EXT .AND. NADD.EQ.0) THEN !FIRST EXTRACT
	    DO I=0,3				!INIT
	      TAREA(I,0)=0
	      FAREA(I)=0
	      MXAREA(I)=0
	    END DO
	    FAREA(2)=MPHJ(MPH_NRA_J,0)
	    FAREA(3)=MPHJ(MPH_NDEC_J,0)
	    MXAREA(2)=FAREA(2)
	    MXAREA(3)=FAREA(3)
	    TAREA(2,0)=FAREA(2)
	    TAREA(3,0)=FAREA(3)
	    CALL NMADAR(1,J0,FAREA,8,MXAREA,TAREA(0,0),PAREA(0,1,0),
	1		TAREA(0,1),PAREA(0,1,1)) !GET AREA
	    IF (J0.LE.0) GOTO 900		!NO AREA
	    FTSIZ(0)=TAREA(2,1)			!DEC
	    FTSIZ(1)=TAREA(3,1)
	    OUTSIZ(0)=TAREA(0,1)		!RA
	    OUTSIZ(1)=TAREA(1,1)
	  END IF
C
C GET OUTPUT DATA
C
	  LINK=.TRUE.				!ASSUME NEW LINK
	  IF (TYP.LT.FID_SUM) THEN		!COMBINE
	    OUTP=WNFEOF(FCA(0))			!NEW MAP
	    NODOUT=NODIN(1)			!OUTPUT NAME
	    FCA(2)=FCA(0)			!OUTPUT=INPUT
	    CALL WNGMV(MPHHDL,MPH(0,0),MPH(0,2)) !NEW HEADER
	  ELSE IF (TYP.LT.FID_EXT) THEN		!SUMMATION
	    IF (NADD.EQ.0) THEN			!FIRST
	      OUTP=WNFEOF(FCA(0))
	      FCA(2)=FCA(0)			!OUTPUT=INPUT
	      NODOUT=NODIN(1)			!OUTPUT NAME
	      CALL WNGMV(MPHHDL,MPH(0,0),MPH(0,2)) !NEW HEADER
	    ELSE
	      OUTP=MPHJ(MPH_MDP_J,2)		!OLD
	      LINK=.FALSE.
	    END IF
	  ELSE IF (TYP.LT.FID_BEA) THEN
	    OUTP=WNFEOF(FCA(1))			!NEW MAP
	    FCA(2)=FCA(1)			!MAYBE NEW OUTPUT
	    NODOUT=NODIN(2)			!OUTPUT NAME
	    CALL WNGMV(MPHHDL,MPH(0,0),MPH(0,2)) !NEW HEADER
	  ELSE
	    OUTP=MPHJ(MPH_MDP_J,0)		!OVERWRITE INPUT
	    FCA(2)=FCA(0)			!OUTPUT=INPUT
	    NODOUT=NODIN(1)			!OUTPUT NAME
	    CALL WNGMV(MPHHDL,MPH(0,0),MPH(0,2)) !NEW HEADER
	    LINK=.FALSE.
	    CALL WNGMV(8*LB_J,SNAM(0,0),SGNR(0)) !SAVE NAME
	    MPHP(2)=MPHP(0)			!MAP HEADER
	  END IF
C
C NORMALISATION
C
	  NADD=NADD+1				!COUNT MAPS
	  NORM=1				!ASSUME 1
	  FAC(0)=1				!DEFAULT FACTORS
	  FAC(1)=0
	  IF (TYP.LT.FID_POL) THEN		!ADD
	    FAC(0)=POLT(0,0)			!FACTORS
	    FAC(1)=POLT(1,0)
	    IF (TYP.EQ.FID_AVE) THEN		!AVERAGE
	      NORM=ABS(POLT(0,0))+ABS(POLT(1,0))
	    END IF
	  ELSE IF (TYP.LT.FID_SUM) THEN		!POL.
	    FAC(0)=1
	    FAC(1)=1
	  ELSE IF (TYP.LT.FID_EXT) THEN		!SUMMATION
	    IF (TYP.EQ.FID_SUM) THEN		!SUM
	      FAC(1)=NADD
	    ELSE IF (TYP.EQ.FID_NSU) THEN	!NSUM
	      FAC(0)=MPHD(MPH_SUM_D,0)
	      FAC(1)=MPHD(MPH_SUM_D,1)
	    ELSE IF (TYP.EQ.FID_BSU) THEN	!BSUM
	      FAC(0)=MPHD(MPH_BDW_D,0)
	      FAC(1)=MPHD(MPH_BDW_D,1)
	    ELSE IF (TYP.EQ.FID_BNS) THEN	!BNSUM
	      FAC(0)=MPHD(MPH_SUM_D,0)*MPHD(MPH_BDW_D,0)
	      FAC(1)=MPHD(MPH_SUM_D,1)*MPHD(MPH_BDW_D,1)
	    ELSE IF (TYP.EQ.FID_FSU) THEN	!FSUM
	      IF (NADD.EQ.1) THEN
	        FAC(0)=POLT(-2+MOD(NADD-1,8.),0)
	        FAC(2)=POLT(-2+MOD(NADD,8.),0)
	      ELSE
	        FAC(0)=POLT(-2+MOD(NADD,8.),0)
	      END IF
	      FAC(1)=FAC(2)
	      FAC(2)=ABS(FAC(2))+ABS(FAC(0))	!!920626
	    ELSE IF (TYP.EQ.FID_CSU) THEN	!CSUM	      
	      IF (NADD.EQ.1) THEN
	        FAC(2)=0			! RESET TOTAL WEIGHT
	        IF (DO_IM) THEN			! Bn*REn + An*IMn
	          FAC(0)=  POLT(-2+NADD,0)
	          FAC(1)=  POLT(-2+NADD-1,0)
	        ELSE				! An*REn - Bn*IMn
	          FAC(0)=  POLT(-2+NADD-1,0)
	          FAC(1)= -POLT(-2+NADD,0)
	        END IF
	      ELSE IF (DO_IM) THEN		! Swap An/Bn
	        IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	          FAC(0)= POLT(-2+NADD+1,0)
	        ELSE				! Im input map
	          FAC(0)= POLT(-2+NADD-1,0)
	        END IF
	      ELSE				! Negative Bn
	        IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	          FAC(0)=  POLT(-2+NADD,0)
	        ELSE				! Im input map
	          FAC(0)= -POLT(-2+NADD,0)
	        END IF
	      END IF
C
	      IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	        FAC(1)=FAC(2)
	        NORM=1.
	      ELSE				! Im input map
	        IF (NADD.NE.1) FAC(1)= 1.	! First (Re,Im) pair
	        FAC(2)=FAC(2)+SQRT(POLT(-2+NADD  ,0)**2+
	1			   POLT(-2+NADD-1,0)**2)
	        NORM=FAC(2)
	      END IF
	      CALL WNCTXT(F_TP,'CSUM Fac: !D9.2 , !D9.2',FAC(0),FAC(1))
C
	    ELSE IF (TYP.EQ.FID_RSU) THEN	!RSUM
C
C  Check frequencies and calculate rot.angle
C
	      IF ((NADD.EQ.1 .AND.
	1	    MPHD(MPH_FRQ_D,0).NE.MPHD(MPH_FRQ_D,1)) .OR.
	1	  (NADD.GT.1 .AND. MOD(NADD,2.).NE.0 .AND.
	1	    MPHD(MPH_FRQ_D,0).NE.SAVFRQ) ) THEN
		CALL WNCTXT(F_TP,
	1		'Input !AS and !AS not same frequency',
	1		CPOLRE,CPOLIM)
	      ELSE IF (MOD(NADD,2.).EQ.0) THEN
	        SAVFRQ=MPHD(MPH_FRQ_D,0)	!SAVE FREQUENCY Re MAP
	      END IF
C
	      THETA=2.*RMVAL(IRM)*( 
	1		(DCL*1D-6/FRQ0)**2 -
	1		(DCL*1D-6/MPHD(MPH_FRQ_D,0))**2)	!ROT.ANGLE
C
	      IF (NADD.EQ.1) THEN
	        FAC(2)=0			! RESET TOTAL WEIGHT
	        IF (DO_IM) THEN			! Bn*REn + An*IMn
	          FAC(0)=  SIN(THETA)
	          FAC(1)=  COS(THETA)
	        ELSE				! An*REn - Bn*IMn
	          FAC(0)=  COS(THETA)
	          FAC(1)= -SIN(THETA)
	        END IF
	      ELSE IF (DO_IM) THEN		! Swap An/Bn
	        IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	          FAC(0)= SIN(THETA)
	        ELSE				! Im input map
	          FAC(0)= COS(THETA)
	        END IF
	      ELSE				! Negative Bn
	        IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	          FAC(0)=  COS(THETA)
	        ELSE				! Im input map
	          FAC(0)= -SIN(THETA)
	        END IF
	      END IF
C
	      I2=NADD/2
	      D0=POLT(-2+MOD(I2,8),0)		! Weight factor
	      FAC(0)=FAC(0)*D0			! Weight input map
	      IF (MOD(NADD,2.).EQ.0) THEN	! Re input map
	        FAC(1)=FAC(2)			! Undo normalisation
	        NORM=1.
	      ELSE				! Im input map
	        IF (NADD.NE.1) THEN
		   FAC(1)= 1.
		ELSE				! First (Re,Im) pair
		   FAC(1)=FAC(1)*D0		! Weight second input map
		END IF
	        FAC(2)=FAC(2)+D0		!Total weight
	        NORM=FAC(2)
	      END IF
	      CALL WNCTXT(F_TP,
	1	'RSUM Fac: !D6.4, !D6.4, Norm !D6.2, '//
	1	'Theta !D9.4 deg, RM=!E9.3, FRQ=!D9.4',
	1	FAC(0),FAC(1),NORM,THETA/PI2*180,
	1	RMVAL(IRM),MPHD(MPH_FRQ_D,0))
C
	    ELSE IF (TYP.EQ.FID_NSS) THEN	!NSSUM
	      DO I=0,1
	        IF (MPHE(MPH_NOS_E,I).NE.0) THEN
	          FAC(I)=1./(MPHE(MPH_NOS_E,I)**2)
	        ELSE
	          FAC(I)=0
	        END IF
	      END DO
	    END IF
	    IF (TYP.NE.FID_CSU .AND. TYP.NE.FID_RSU) THEN
	       NORM=ABS(FAC(0))+ABS(FAC(1))
	    END IF
	  ELSE IF (TYP.EQ.FID_FAC) THEN
	    FAC(0)=POLT(0,0)
	  END IF
	  IF (NORM.NE.0) THEN
	    NORM=1/NORM
	  ELSE
	    NORM=1
	  END IF
C
C SET BORDERS
C
	  IF (TYP.EQ.FID_EXT) THEN		!SET BORDERS
	    BORDER(0,0)=FTSIZ(0)+MPHJ(MPH_NDEC_J,0)/2 !DEC LOW
	    BORDER(1,0)=FTSIZ(1)+MPHJ(MPH_NDEC_J,0)/2 !DEC HIGH
	    BORDER(0,1)=OUTSIZ(0)+MPHJ(MPH_NRA_J,0)/2 !RA LOW
	    BORDER(1,1)=OUTSIZ(1)+MPHJ(MPH_NRA_J,0)/2 !RA HIGH
	  ELSE
	    BORDER(0,0)=0			!DEC LOW
	    BORDER(1,0)=MPHJ(MPH_NDEC_J,0)-1	!DEC HIGH
	    BORDER(0,1)=0			!RA LOW
	    BORDER(1,1)=MPHJ(MPH_NRA_J,0)-1	!RA HIGH
	  END IF
	  LSIZE=BORDER(1,1)-BORDER(0,1)+1	!LENGTH LINE
C
C PREPARE OUTPUT HEADER
C
	  CALL WNMHS9(HIST)			!CLEAR HISTO
	  CALL WNMHS8(HIST,1,1E0)		!INIT HISTO
	  MPHI(MPH_PCD_I,2)=1			!INDICATE FIDDLE
	  MPHD(MPH_SHR_D,2)=MPHD(MPH_SHR_D,2)+MPHD(MPH_SRA_D,2)*
	1		((BORDER(0,1)+BORDER(1,1)+1)/2-MPHJ(MPH_ZRA_J,2))
	  MPHD(MPH_SHD_D,2)=MPHD(MPH_SHD_D,2)+MPHD(MPH_SDEC_D,2)*
	1		((BORDER(0,0)+BORDER(1,0)+1)/2-MPHJ(MPH_ZDEC_J,2))
	  MPHJ(MPH_NRA_J,2)=LSIZE		!LENGTH LINE
	  MPHJ(MPH_NDEC_J,2)=BORDER(1,0)-BORDER(0,0)+1 !# OF LINES
	  MPHE(MPH_FRA_E,2)=MPHJ(MPH_NRA_J,2)*MPHD(MPH_SRA_D,2) !FIELD SIZE RA
	  MPHE(MPH_FDEC_E,2)=MPHJ(MPH_NDEC_J,2)*MPHD(MPH_SDEC_D,2) !IDEM DEC
	  MPHJ(MPH_ZRA_J,2)=LSIZE/2		!CENTRE POINT
	  MPHJ(MPH_ZDEC_J,2)=(BORDER(1,0)-BORDER(0,0)+1)/2 !CENTRE LINE
	  MPHJ(MPH_MXR_J,2)=0			!POS. MAX/MIN
	  MPHJ(MPH_MXD_J,2)=0
	  MPHJ(MPH_MNR_J,2)=0
	  MPHJ(MPH_MND_J,2)=0
	  MPHE(MPH_MAX_E,2)=-1E36		!MAX.
	  MPHE(MPH_MIN_E,2)=1E36		!MIN.
	  IF (TYP.LT.FID_EXT) THEN
	    MPHJ(MPH_NPT_J,2)=MPHJ(MPH_NPT_J,0)+MPHJ(MPH_NPT_J,1) !# OF POINTS
	    MPHJ(MPH_NBL_J,2)=MPHJ(MPH_NBL_J,0)+MPHJ(MPH_NBL_J,1) !# OF BASEL.
	    MPHJ(MPH_NST_J,2)=MPHJ(MPH_NST_J,0)+MPHJ(MPH_NST_J,1) !# OF SETS
	    IF (TYP.NE.FID_POL .AND. TYP.NE.FID_ANG) THEN !NOT POL.
	      D0=ABS(FAC(0))+ABS(FAC(1))
	      IF (D0.NE.0) THEN
	        MPHD(MPH_BDW_D,2)=MPHD(MPH_BDW_D,0)+
	1		MPHD(MPH_BDW_D,1)
	        MPHD(MPH_FRQ_D,2)=(MPHD(MPH_FRQ_D,0)*ABS(FAC(0))+
	1		MPHD(MPH_FRQ_D,1)*ABS(FAC(1)))/D0
	        MPHD(MPH_FRQO_D,2)=(MPHD(MPH_FRQO_D,0)*ABS(FAC(0))+
	1		MPHD(MPH_FRQO_D,1)*ABS(FAC(1)))/D0
	        MPHE(MPH_VEL_E,2)=(MPHE(MPH_VEL_E,0)*ABS(FAC(0))+
	1		MPHE(MPH_VEL_E,1)*ABS(FAC(1)))/D0
	        MPHE(MPH_VELR_E,2)=(MPHE(MPH_VELR_E,0)*ABS(FAC(0))+
	1		MPHE(MPH_VELR_E,1)*ABS(FAC(1)))/D0
	        MPHD(MPH_FRQC_D,2)=(MPHD(MPH_FRQC_D,0)*ABS(FAC(0))+
	1		MPHD(MPH_FRQC_D,1)*ABS(FAC(1)))/D0
	        MPHD(MPH_FRQ0_D,2)=(MPHD(MPH_FRQ0_D,0)*ABS(FAC(0))+
	1		MPHD(MPH_FRQ0_D,1)*ABS(FAC(1)))/D0
	        MPHD(MPH_FRQV_D,2)=(MPHD(MPH_FRQV_D,0)*ABS(FAC(0))+
	1		MPHD(MPH_FRQV_D,1)*ABS(FAC(1)))/D0
	      END IF
	    END IF
	  END IF
	  D0=MPHD(MPH_SUM_D,1)*(FAC(0)**2)+
	1		MPHD(MPH_SUM_D,0)*(FAC(1)**2)
	  IF (TYP.LT.FID_EXT) THEN		!NORM. SUM
	    IF (D0.GT.1E-6) THEN
	      MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)*MPHD(MPH_SUM_D,1)/
	1			NORM/NORM/D0
	    ELSE
	      MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)
	    END IF
	  ELSE IF (TYP.LT.FID_BEA) THEN
	    MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)
	  ELSE IF (TYP.EQ.FID_FAC) THEN
	    IF (POLT(0,0).NE.0) THEN
	      MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)/(POLT(0,0)**2)
	    ELSE
	      MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)
	    END IF
	  ELSE
	    MPHD(MPH_SUM_D,2)=MPHD(MPH_SUM_D,0)
	  END IF
	  IF (TYP.EQ.FID_POL) THEN		!POL. TYPE
	    CALL WNGMFS(MPH_POL_N,'PI',MPH(MPH_POL_1,2))
	  ELSE IF (TYP.EQ.FID_ANG) THEN
	    CALL WNGMFS(MPH_POL_N,'PA',MPH(MPH_POL_1,2))
	  ELSE IF (TYP.EQ.FID_CSU.OR.TYP.EQ.FID_RSU) THEN
	    IF (DO_IM) THEN
	      CALL WNGMFS(MPH_POL_N,CPOLIM,MPH(MPH_POL_1,2))
	    ELSE
	      CALL WNGMFS(MPH_POL_N,CPOLRE,MPH(MPH_POL_1,2))
	    END IF
	  END IF
	  IF (TYP.EQ.FID_ADD) THEN		!COMMENT
	    CALL WNCTXS(TXT,'!E9.2\*!AS\+!E9.2\*!AS',
	1		POLT(0,0),WNTTSG(SNAM(0,0),0),
	1		POLT(1,0),WNTTSG(SNAM(0,1),0))
	  ELSE IF (TYP.EQ.FID_AVE) THEN
	    CALL WNCTXS(TXT,'Norm. !E9.2\*!AS\+!E9.2\*!AS',
	1		POLT(0,0),WNTTSG(SNAM(0,0),0),
	1		POLT(1,0),WNTTSG(SNAM(0,1),0))
	  ELSE IF (TYP.EQ.FID_POL) THEN
	    CALL WNCTXS(TXT,'Pol. I !AS\ and !AS',
	1		WNTTSG(SNAM(0,0),0),
	1		WNTTSG(SNAM(0,1),0))
	  ELSE IF (TYP.EQ.FID_ANG) THEN
	    CALL WNCTXS(TXT,'Pol. angle !AS\ and !AS',
	1		WNTTSG(SNAM(0,0),0),
	1		WNTTSG(SNAM(0,1),0))
	  ELSE IF (TYP.EQ.FID_SUM) THEN
	    CALL WNCTXS(TXT,'Sum of maps')
	  ELSE IF (TYP.EQ.FID_NSU) THEN
	    CALL WNCTXS(TXT,'Nsum of maps')
	  ELSE IF (TYP.EQ.FID_BSU) THEN
	    CALL WNCTXS(TXT,'Bsum of maps')
	  ELSE IF (TYP.EQ.FID_BNS) THEN
	    CALL WNCTXS(TXT,'BNsum of maps')
	  ELSE IF (TYP.EQ.FID_FSU) THEN
	    CALL WNCTXS(TXT,'Fsum of maps')
	  ELSE IF (TYP.EQ.FID_CSU) THEN
	    IF (DO_IM) THEN
	      CALL WNCTXS(TXT,'Csum (Im)')
	    ELSE
	      CALL WNCTXS(TXT,'Csum (Re)')
	    END IF
	  ELSE IF (TYP.EQ.FID_RSU) THEN
	    IF (DO_IM) THEN
	      CALL WNCTXS(TXT,'Rsum (!AS) RM=!E9.3',
	1			CPOLIM,RMVAL(IRM))
	    ELSE
	      CALL WNCTXS(TXT,'Rsum (!AS) RM=!E9.3',
	1			CPOLRE,RMVAL(IRM))
	    END IF
	  ELSE IF (TYP.EQ.FID_NSS) THEN
	    CALL WNCTXS(TXT,'NSsum of maps')
	  ELSE IF (TYP.EQ.FID_EXT) THEN
	    CALL WNCTXS(TXT,'Extract from !AS',
	1		WNTTSG(SNAM(0,0),0))
	  ELSE IF (TYP.EQ.FID_COP) THEN
C	    CALL WNCTXS(TXT,'Copy from !AS',
C	1		WNTTSG(SNAM(0,0),0))
	    CALL WNGMTS(MPH_UCM_N,MPH(MPH_UCM_1,0),TXT)
	  ELSE IF (TYP.EQ.FID_BEA) THEN
	    MPHI(MPH_CD_I+7,2)=MPHI(MPH_CD_I+7,2)+1
	    CALL WNGMTS(MPH_UCM_N,MPH(MPH_UCM_1,0),TXT)
	  ELSE IF (TYP.EQ.FID_DEB) THEN
	    MPHI(MPH_CD_I+7,2)=MPHI(MPH_CD_I+7,2)-1
	    CALL WNGMTS(MPH_UCM_N,MPH(MPH_UCM_1,0),TXT)
	  ELSE IF (TYP.EQ.FID_FAC) THEN
	    CALL WNCTXS(TXT,'!E9.2\*!AS',
	1		POLT(0,0),WNTTSG(SNAM(0,0),0))
	  END IF
	  CALL WNGMFS(MPH_UCM_N,TXT,MPH(MPH_UCM_1,2)) !SET COMMENT
	  MPHJ(MPH_MDP_J,2)=OUTP		!DATA POINTER
C
C GET BEAM FACTOR
C
	  IF (.NOT.NMOBMF(MPHJ(MPH_INST_J,2),
	1		MPHD(MPH_FRQO_D,2))) THEN !RANGE
	    CALL WNCTXT(F_TP,'Cannot get beam information for map !AS',
	1		WNTTSG(SNAM(0,0),1))
	    CALL WNGEX				!STOP
	  END IF
C
C READ DATA
C
	  DO I=BORDER(0,0),BORDER(1,0)		!ALL LINES
C
C SET 1
C
	    IF (.NOT.WNFRD(FCA(0),LB_E*MPHJ(MPH_NRA_J,0),DAT(0,0),
	1		MPHJ(MPH_MDP_J,0)+
	1		LB_E*I*MPHJ(MPH_NRA_J,0))) THEN !READ LINE
	      CALL WNCTXT(F_TP,'Error reading Map !AS',
	1		WNTTSG(SNAM(0,0),1))
	      CALL WNGEX			!STOP
	    END IF
C
C SET 2
C
	    IF (TYP.LT.FID_EXT) THEN		!NEED SET 2
	      IF (.NOT.WNFRD(FCA(1),LB_E*MPHJ(MPH_NRA_J,1),DAT(0,1),
	1		MPHJ(MPH_MDP_J,1)+
	1		LB_E*I*MPHJ(MPH_NRA_J,1))) THEN !READ LINE
	        CALL WNCTXT(F_TP,'Error reading Map !AS',
	1		WNTTSG(SNAM(0,0),1))
	        CALL WNGEX			!STOP
	      END IF
	    END IF
C
C MAKE OUTPUT
C
	    DO I1=BORDER(0,1),BORDER(1,1)	!ALL POINTS
	      IF (TYP.LT.FID_POL) THEN		!ADD/AVERAGE
		ODAT(I1)=FAC(0)*DAT(I1,0)+FAC(1)*DAT(I1,1)
	      ELSE IF (TYP.LT.FID_SUM) THEN	!POL
		R0=SQRT(ABS(DAT(I1,0)**2+DAT(I1,1)**2))
		IF (R0.GE.POLT(0,0)) THEN	!CAN DO
		  IF (TYP.EQ.FID_POL) THEN	!POL. AMPL
	 	    ODAT(I1)=R0
		  ELSE				!POL. ANGLE
		    ODAT(I1)=0.5*ATAN2(DAT(I1,0),DAT(I1,1))
		  END IF
		ELSE
		  ODAT(I1)=0
		END IF
	      ELSE IF (TYP.LT.FID_EXT) THEN	!SUM
		ODAT(I1)=FAC(0)*DAT(I1,0)+FAC(1)*DAT(I1,1)
	      ELSE IF (TYP.EQ.FID_EXT) THEN	!EXTRACT
		ODAT(I1-BORDER(0,1))=DAT(I1,0)
	      ELSE IF (TYP.EQ.FID_COP) THEN	!COPY
		ODAT(I1)=DAT(I1,0)
	      ELSE IF (TYP.LT.FID_FAC) THEN	!BEAM/DEBEAM
		CALL WNMDLM(MPHD(MPH_RA_D,0),MPHD(MPH_DEC_D,0),
	1		((I1-MPHJ(MPH_NRA_J,0)/2)*MPHD(MPH_SRA_D,0)+
	1		MPHD(MPH_SHR_D,0))*DPI2,
	1		((I-MPHJ(MPH_NDEC_J,0)/2)*MPHD(MPH_SDEC_D,0)+
	1		MPHD(MPH_SHD_D,0))*DPI2,
	1		D0,D1)			!RA,DEC POINT
		CALL WNMCRD(MPHD(MPH_RAO_D,0),MPHD(MPH_DECO_D,0),
	1		R0,R1,
	1		D0,D1)			!L,M BEAM POINT
		D0=NMOBMV(MPHD(MPH_FRQO_D,0),R0,R1,
	1		BEMLIM,TYP.NE.FID_BEA)	!VALUE
		ODAT(I1)=D0*DAT(I1,0)		!DO
	      ELSE IF (TYP.EQ.FID_FAC) THEN	!FACTOR
		ODAT(I1)=FAC(0)*DAT(I1,0)
	      ELSE
		ODAT(I1)=DAT(I1,0)		!UNKNOWN
	      END IF
	    END DO				!END POINTS
C
C STATISTICS
C
	    R0=-1E36				!MAX
	    R1=1E36				!MIN
	    CALL WNMFMX(LSIZE,ODAT,NORM,R0,I3,R1,I4) !NORM. AND FIND MAX/MIN
	    IF (R0.GT.MPHE(MPH_MAX_E,2)) THEN	!NEW MAX
	      MPHE(MPH_MAX_E,2)=R0
	      MPHJ(MPH_MXR_J,2)=I3-LSIZE/2
	      MPHJ(MPH_MXD_J,2)=I-(BORDER(1,0)+BORDER(0,0)+1)/2
	    END IF
	    IF (R1.LT.MPHE(MPH_MIN_E,2)) THEN	!NEW MIN
	      MPHE(MPH_MIN_E,2)=R1
	      MPHJ(MPH_MNR_J,2)=I4-LSIZE/2
	      MPHJ(MPH_MND_J,2)=I-(BORDER(1,0)+BORDER(0,0)+1)/2
	    END IF
	    CALL WNMHS1(HIST,LSIZE,ODAT)	!MAKE HISTO
C
C OUTPUT LINE
C
	    IF (.NOT.WNFWR(FCA(2),LB_E*LSIZE,ODAT,OUTP)) THEN
 20	      CONTINUE
	      CALL WNCTXT(F_TP,'Error writing output map')
	      CALL WNGEX			!STOP
	    END IF
	    OUTP=OUTP+LB_E*LSIZE		!NEXT OUTPUT POINTER
C
C NEXT LINE
C
	  END DO
C
C WRITE MAP HEADER
C
	  IF (TYP.LT.FID_SUM .OR. TYP.GE.FID_EXT) THEN !NOT SUM
	    CALL WNMHS3(HIST,1,F_P)		!SHOW HISTOGRAM
	  END IF
	  IF (TYP.GE.FID_EXT .AND. TYP.LT.FID_BEA) THEN !NO NEW NOISE SET
	    CALL WNMHS4(HIST,R0,F_P)		!SHOW NOISE
	  ELSE
	    CALL WNMHS4(HIST,MPHE(MPH_NOS_E,2),F_P) !SET NOISE
	  END IF
	  IF (LINK) THEN			!NEW HEADER
	    MPHP(2)=WNFEOF(FCA(2))		!WHERE TO WRITE
	    CALL WNDSTI(FCA(0),SNAM(0,0))	!MAKE AN INDEX IF NECESSARY
	  END IF
	  IF (FCA(2).NE.FCA(0)) THEN		!JSS NO LONGER THERE
	     MPHJ(MPH_JOBP_J,2)=0		!SO CLEAR IT
	     MPHJ(MPH_JOBL_J,2)=0
	  END IF
	  IF (.NOT.WNFWR(FCA(2),MPHHDL,MPH(0,2),MPHP(2))) GOTO 20 !WRITE HEADER
	  IF (LINK.AND.LFIRST) THEN		!MAKE NEW JOB
	    CALL WNCTXT(F_TP,'Creating new group')
	    IF (.NOT.WNDLNG(GFH_LINKG_1,0,SGH_GROUPN_1,
	1		FCA(2),SGPH(0),SGNR(0))) THEN
 30	      CONTINUE
	      CALL WNCTXT(F_TP,'Error creating sub-group')
	      CALL WNGEX			!STOP
	    END IF
	    LFIRST=.FALSE.
	  END IF
	  IF (LINK) THEN			!RE-LINK
	    I=1					!Same Field
	    IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,SNAM(I,0),
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    I=2					!For sum: channel 0
	    IF (TYP.GE.FID_SUM.AND.TYP.LT.FID_EXT) THEN
	      IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,0,
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    ELSE				!Else: same channel
	      IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,SNAM(I,0),
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    END IF
	    I=3					!For Pol/Ang: pol 0
	    IF (TYP.EQ.FID_POL .OR. TYP.EQ.FID_ANG) THEN
	      IF (.NOT.WNDLNG(SGPH(I-1)+SGH_LINKG_1,0,SGH_GROUPN_1,
	1		FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    ELSE IF (TYP.EQ.FID_CSU .OR. TYP.EQ.FID_RSU) THEN
	      IF (DO_IM) THEN			!Imaginary output map
	        IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,POLIM,
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	      ELSE				!Real output map
	        IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,POLRE,
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	      END IF
	    ELSE				!Else same pol
	      IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,SNAM(I,0),
	1		SGH_GROUPN_1,FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    END IF
	    I=4					!Same Type
	    IF (.NOT.WNDLNF(SGPH(I-1)+SGH_LINKG_1,SNAM(I,0),SGH_GROUPN_1,
	1		FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    I=5					!Same Map
	    IF (.NOT.WNDLNK(GFH_LINK_1,MPHP(2),MPH_SETN_1,
	1		FCA(2))) GOTO 30
	    IF (.NOT.WNDLNG(SGPH(I-1)+SGH_LINKG_1,MPHP(2),SGH_GROUPN_1,
	1		FCA(2),SGPH(I),SGNR(I))) GOTO 30
	    IF (.NOT.WNFRD(FCA(2),MPHHDL,MPH(0,2),MPHP(2))) GOTO 30 !HEADER
	  END IF
	  SGNR(6)=-1				!END NAME
	  CS1=WNTTSG(SNAM(0,0),0)		!Input set 1
	  CS2=WNTTSG(SNAM(0,1),0)		!Input set 2
	  IF (TYP.LT.FID_EXT) THEN
	     CALL WNCTXT(F_T,'!AS, !AS -> !AS',
	1	                CS1,CS2,WNTTSG(SGNR,0))
	  ELSE 
	     CALL WNCTXT(F_T,'!AS -> !AS',CS1,WNTTSG(SGNR,0))
	  END IF
	  CALL WNGMV(8*LB_J,SGNR(0),SNAM(0,2))
C
	  IF (TYP.LT.FID_SUM .OR. TYP.GE.FID_EXT) THEN !NOT SUM
	    CALL WNCTXT(F_P,'!^')
	    CALL NMAPMH(F_P,MPH(0,2),SGNR,NODOUT) !PRINT HEADER
	  END IF
C
C NEXT SET
C
 10	  CONTINUE
	END DO
C
C SHOW HISTO
C
	IF (TYP.GE.FID_SUM .AND. TYP.LT.FID_EXT .AND. NADD.GT.0) THEN
	  CALL WNMHS3(HIST,1,F_P)		!SHOW HISTOGRAM
	  CALL WNCTXT(F_P,'!^')
	  CALL NMAPMH(F_P,MPH(0,2),SGNR,NODOUT) !PRINT HEADER
	END IF
C
C MAKE IMAGINARY PART IF NEEDED (quick and dirty loop)
C
	IF (TYP.EQ.FID_CSU.OR.TYP.EQ.FID_RSU) THEN
	   IF (.NOT.DO_IM) THEN
	     DO_IM=.TRUE.		! IMAGINARY PART NOW
	     CALL WNMHS9(HIST)		! CLEAR HISTO
	     GOTO 100			! OFF AND GO
	   ELSE IF (TYP.EQ.FID_RSU) THEN	!LOOP OVER ROT.MEASURES
	     IRM=IRM+1
	     IF (IRM.LT.NLAB) THEN	! MORE VALUES LEFT?
	       DO_IM=.FALSE.		! REAL PART FIRST
	       LFIRST=.TRUE.		! MAKE NEW GROUP
	       CALL WNMHS9(HIST)	! CLEAR HISTO
	       GOTO 100			! OFF AND GO
	     END IF
	   END IF
	END IF
C
C READY
C
 900	CONTINUE
	CALL WNMHS9(HIST)			!CLEAR HISTO
	CALL WNFCL(FCA(0))			!CLOSE FILES
	CALL WNFCL(FCA(1))
C
	RETURN
C
C
	END

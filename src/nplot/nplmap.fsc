C+ NPLMAP.FOR
C  WNB 910619
C
C  Revisions:
C	WNB 911217	Change to WNP/WQ
C	WNB 911220	Add loops, pol., ruled surface
C	WNB 920130	Change multiple pages
C	WNB 920423	Allow UV-plane coordinates
C	HjV 920728	Change annotation for contours: 
C				Print 9 iso. 15 values per line
C	WNB 920811	Change limited range to white at top end
C	HjV 920827	Change character expansion for plot-info
C	WNB 930401	Do shading first; then plots; then coordinates
C	HjV 930423	Change some text
C	HjV 930705	RULE plot horizontal plotted
C	WNB 931018	RULE plot horizontal small errors
C	CMV 931130	Plot markers in color for X11
C	HjV 940131	Small error RULE PLOT when SIZE <> 1,1
C	CMV 940420	Option to annotate sources in plot
C	CMV 940428	Use NMONAM to get proper names for annotation
C	CMV 940622	Option to connect sources and annotate
C	WNB 940624	Correct len statement
C	CMV 940817	Options to ignore pixel coordinate axes
C	CMV 940829	Correct linetype of rotation vectors if overlayed
C	CMV 940930	More spacing between annotation and axis
C	HjV 941205	Fix bug with RA =~ 0.0 (No coordinates plotted)
C	HjV 950711	Add PLTHDR (Plot heading)
C	JPH 960812	Control-C handling
C	JPH 960815	Display user comment from MPH
C			Report first map index on terminal
C	WNB 970521	Plot coordinates as contours above DEC=80 deg
C	WNB 970527	Adjustment for very special cases above 80 deg
C	WNB 970604	Further sdjustment for very special cases at pole
C	WNB 970605	Default COORD_PREC to 256
C	HjV 970723	Remove control-C stuff (commented out with CCC)
C
	SUBROUTINE NPLMAP
C
C  Plot maps
C
C  Result:
C
C	CALL NPLMAP		Plot maps
C
C  PIN references:
C
C       SOURCES
C	TEXT
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'MPH_O_DEF'
	INCLUDE 'MDH_O_DEF'		!MODEL HEADER
	INCLUDE 'MDL_O_DEF'		!MODEL LINE
	INCLUDE 'STH_O_DEF'		!SET HEADER
	INCLUDE 'NPL_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
C
C  Function references:
C
	LOGICAL WQ_MPAGE		!OPEN PLOT DEVICE
	LOGICAL WNFRD			!READ DISK
	LOGICAL WNDPAR			!GET USER INPUT
	INTEGER WNMEJC			!CEIL(X)
	INTEGER WNMEJF			!FLOOR(X)
	INTEGER WNCALN			!STRING LENGTH
CCC	INTEGER WNGCCN			! check control-C's
	CHARACTER*32 WNTTSG		!SET NAME
	LOGICAL NMASTL			!GET MAP
	LOGICAL WNGGVA			!GET MEMORY
	DOUBLE PRECISION WNGDPF,WNGDNF	!NORMALISE ANGLE
	REAL WNGENF			!NORMALISE ANGLE
	DOUBLE PRECISION WNGDPD,WNGDND	!NORMALISE ANGLE
	LOGICAL NMONAM			!FIND PROPER NAME
C
C  Data declarations:
C
	CHARACTER*32 DUSER              !USERNAME
	INTEGER NHV(0:1)		!# PAGES
	INTEGER MXNHV(0:1)		!MAX. # OF PAGES
	INTEGER NRPLT			!SET COUNT
	INTEGER STARTJ			!USED FOR RULE
	INTEGER BUFPTR,BFPTRE		!TRANSPOSE BUFFER ADDR
	INTEGER LSIZE			!BYTES PER RA NEEDED
	INTEGER RPPD			!RA POINTS PER DEC
	INTEGER RA_AX,DEC_AX		!RA-AXIS, DEC-AXIS
	INTEGER RA_PP			!RA PER POINT
	INTEGER NRPNTS			!NR. OF POINTS TO DE
	INTEGER MEMUSE			!MEMORY TO USE
	INTEGER OFFRA,OFFDEC		!ADDR OFFSET FOR RA AND DEC
	REAL STEP(2)			!X,Y DISTANCE BETWEEN POINTS
	LOGICAL UVPL			!UV-PLANE OUTPUT
	CHARACTER*132 STR		!ANNOTATION
	CHARACTER*10 NAMES(2)		!SOURCE NAMES (INPUT)
	REAL RD(2,2)			!SOURCE COORDINATES
	INTEGER KI,KJ,KT		!IFR COUNTS
	CHARACTER*16 TSTR		!TEL. NAMES
	  DATA TSTR/'0123456789ABCDEF'/
	REAL PC(2)			!LOWER LEFT CORNER
	REAL PCD(2,2)			!PLOT STEPS
	REAL PGRD(2,0:64)		!COORDINATE LINES
	  REAL PGRD1(0:128)
	  EQUIVALENCE(PGRD,PGRD1)
	REAL WEDGE(0:256)		!WEDGE
	REAL WRANGE(2)			!WEDGE INTENSITY RANGE
	  DATA WRANGE/0.,256./
	INTEGER CID1,CID2,SID,CIDC2	!CONTOUR/SHADING ID
	  DATA CID1,CID2,SID,CIDC2/0,0,0,0/
	INTEGER CONTLP,CONTP,CONTPE     !LENGTH, POINTER, E_PTR COORD CONTOURS
	INTEGER COCOLP,COCOP,COCOPE	!LENGTH, PTR, E_PTR COORD. BUFFER
	INTEGER PID1,PID2		!POL, RULED ID
	  DATA PID1,PID2/0,0/
	REAL LBUF(0:4095)		!DATA BUFFER
	REAL ABUF(0:4095)		!ANGLE BUFFER
	INTEGER GRTAB1(19)		!TEST TABLE INCREMENT
	  DATA GRTAB1/1,2,5,10,30,60,120,300,600,1800,3600,
	1			7200,18000,36000,72000,180000,360000,
	1			720000,1440000/
	INTEGER GRTAB(22)		!TEST TABLE INCREMENT
	  DATA GRTAB/1,2,5,10,20,50,100,200,500,1000,2000,5000,
	1			10000,20000,50000,100000,200000,500000,
	1			1000000,2000000,5000000,10000000/
	REAL DIR(2,2)			!TEXT DIRECTION
	  DATA DIR/0.,1.,-1.,0/		!HORIZONTAL, VERTICAL
	REAL L,M			!L,M POSITIONS
	DOUBLE PRECISION RA,DEC		!RA, DEC POSITIONS
	REAL FSC,FSCSGN			!RA, DEC SCALE
	LOGICAL PLCR			!PLOT CROSS
	LOGICAL FIRST			! new plot
	LOGICAL DONE			!DONE WITH EDIT LOOP?
	DOUBLE PRECISION SAVRA(2)	!SAVE APPARENT COORDINATES
	DOUBLE PRECISION CCRD(2,4)	!CORNER RA,DEC
	CHARACTER*12 TXTT1
	CHARACTER*24 TXTT2
	REAL R2,R3,R4,R5,R6,R0C
	INTEGER J6
	REAL CHREXP			!CHARACTER EXPANSION
	  DATA CHREXP/0.7/
	INTEGER MPHP,MPHP1		!MAP POINTER
	INTEGER SETNAM1(0:7)		!SET NAME
	BYTE MPH(0:MPHHDL-1)		!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1)
	  INTEGER MPHJ(0:MPHHDL/4-1)
	  REAL MPHE(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	BYTE MPH1(0:MPHHDL-1)		!MAP HEADER
	  INTEGER*2 MPH1I(0:MPHHDL/2-1)
	  INTEGER MPH1J(0:MPHHDL/4-1)
	  REAL MPH1E(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPH1D(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH1,MPH1I,MPH1J,MPH1E,MPH1D)
	BYTE MDL(0:MDLHDL-1)		!MODEL LINE
	  INTEGER MDLJ(0:MDLHDL/LB_J-1)
	  REAL MDLE(0:MDLHDL/LB_E-1)
	  EQUIVALENCE (MDL,MDLJ,MDLE)
	BYTE GDES(0:MDHHDL-1)		!MODEL HEADER
	  INTEGER GDESJ(0:MDHHDL/4-1)
	  EQUIVALENCE (GDES,GDESJ)
C-
C Init
C
	NO_MORE=.FALSE.
	FIRST=.TRUE.
C
C GET MAP
C
	MXNHV(0)=MXNPAG/2				!SET MAX. # OF PAGES
	MXNHV(1)=MXNPAG/2
	IF (.NOT.NMASTL(FCAIN,SETS,MPH,MPHP,SETNAM,LPOFF)) RETURN !NONE
	CALL WNDSTI(SETNAM,SETNAM)
	IF (FIRST) THEN
	  CALL WNCTXT(F_T,'Next plot, first image: !AS', WNTTSG(SETNAM,0))
	  FIRST=.FALSE.
	ENDIF
	CALL WNGMTS(MPH_TYP_N,MPH(MPH_TYP_1),TXTT1)	!GET TYPE
	IF (TXTT1.EQ.'COVER' .OR. TXTT1.EQ.'REAL' .OR.
	1	TXTT1.EQ.'IMAG' .OR. TXTT1.EQ.'AMPL' .OR.
	1	TXTT1.EQ.'PHASE') THEN
	  UVPL=.TRUE.					!UV-PLANE
	ELSE
	  UVPL=.FALSE.					!MAP
	END IF
C
C SET UP SIZE
C
	R0=32.						!START SIZE
	J1=16
	IF (TAREA(2).GT.TAREA(3)) THEN			!USE LARGEST SIZE
	  J2=2
	ELSE
	  J2=3
	END IF
	DO I=1,8
	  IF (TAREA(J2).LE.J1) GOTO 10			!CORRECT FOUND
	  J1=2*J1	
	  R0=R0/2.					!NEXT
	END DO
  10	STEP(1)=R0*SIZE(1)				!STEP X TO USE
	STEP(2)=R0*SIZE(2)				!STEP Y TO USE
	POINXY(1,1)=30.					!POSITION TOP LEFT
	POINXY(2,1)=542.
	POINXY(1,2)=POINXY(1,1)+(TAREA(2)-1)*STEP(1) 	!POS. BOTTOM RIGHT
	POINXY(2,2)=POINXY(2,1)-(TAREA(3)-1)*STEP(2)
C
C MAKE PAGES AND OVERLAP CROSSES
C
	PG(1,1)=0					!TOTAL AREA
	PG(2,1)=POINXY(2,2)-30.
	PG(1,2)=POINXY(1,2)+30.
	PG(2,2)=780
	IF (.NOT.WQ_MPAGE(DQID2,NHV,PLDEV,MXNHV,780.,PG(1,1))) THEN
	  CALL WNCTXT(F_TP,'!/Cannot open plotter!/')
	  CALL WNGEX					!STOP PROGRAM
	END IF
C
C ANNOTATION
C
	IF (PLTHDR) THEN				!PLOT HEADING
	  CALL WNGSGU(DUSER)                            !GET USER
	  CALL WNCTXS(STR,'  !12$AS !24$AS (!AS) by !AS  ',
	1		TXTT1,TXTT2,MAPDTYP,DUSER)    !NAME OF FIELD
	  CALL WQ_MDATE(DQID2,NHV,STR)
	  CALL WQSTXH(9.)				!TEXT SIZE
	  CALL WQSTXX(CHREXP)				!CHARACTER EXPANSION
	  TXTXY(1)=0.					!TEXT
	  TXTXY(2)=740.
	  CALL WNCTXS(STR,'Node:     !AS!45CFile:    !AS',NODIN,FILIN)
	  CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	  TXTXY(2)=725.
	  CALL WNCTXS(STR,'Map:      !AS (!AL2)!45CField:   !AL#     ', 
	1	WNTTSG(SETNAM,0), MPH(MPH_POL_1),
	1	MPH_FNM_N,MPH(MPH_FNM_1) )		! 2nd !AL# on WNCTXS
	  CALL WNGMTS(MPH_UCM_N,MPH(MPH_UCM_1),STR(80:))!  will not work
	  CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	  TXTXY(2)=690.
	  IF (NCF.GT.0) THEN
	    CALL WQTEXT(TXTXY,'Full contours: ')
	    TXTXY(1)=128.
	    DO I=1,NCF,9
	      CALL WNCTXS(STR,'!#E5',MIN(9,NCF-I+1),FCONT(I))
	      CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	      TXTXY(2)=TXTXY(2)-15.
	    END DO
	    TXTXY(1)=0.
	  END IF
	  IF (NCD.GT.0) THEN
	    CALL WQTEXT(TXTXY,'Dotted contours: ')
	    TXTXY(1)=128.
	    DO I=1,NCD,9
	      CALL WNCTXS(STR,'!#E5',MIN(9,NCD-I+1),DCONT(I))
	      CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	      TXTXY(2)=TXTXY(2)-15.
	    END DO
	    TXTXY(1)=0.
	  END IF
	  IF (HALF.GE.0) THEN				!WEDGE
	    PG(1,1)=700.*CHREXP
	    PG(2,1)=740.
	    PG(1,2)=PG(1,1)+256.
	    PG(2,2)=PG(2,1)
	    PG(1,3)=PG(1,2)
	    PG(2,3)=710.
	    PG(1,4)=PG(1,1)
	    PG(2,4)=PG(2,3)
	    PG(1,5)=PG(1,1)
	    PG(2,5)=PG(2,1)
	    DO I=0,256
	      WEDGE(I)=TRF(I)				!INTENSITIES
	    END DO
	    PCD(1,1)=1.
	    PCD(2,1)=0.
	    PCD(1,2)=0.
	    PCD(2,2)=30.
	    CALL WQ_SHADI(SID,257,PG(1,4),PCD,HALF,WRANGE,0.)
	    CALL WQ_SHADE(SID,WEDGE)
	    CALL WQ_SHADE(SID,WEDGE)
	    CALL WQ_SHADX(SID)
	    CALL WQ_MPLR(DQID2,NHV,1,1,1.,0)
	    CALL WQSPLI(1)
	    CALL WQPOLL(5,PG)				!BOX
	    PG(1,1)=PG(1,1)+128.
	    PG(2,1)=710.
	    PG(1,2)=PG(1,1)
	    PG(2,2)=720.
	    CALL WQPOLL(2,PG)				!TICK
	    TXTXY(1)=649.*CHREXP
	    TXTXY(2)=698.
	    CALL WNCTXS(STR,'!10$E10.3',RANGE(1))
	    CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	    TXTXY(1)=TXTXY(1)+128.
	    CALL WNCTXS(STR,'!10$E10.3',RANGE(1)+(RANGE(2)-RANGE(1))/2.)
	    CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	    TXTXY(1)=TXTXY(1)+128.
	    CALL WNCTXS(STR,'!10$E10.3',RANGE(2))
	    CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	  END IF
	  IF (RSCAL.NE.0) THEN				!RULE
	    PG(1,1)=770.*CHREXP
	    PG(2,1)=675.
	    PG(1,2)=PG(1,1)+40.
	    PG(2,2)=PG(2,1)
	    CALL WQPOLL(2,PG)
	    TXTXY(1)=PG(1,1)+50.
	    TXTXY(2)=670.
	    CALL WNCTXS(STR,'!10$E10.3 W.U. (ruled)',10./RSCAL)
	    CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	  END IF
	  IF (PSCAL.NE.0) THEN				!POL
	    PG(1,1)=770.*CHREXP
	    PG(2,1)=645.
	    PG(1,2)=PG(1,1)+40.
	    PG(2,2)=PG(2,1)
	    CALL WQPOLL(2,PG)
	    TXTXY(1)=PG(1,1)+50.
	    TXTXY(2)=640.
	    CALL WNCTXS(STR,'!10$E10.3 W.U. (pol.)',10./PSCAL)
	    CALL WQTEXT(TXTXY,STR(:WNCALN(STR)))
	  END IF	
	END IF
C
C INIT PLOTTING
C
CCC	CALL WNGCCD					! trap control-C
	CALL WQSTXH(9.)					!TEXT SIZE
	NRPLT=0						!COUNT SETS
 100	CONTINUE
 	NRPLT=NRPLT+1
	PC(1)=POINXY(1,1)				!BOTTOM LEFT CORNER
	PC(2)=POINXY(2,2)
	PCD(1,1)=STEP(1)				!STEP ALONG LINE
	PCD(2,1)=0.
	PCD(1,2)=0.					!STEP VERTICAL
	PCD(2,2)=STEP(2)
	CALL WQ_MPLR(DQID2,NHV,1,1,1.,0)		!SET LINE REPRESENTATION
	CALL WQ_MPLR(DQID2,NHV,3,3,1.,0)
	J1=TAREA(2)
	IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCF.GT.0)	!CONT
	1		CALL WQ_CONJ(CID1,J1,PC,PCD,NCF,FCONT,
	1		0.,1)
	IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCD.GT.0)	!CONT
	1		CALL WQ_CONJ(CID2,J1,PC,PCD,NCD,DCONT,
	1		0.,3)
	IF (IAND(2,PTYP(NRPLT)).NE.0 .AND. HALF.GE.0)	!HALF
	1		CALL WQ_SHADI(SID,J1,PC,PCD,HALF,WRANGE,0.)
	IF (IAND(8,PTYP(NRPLT)).NE.0) THEN		!RULE
	  PCD(1,1)=0.					!STEP ALONG LINE
	  PCD(2,1)=STEP(2)
	  PCD(1,2)=STEP(1)				!STEP HORIZONTAL
	  PCD(2,2)=0.
	  PC(1)=POINXY(1,1)+(RTEAR(0)-TEAR(0))*STEP(1)
	  PC(2)=POINXY(2,2)+(RTEAR(2)-TEAR(2))*STEP(2)
	  CALL WQ_RULI(PID2,RTEAR(3)-RTEAR(2)+1,PC,PCD,
	1			4.*RSCAL,RRANGE,0.,0)
	END IF
	IF (IAND(4,PTYP(NRPLT)).NE.0) THEN		!POL
	  PC(1)=POINXY(1,1)+(PTEAR(0)-TEAR(0))*STEP(1)
	  PC(2)=POINXY(2,2)+(PTEAR(2)-TEAR(2))*STEP(2)
	  CALL WQ_POLI(PID1,PTEAR(1)-PTEAR(0)+1,PC,PCD,
	1			4.*PSCAL,PRANGE,0.)
	  IF (.NOT.NMASTL(FCAIN,ASET(0,NRPLT),MPH1,MPHP1,SETNAM1,LPOFF))
	1		GOTO 110			!GET ANGLES
	END IF
C
C PLOT SHADING
C
	IF (IAND(2,PTYP(NRPLT)).NE.0 .AND. HALF.GE.0) THEN
	  J1=LB_E*TAREA(2)				!LENGTH LINE
	  J=MPHJ(MPH_NRA_J)				!DATALINE LENGTH
	  J=MPHJ(MPH_MDP_J)+LB_E*(J*(MPHJ(MPH_NDEC_J)/2+
	1		TEAR(2))+MPHJ(MPH_NRA_J)/2+TEAR(0)) !DATA POINTER
	  DO I=TEAR(2),TEAR(3)				!PLOT ALL LINES
	    IF (.NOT.WNFRD(FCAIN,J1,LBUF(0),J)) GOTO 20	!READ A LINE
	    J=J+LB_E*MPHJ(MPH_NRA_J)			!NEXT LINE
	    IF (MAPDTYP.EQ.'SLOPE') THEN		!CALCULATE SLOPE
	      DO I1=1,TAREA(2)-1
	        LBUF(I1-1)=LBUF(I1)-LBUF(I1-1)
	      END DO
	      LBUF(TAREA(2)-1)=LBUF(TAREA(2)-2)
	    END IF
	    R0=RANGE(2)-RANGE(1)
	    IF (R0.GT.0) THEN
	      R0=MXNTRF/R0
	      R1=-RANGE(1)*R0
	      DO I1=0,TAREA(2)-1			!CONVERT DATA
		R2=LBUF(I1)*R0+R1
		IF (R2.LT.0.) THEN
		  R2=0.
		ELSE IF (R2.GT.FLOAT(MXNTRF)) THEN
		  R2=0.					!WAS: FLOAT(MXNTRF)
		END IF
		LBUF(I1)=TRF(NINT(R2))
	      END DO
	    END IF
	    CALL WQ_SHADE(SID,LBUF(0))			!SHADING
CCC	    IF (WNGCCN().GT.0) GOTO 101
 	  END DO
CCC 101	  CONTINUE
	  CALL WQ_SHADX(SID)				!FINISH SHADING
	END IF
C
C PLOT RULE
C
	IF (IAND(8,PTYP(NRPLT)).NE.0) THEN
	  STARTJ=MPHJ(MPH_MDP_J)+LB_E*(MPHJ(MPH_NRA_J)*
	1		(MPHJ(MPH_NDEC_J)/2+TEAR(2))+
	1		MPHJ(MPH_NRA_J)/2+TEAR(0))	!DATA POINTER
	  LSIZE=MIN(TAREA(3),MPHJ(MPH_NDEC_J))*LB_E	!BYTES PER RA NEEDED
	  MEMUSE=132000					!MEMORY TO USE
	  RPPD=MAX(WNMEJC(FLOAT(MEMUSE)/FLOAT(LSIZE)),1) !POINTS READ PER DEC
	  MEMUSE=RPPD*LSIZE				!ACTUAL MEMORY TO USE
	  IF (.NOT.WNGGVA(MEMUSE,BUFPTR)) THEN		!GET TRANSPOSE BUFFER
	    CALL WNCTXT(F_TP,'Cannot obtain transpose buffer')
	    CALL WNGEX					!STOP PROGRAM
	  END IF
	  BFPTRE=(BUFPTR-A_OB)/LB_E
	  DO RA_AX=TEAR(0),TEAR(1),RPPD			!X-AXIS (=RA)
	    NRPNTS=MIN(RPPD,TEAR(1)+1-RA_AX)		!NR. OF POINTS TO DO
	    OFFRA=(RA_AX-TEAR(0))*LB_E
	    DO DEC_AX=TEAR(2),TEAR(3)			!Y-AXIS (=DEC)
	      OFFDEC=(DEC_AX-TEAR(2))*MPHJ(MPH_NRA_J)*LB_E
	      IF (.NOT.WNFRD(FCAIN,LB_E*NRPNTS,
	1	A_E(BFPTRE+(DEC_AX-TEAR(2))*NRPNTS),
	1	STARTJ+OFFRA+OFFDEC)) GOTO 20
	    END DO
	    DO RA_PP=RA_AX,RA_AX+NRPNTS-1		!PARTS X-AXIS
	      DO DEC_AX=TEAR(2),TEAR(3)			!Y-AXIS
		 LBUF(DEC_AX-TEAR(2))=A_E(BFPTRE+
	1		(DEC_AX-TEAR(2))*NRPNTS+(RA_PP-RA_AX))
	      END DO	
	      IF (MAPDTYP.EQ.'SLOPE') THEN		!CALCULATE SLOPE
		 DO I1=1,TAREA(3)-1
		   LBUF(I1-1)=LBUF(I1)-LBUF(I1-1)
		 END DO
		 LBUF(TAREA(3)-1)=LBUF(TAREA(3)-2)
	      END IF
	      IF (RA_PP.GE.RTEAR(0) .AND. RA_PP.LE.RTEAR(1)) THEN   !DO
		CALL WQ_RULE(PID2,LBUF(RTEAR(0)-TEAR(0)))  !RULED SURFACE
	      END IF
CCC	      IF (WNGCCN().GT.0) GOTO 102
	    END DO
	  END DO
CCC 102	  CONTINUE
	  CALL WNGFVA(MEMUSE,BUFPTR)			!FREE TRANSPOSE BUFFER
	END IF
C
C PLOT OTHERS
C
	IF ((IAND(1,PTYP(NRPLT)).NE.0 .AND. NCF.GT.0) .OR.
	1	(IAND(1,PTYP(NRPLT)).NE.0 .AND. NCD.GT.0) .OR.
	1	(IAND(4,PTYP(NRPLT)).NE.0)) THEN
 	  J1=LB_E*TAREA(2)				!LENGTH LINE
	  J=MPHJ(MPH_NRA_J)				!DATALINE LENGTH
	  J=MPHJ(MPH_MDP_J)+LB_E*(J*(MPHJ(MPH_NDEC_J)/2+
	1		TEAR(2))+MPHJ(MPH_NRA_J)/2+TEAR(0)) !DATA POINTER
	  DO I=TEAR(2),TEAR(3)				!PLOT ALL LINES
	    IF (.NOT.WNFRD(FCAIN,J1,LBUF(0),J)) THEN	!READ A LINE
 20		CONTINUE
		CALL WNCTXT(F_TP,'!/Read error map')
		CALL WNGEX				!STOP
	    END IF
	    IF (IAND(4,PTYP(NRPLT)).NE.0) THEN		!POL
	      IF (.NOT.WNFRD(FCAIN,J1,ABUF(0),
	1		J-MPHJ(MPH_MDP_J)+MPH1J(MPH_MDP_J))) THEN !READ ANGLES
	        GOTO 20
	      END IF
	      IF (POLMAG) THEN				!MAGNETIC FIELD
	        DO I1=0,J1/LB_E-1
		  ABUF(I1)=ABUF(I1)+PI/2.		!ROTATE 90 DEGREES
	        END DO
	      END IF
	    END IF
	    J=J+LB_E*MPHJ(MPH_NRA_J)			!NEXT LINE
 	    IF (MAPDTYP.EQ.'SLOPE') THEN		!CALCULATE SLOPE
	      DO I1=1,TAREA(2)-1
	        LBUF(I1-1)=LBUF(I1)-LBUF(I1-1)
	      END DO
	      LBUF(TAREA(2)-1)=LBUF(TAREA(2)-2)
	    END IF
	    IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCF.GT.0)
	1		CALL WQ_CONT(CID1,LBUF(0)) 	!FULL CONTOURS
	    IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCD.GT.0)
	1		CALL WQ_CONT(CID2,LBUF(0)) 	!DOTTED CONTOURS
	    IF (IAND(4,PTYP(NRPLT)).NE.0) THEN
	      IF (I.GE.PTEAR(2) .AND. I.LE.PTEAR(3)) THEN !DO
	        CALL WQSPLI(1)				!SELECT FULL DRAWN LINE
	        CALL WQ_POLT(PID1,LBUF(PTEAR(0)-TEAR(0)),
	1		ABUF(PTEAR(0)-TEAR(0)))		!POL. VECTORS
	      END IF
	    END IF
CCC	    IF (WNGCCN().GT.0) GOTO 110
	  END DO
	END IF
 110	CONTINUE
	IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCF.GT.0)
	1		CALL WQ_CONX(CID1)		!FINISH PLOT
	IF (IAND(1,PTYP(NRPLT)).NE.0 .AND. NCD.GT.0)
	1		CALL WQ_CONX(CID2)
	IF (IAND(8,PTYP(NRPLT)).NE.0)
	1		CALL WQ_RULX(PID2)
	IF (IAND(4,PTYP(NRPLT)).NE.0)
	1		CALL WQ_POLX(PID1)
C
C Check control-C status
C
CCC 	IF (WNGCCN().GT.0) GOTO 9000
C
C MORE MAPS
C
	IF (NMASTL(FCAIN,SETS,MPH,MPHP,SETNAM,LPOFF)) GOTO 100 !MORE
C
C GRID
C
	CALL WQSTXX(1.)					!CHARACTER EXPANSION
	CALL WQSPLI(1)
	PG(1,1)=POINXY(1,1)
	PG(2,1)=POINXY(2,1)
	PG(1,2)=POINXY(1,2)
	PG(2,2)=POINXY(2,1)
	PG(1,3)=POINXY(1,2)
	PG(2,3)=POINXY(2,2)
	PG(1,4)=POINXY(1,1)
	PG(2,4)=POINXY(2,2)
	PG(1,5)=POINXY(1,1)
	PG(2,5)=POINXY(2,1)
	CALL WQ_MPLR(DQID2,NHV,1,1,2.,0)		!THICK LINE
	CALL WQPOLL(5,PG)				!BOX
	CALL WQ_MPLR(DQID2,NHV,1,1,1.,0)		!NORMAL LINE
C
C GRID COORDINATES
C
	IF (CRD.GE.0) THEN				!DO GRID COORDINATES
	  DO I=1,2					!LEFT/UP
	    J1=WNMEJC(80./STEP(I))			!MINIMUM GRID INCREMENT
	    I1=1
	    DO WHILE(J1.GT.GRTAB(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB(I1)				!ACTUAL INCREMENT
	    J2=TAREA(I+1)/2				!CENTRE OFFSET
	    R0=J2*STEP(I)+POINXY(I,I)			!CENTRE OFFSET
	    J2=TAREA(I-1)				!CENTRE POSITION
	    DO WHILE (R0.GT.POINXY(I,I))
	      R0=R0-J1*STEP(I)
	    J2=J2-J1
	    END DO
	    R0=R0+J1*STEP(I)				!FIRST POS.
	    J2=J2+J1
	    DO WHILE(R0.LT.POINXY(I,3-I))		!DRAW TICKS
	      PG(I,1)=R0
	      PG(3-I,1)=POINXY(3-I,I)
	      PG(I,2)=R0
	      PG(3-I,2)=PG(3-I,1)+10.
	      CALL WQPOLL(2,PG)				!TICK
	      CALL WNCTXS(STR,'!SJ',J2)			!VALUE
	      CALL WQSTXU(DIR(1,I))			!DIRECTION
	      PG(I,1)=PG(I,1)-4*WNCALN(STR)+1.		!TEXT POSITION
	      PG(3-I,1)=PG(3-I,1)+(9*I-6)+10.
	      CALL WQTEXT(PG,STR(:5))			!PRINT GRID
	      R0=R0+J1*STEP(I)				!NEXT POS.
	      J2=J2+J1
	    END DO
	  END DO
	END IF
	CALL WQSTXU(DIR(1,1))				!SET HORIZONTAL

C
C COORDINATES
C
	IF (ABS(CRD).EQ.1 .OR. ABS(CRD).EQ.2) THEN	!LM/DLM
	  DO I=1,2					!LEFT/UP
	    IF (.NOT.UVPL) THEN				!MAP
	      R1=((MPHD(MPH_SRA_D+I-1))*3600.*360.)	!PLOT COORD. ASEC
	    ELSE					!UV-PLANE
	      IF (MPHI(MPH_CD_I+6).EQ.0) THEN		!UV
		R1=1./(MPHD(MPH_SRA_D+2-I)*MPHJ(MPH_FSR_J+2-I)*PI2) !WAVEL.
	      ELSE IF (MPHI(MPH_CD_I+6).EQ.1) THEN	!BAS-HA
		R1=1./(MPHD(MPH_SRA_D+2-I)*MPHJ(MPH_FSR_J+2-I)*PI2)/
	1		(MPHD(MPH_FRQ_D)/(CL*1E-6))	!M
		IF (I.EQ.1) R1=DEG*R1			!DEGREE
	      ELSE					!IFR-HA
		R1=1./(MPHD(MPH_SRA_D+2-I)*MPHJ(MPH_FSR_J+2-I)*PI2)/
	1		(MPHD(MPH_FRQ_D)/(CL*1E-6))	!IFR NUMBER
		IF (I.EQ.1) R1=DEG*R1			!DEGREE
	      END IF
	    END IF
	    R1=STEP(I)/R1				!PLOT COORD. PER UNIT
	    J1=WNMEJC(80./R1)				!MINIMUM INCREMENT
	    I1=1
	    DO WHILE(J1.GT.GRTAB(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB(I1)				!ACTUAL INCREMENT
	    R0=0.					!CENTRE LM
	    IF (.NOT.UVPL) THEN
	      IF (ABS(CRD).EQ.2) THEN			!LM
	        R0=TAREA(I-1)*(MPHD(MPH_SRA_D+I-1))+
	1			(MPHD(MPH_SHR_D+I-1))	!CENTRE LM
	      END IF
	      R0=R0*3600.*360.				!MAKE ARCSEC
	    ELSE					!UV-PLANE
	      IF (I.EQ.1) THEN				!V
		R0=TAREA(I-1)*STEP(I)/R1		!CENTRE LM
	      ELSE					!U
		R0=(TAREA(I-1)+MPHJ(MPH_NRA_J+I-1)/2)*STEP(I)/R1
	      END IF
	    END IF
	    J2=WNMEJC(R0/J1)*J1				!VALUE OF A TICK
	    R0=(TAREA(I+1)/2)*STEP(I)+POINXY(I,I)+((J2-R0)*R1) !POS. TICK
	    DO WHILE (R0.GT.POINXY(I,I))
	      R0=R0-J1*R1
	      J2=J2-J1
	    END DO
	    R0=R0+J1*R1					!FIRST POS.
	    J2=J2+J1
	    IF (CRDTYP.EQ.2) CALL WQSPLI(3)		!SELECT DOTTED LINE
	    DO WHILE(R0.LT.POINXY(I,3-I))		!DRAW TICKS
	      PG(I,1)=R0
	      PG(3-I,1)=POINXY(3-I,3-I)
	      PG(I,2)=R0
	      IF (CRDTYP.EQ.1) THEN			!TICK
	        PG(3-I,2)=PG(3-I,1)+10.
	      ELSE					!LINE
	        PG(3-I,2)=POINXY(3-I,I)
	      END IF
	      CALL WQPOLL(2,PG)				!TICK
	      IF (UVPL .AND. MPHI(MPH_CD_I+6).EQ.2) THEN !IFR
		KT=STHTEL				!# OF TELESCOPES
		KJ=0					!WEST TELESCOPE
		KI=MOD(J2,STHIFR)			!CATER FOR ERRORS
		DO WHILE (KI.GE.0)			!FIND WEST
		  KI=KI-KT
		  KT=KT-1
		  KJ=KJ+1
		END DO
		KJ=KJ-1
		KT=KT+1
		KI=KI+KT+KJ				!EAST TEL
		STR=TSTR(KJ+1:KJ+1)//TSTR(KI+1:KI+1)
	      ELSE
	        CALL WNCTXS(STR,'!SJ',J2)		!VALUE
	      END IF
	      CALL WQSTXU(DIR(1,I))			!DIRECTION
	      PG(I,1)=PG(I,1)-4*WNCALN(STR)+1.		!TEXT POSITION
	      PG(3-I,1)=PG(3-I,1)+(9*I-20)
	      CALL WQTEXT(PG,STR(:10))			!PRINT GRID
	      IF (CRDTYP.EQ.1) THEN
	        PG(I,1)=R0
		PG(3-I,1)=POINXY(3-I,I)
		PG(I,2)=R0
		PG(3-I,2)=PG(3-I,1)-10.
		CALL WQPOLL(2,PG)			!TICK
	      END IF
	      R0=R0+J1*R1				!NEXT POS.
	      J2=J2+J1
	    END DO
	  END DO
	  CALL WQSPLI(1)				!SELECT FULL DRAWN LINE
	  CALL WQSTXU(DIR(1,1))				!SET HORIZONTAL
	  PG(1,1)=POINXY(1,1)				!COORDINATE TYPE
	  PG(2,1)=POINXY(2,2)-30.
	  IF (.NOT.UVPL) THEN				!MAP
	    CALL WNCTXS(STR,'l (arcsec,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	  ELSE IF (MPHI(MPH_CD_I+6).EQ.0) THEN		!UV
	    CALL WNCTXS(STR,'V (wavel.)')
	  ELSE IF (MPHI(MPH_CD_I+6).EQ.1) THEN		!BAS-HA
	    CALL WNCTXS(STR,'HA (deg)')
	  ELSE						!IFR-HA
	    CALL WNCTXS(STR,'HA (deg)')
	  END IF
	  CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  PG(1,1)=10.
	  PG(2,1)=POINXY(2,2)
	  CALL WQSTXU(DIR(1,2))				!VERTICAL
	  IF (.NOT.UVPL) THEN				!MAP
	    CALL WNCTXS(STR,'m (arcsec,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	  ELSE IF (MPHI(MPH_CD_I+6).EQ.0) THEN		!UV
	    CALL WNCTXS(STR,'U (wavel.)')
	  ELSE IF (MPHI(MPH_CD_I+6).EQ.1) THEN		!BAS-HA
	    CALL WNCTXS(STR,'Basel. (m)')
	  ELSE						!IFR-HA
	    CALL WNCTXS(STR,'Ifr')
	  END IF
	  CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  CALL WQSTXU(DIR(1,1))				!SET HORIZONTAL
	END IF
C
C RA
C
	IF (ABS(CRD).GE.3 .AND. ABS(CRD).LE.6 
	1	.AND. .NOT.UVPL) THEN !RA/DRA
	  IF (ABS(CRD).LE.4) THEN
	    FSC=360.*240.				!SCALE
	  ELSE
	    FSC=360.*1000.
	  END IF
	  L=(TAREA(0))*(MPHD(MPH_SRA_D))+(MPHD(MPH_SHR_D))
	  M=(-(TAREA(3)/2)+TAREA(1))*(MPHD(MPH_SDEC_D))+
	1			(MPHD(MPH_SHD_D))
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,D0,DEC)	!RA CENTRE
	  R0=D0
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			REAL(PI2*(L+10.*(MPHD(MPH_SRA_D)))),
	1			PI2*M,D0,DEC)		!RA 1 GRID POINT AWAY
	  R1=D0
	  FSCSGN=FSC					!SIGNED FSC
	  R1=WNGENF(R1-R0)
	  IF (R1.GT.0) FSCSGN=-FSCSGN
	  R1=ABS(R1)*FSC/10.				!GRID STEP IN TIME SEC
	  R0=R0*FSC					!POS. IN TIME SEC
	  R1=STEP(1)/R1					!PLOT COORD. PER SEC
	  J1=WNMEJC(80./R1)				!MINIMUM INCREMENT
	  I1=1
	  IF (ABS(CRD).LE.4) THEN
	    DO WHILE(J1.GT.GRTAB1(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB1(I1)				!ACTUAL INCREMENT
	  ELSE
	    DO WHILE(J1.GT.GRTAB(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB(I1)				!ACTUAL INCREMENT
	  END IF
	  IF (ABS(CRD).EQ.4 .OR. ABS(CRD).EQ.6) THEN
	    R2=0					!NO OFFSET
	  ELSE
	    R2=R0					!OFFSET
	  END IF
	  L=L-(TAREA(2)/2)*(MPHD(MPH_SRA_D))		!BOTTOM LEFT CORNER
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,
	1			CCRD(1,1),CCRD(2,1))	!BOTTOM LEFT
	  L=L+(TAREA(2)-1)*(MPHD(MPH_SRA_D))		!BOTTOM RIGHT CORNER
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,
	1			CCRD(1,2),CCRD(2,2))	!BOTTOM RIGHT
	  M=M+(TAREA(3)-1)*(MPHD(MPH_SDEC_D)) 		!TOP LEFT CORNER
	  L=L-(TAREA(2)-1)*(MPHD(MPH_SRA_D))
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,
	1			CCRD(1,4),CCRD(2,4))	!TOP LEFT
	  L=L+(TAREA(2)-1)*(MPHD(MPH_SRA_D))		!TOP RIGHT CORNER
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,
	1			CCRD(1,3),CCRD(2,3))	!TOP RIGHT
	  IF (FSCSGN.GT.0) THEN
	    R0=CCRD(1,1)				!BOTTOM LEFT RA
	    R1=CCRD(1,2)				!BOTTOM RIGHT
	    IF (CCRD(1,1).LT.CCRD(1,2)) R0=R0+1.	!FOR 24H
	    IF (WNGDNF(CCRD(1,4)-CCRD(1,3)).GT.0) THEN
		R3=WNGDNF(CCRD(1,4)-CCRD(1,1))
		IF (R3.GT.0) R0=R0+R3
		R3=WNGDNF(CCRD(1,3)-CCRD(1,2))
		IF (R3.LT.0) R1=R1+R3
	    ELSE
		R3=WNGDNF(CCRD(1,3)-CCRD(1,1))
		IF (R3.GT.0) R0=R0+R3
		R3=WNGDNF(CCRD(1,4)-CCRD(1,2))
		IF (R3.LT.0) R1=R1+R3
	    END IF
	  ELSE
	    R0=CCRD(1,2)				!BOTTOM RIGHT RA
	    R1=CCRD(1,2)				!BOTTOM LEFT
	    IF (CCRD(1,1).GT.CCRD(1,2)) R1=R1+1.	!FOR 24H
	    IF (WNGDNF(CCRD(1,3)-CCRD(1,4)).GT.0) THEN
		R3=WNGDNF(CCRD(1,3)-CCRD(1,2))
		IF (R3.GT.0) R0=R0+R3
		R3=WNGDNF(CCRD(1,4)-CCRD(1,1))
		IF (R3.LT.0) R1=R1+R3
	    ELSE
		R3=WNGDNF(CCRD(1,4)-CCRD(1,2))
		IF (R3.GT.0) R0=R0+R3
		R3=WNGDNF(CCRD(1,3)-CCRD(1,1))
		IF (R3.LT.0) R1=R1+R3
	    END IF
	  END IF
	  J2=WNMEJF((R0*FSC-R2)/J1)*J1			!FIRST TICK
	  R0=R1*FSC					!LAST TICK
	  IF (CRDTYP.EQ.2) THEN				!DOTTED
	    CALL WQSPLI(3)
	  ELSE
	    CALL WQSPLI(1)				!FULL
	  END IF
	  IF ((J2+R2).LT.R0) J2=J2+FSC
	  DO WHILE(J2+R2.GT.R0)				!DRAW TICKS
	    M=(-(TAREA(3)/2)+TAREA(1))*(MPHD(MPH_SDEC_D))+
	1			(MPHD(MPH_SHD_D))	!BOTTOM LINE
	    CALL WNMCRM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			R1,PI2*M,DBLE((J2+R2)/FSC),DEC) !GET L
	    PG(1,1)=STEP(1)*(R1/PI2-L)/(MPHD(MPH_SRA_D))+
	1			POINXY(1,2)
	    PG(2,1)=POINXY(2,2)
	    CALL WNMCRM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			R1,REAL(PI2*(M+(MPHD(MPH_SDEC_D))*
	1			10./STEP(2))),
	1			DBLE((J2+R2)/FSC),DEC)	!GET L
	    PG(1,2)=STEP(1)*(R1/PI2-L)/(MPHD(MPH_SRA_D))+
	1			POINXY(1,2)
	    PG(2,2)=PG(2,1)+10.
	    IF (PG(1,1).GE.POINXY(1,1) .AND. PG(1,1).LE.POINXY(1,2) .AND.
	1		PG(1,2).GE.POINXY(1,1) .AND.
	1		PG(1,2).LE.POINXY(1,2)) THEN
	      IF (ABS(CCRD(2,1)).LT.80.0/360.)
	1	      CALL WQPOLL(2,PG)			!TICK
	      J3=MOD(J2,NINT(FSC))
	      IF (J3.LT.0) J3=J3+NINT(FSC)
	      IF (ABS(CRD).LE.4) THEN
	        CALL WNCTXS(STR,'!8$EHD6',J3/240.)
	      ELSE
	        CALL WNCTXS(STR,'!E10.3',J3/1000.)
	      END IF
	      CALL WQSTXU(DIR(1,1))			!DIRECTION
	      PG(1,1)=PG(1,1)-4*WNCALN(STR)+1. 		!TEXT POSITION
	      PG(2,1)=PG(2,1)-11.
	      IF (PG(1,1).GE.POINXY(1,1) .AND.
	1	(ABS(WNGDNF(DBLE((J2+R2)/FSC-CCRD(1,1)))).LT.0.25 .OR.
	1	ABS(WNGDNF(DBLE((J2+R2)/FSC-CCRD(1,2)))).LT.0.25) .AND.
	1	ABS(WNGDNF(DBLE((J2+R2)/FSC-CCRD(1,1)))-
	1	WNGDNF(DBLE((J2+R2)/FSC-CCRD(1,2)))).LT.0.5)
	1		CALL WQTEXT(PG,STR(:9))		!PRINT GRID
	    END IF
	    IF (ABS(CCRD(2,1)).LT.80.0/360.) THEN
	      M=M+(TAREA(3)-1)*(MPHD(MPH_SDEC_D)) 	!TOP LINE
	      CALL WNMCRM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			R1,PI2*M,DBLE((J2+R2)/FSC),DEC) !GET L
	      PG(1,1)=STEP(1)*(R1/PI2-L)/
	1			(MPHD(MPH_SRA_D))+POINXY(1,2)
	      PG(2,1)=POINXY(2,1)
	      CALL WNMCRM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			R1,REAL(PI2*(M-(MPHD(MPH_SDEC_D))*
	1			10./STEP(2))),
	1			DBLE((J2+R2)/FSC),DEC)	!GET L
	      PG(1,2)=STEP(1)*(R1/PI2-L)/
	1			(MPHD(MPH_SRA_D))+POINXY(1,2)
	      PG(2,2)=PG(2,1)-10.
	      IF (PG(1,1).GE.POINXY(1,1) .AND. PG(1,1).LE.POINXY(1,2) .AND.
	1		PG(1,2).GE.POINXY(1,1) .AND.
	1		PG(1,2).LE.POINXY(1,2)) THEN
	      IF (ABS(CCRD(2,1)).LT.80.0/360.)
	1	      CALL WQPOLL(2,PG)			!TICK
	      END IF
	      IF (CRDTYP.GT.1 .AND.
	1	 ABS(CCRD(2,1)).LT.80.0/360.) THEN !DRAW GRID
	        M=M-(TAREA(3)-1)*(MPHD(MPH_SDEC_D))      !BOTTOM LINE
	        DO I1=0,64
		  R3=I1*((TAREA(3)-1)/64.) !GRID POINT
		  CALL WNMCRM(((MPHD(MPH_RA_D))),
	1	       ((MPHD(MPH_DEC_D))),
	1	       R1,REAL(PI2*(M+R3*
	1	       (MPHD(MPH_SDEC_D)))),
	1	       DBLE((J2+R2)/FSC),DEC) !GET L
		  PGRD(1,I1)=STEP(1)*(R1/PI2-L)/(MPHD(MPH_SRA_D))+
	1	       POINXY(1,2)
		  PGRD(2,I1)=POINXY(2,2)+STEP(2)*R3
	        END DO
	        J3=0		!TEST INSIDE
	        DO WHILE (J3.LT.65 .AND. (PGRD(1,J3).LT.POINXY(1,1) .OR.
	1	    PGRD(1,J3).GT.POINXY(1,2)))
		  J3=J3+1	!SKIP
	        END DO
	        J4=J3
	        DO WHILE (J4.LT.64 .AND. (PGRD(1,J4+1).LE.POINXY(1,2) .AND.
	1	    PGRD(1,J4+1).GE.POINXY(1,1)))
		  J4=J4+1
	        END DO
	        CALL WQPOLL(J4-J3+1,PGRD(1,J3)) !DRAW
	      END IF
	    END IF
	    J2=J2-J1					!NEXT POS.
	  END DO
	  J5=J1			!SAVE RA STEP
	  R5=R2/FSC		!AND OFFSET
C
C DEC
C
	  IF (ABS(CRD).LE.4) FSC=360.*3600.		!SCALE
	  FSC=ABS(FSC)
	  L=(-(TAREA(2)/2)+TAREA(0))*(MPHD(MPH_SRA_D))+
	1			(MPHD(MPH_SHR_D))
	  M=(TAREA(1))*(MPHD(MPH_SDEC_D))+
	1			(MPHD(MPH_SHD_D))
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,PI2*M,RA,D0)	!DEC CENTRE
	  R0=D0
	  R0C=R0
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,REAL(PI2*(M+10.*
	1			(MPHD(MPH_SDEC_D)))),RA,D0) !DEC 5 GRID AWAY
	  R1=D0
	  FSCSGN=FSC					!SIGNED FSC
	  IF (R1-R0.LT.0) FSCSGN=-FSCSGN
	  R1=ABS(R1-R0)*FSC/10.				!GRID STEP IN ARCSEC
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,
	1			REAL(PI2*(M-(TAREA(3)/4)*MPHD(MPH_SDEC_D))),
	1			RA,D0)	!DEC CENTRE - 0.25
	  R2=D0
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,
	1			REAL(PI2*(M-(TAREA(3)/4)*MPHD(MPH_SDEC_D)
	1			-10.*MPHD(MPH_SDEC_D))),
	1			RA,D0)	!DEC CENTRE - 0.25
	  R3=ABS(REAL(D0)-R2)*FSC/10.
	  R1=MAX(R1,R3)
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,
	1			REAL(PI2*(M+(TAREA(3)/4)*MPHD(MPH_SDEC_D))),
	1			RA,D0)	!DEC CENTRE - 0.25
	  R2=D0
	  CALL WNMCLM(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,
	1			REAL(PI2*(M+(TAREA(3)/4)*MPHD(MPH_SDEC_D)
	1			+10.*MPHD(MPH_SDEC_D))),
	1			RA,D0)	!DEC CENTRE - 0.25
	  R3=ABS(REAL(D0)-R2)*FSC/10.
	  R1=MAX(R1,R3)
	  R0=R0*FSC					!POS. IN ARCSEC
	  R1=STEP(2)/R1					!PLOT COORD. PER SEC
	  J1=WNMEJC(80./R1)				!MINIMUM INCREMENT
	  I1=1
	  IF (ABS(CRD).LE.4) THEN
	    DO WHILE(J1.GT.GRTAB1(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB1(I1)				!ACTUAL INCREMENT
	  ELSE
	    DO WHILE(J1.GT.GRTAB(I1))			!FIND GRID INCREMENT
	      I1=I1+1
	    END DO
	    J1=GRTAB(I1)				!ACTUAL INCREMENT
	  END IF
	  IF (ABS(CRD).EQ.4 .OR. ABS(CRD).EQ.6) THEN
	    R2=0					!NO OFFSET
	  ELSE
	    R2=R0					!OFFSET
	  END IF
	  IF (FSCSGN.GT.0) THEN
	    R0=CCRD(2,1)				!BOTTOM LEFT DEC
	    J2=WNMEJC((R0*FSC-R2)/J1)*J1		!FIRST TICK
	    R0=CCRD(2,2)				!BOTTOM RIGHT DEC
	    J2=MIN(J2,WNMEJC((R0*FSC-R2)/J1)*J1)
	    R0=MAX(CCRD(2,3),CCRD(2,4))			!TOP DEC
	  ELSE
	    R0=CCRD(2,4)				!TOP LEFT DEC
	    J2=WNMEJF((R0*FSC-R2)/J1)*J1		!FIRST TICK
	    R0=CCRD(2,3)				!TOP RIGHT DEC
	    J2=MIN(J2,WNMEJF((R0*FSC-R2)/J1)*J1)
	    R0=MAX(CCRD(2,1),CCRD(2,2))			!BOTTOM DEC
	  END IF
	  IF (R0C.GT.R0) R0=0.25			!REALLY NEAR POLE
	  R0=R0*FSC
	  IF (CRDTYP.EQ.2) THEN				!DOTTED
	    CALL WQSPLI(3)
	  ELSE
	    CALL WQSPLI(1)				!FULL
	  END IF
	  M=M-(TAREA(3)/2)*(MPHD(MPH_SDEC_D))		!BOTTOM LINE
	  DO WHILE(J2+R2.LT.R0)				!DRAW TICKS
	    L=(-(TAREA(2)/2)+TAREA(0))*(MPHD(MPH_SRA_D))+
	1			(MPHD(MPH_SHR_D))	!LEFT LINE
	    CALL WNMCDL(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,R1,RA,DBLE((J2+R2)/FSC)) !GET M
	    IF (R1.EQ.-100. .AND. RA.EQ.-100.) THEN
	       PG(2,1)=POINXY(2,2)-1.
	    ELSE
	       PG(2,1)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	       IF (PG(2,1).LE.POINXY(2,2) .OR. 
	1		PG(2,1).GE.POINXY(2,1)) THEN
		CALL WNMCD2(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,R1,RA,DBLE((J2+R2)/FSC)) !GET M
	        PG(2,1)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	       END IF
	    END IF
	    PG(1,1)=POINXY(1,1)
	    CALL WNMCDL(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			REAL(PI2*(L+(MPHD(MPH_SRA_D))*
	1			10./STEP(1))),R1,
	1			RA,DBLE((J2+R2)/FSC)) !GET M
	    IF (R1.EQ.-100. .AND. RA.EQ.-100.) THEN
	       PG(2,2)=POINXY(2,2)-1.
	    ELSE
	       PG(2,2)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	       IF (PG(2,2).LE.POINXY(2,2) .OR.
	1		PG(2,2).GE.POINXY(2,1)) THEN
		CALL WNMCD2(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			REAL(PI2*(L+(MPHD(MPH_SRA_D))*
	1			10./STEP(1))),R1,
	1			RA,DBLE((J2+R2)/FSC)) !GET M
		PG(2,2)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	       END IF
	    END IF
	    PG(1,2)=PG(1,1)+10.
	    IF (PG(2,1).GE.POINXY(2,2) .AND. PG(2,1).LE.POINXY(2,1) .AND.
	1		PG(2,2).GE.POINXY(2,2) .AND.
	1		PG(2,2).LE.POINXY(2,1)) THEN
	    IF (ABS(CCRD(2,1)).LT.80.0/360.)
	1	      CALL WQPOLL(2,PG)			!TICK
	      J3=MOD(J2,NINT(FSC))
	      IF (J3.LT.0) THEN
	        STR(1:1)='-'
	        J3=-J3
	      ELSE
	        STR(1:1)=' '
	      END IF
	      IF (ABS(CRD).LE.4) THEN
	        CALL WNCTXS(STR(2:),'!EDD',
	1			J3/3600.)
	      ELSE
	        CALL WNCTXS(STR(2:),'!E10.3',J3/1000.)
	      END IF
	      CALL WQSTXU(DIR(1,2))			!DIRECTION
	      PG(2,1)=PG(2,1)-4*WNCALN(STR)+1. 		!TEXT POSITION
	      PG(1,1)=PG(1,1)-2.
	      IF (PG(2,1).GE.POINXY(2,2))
	1		CALL WQTEXT(PG,STR(:9))		!PRINT GRID
	    END IF
	    IF (ABS(CCRD(2,1)).LT.80.0/360.) THEN
	      L=L+(TAREA(2)-1)*(MPHD(MPH_SRA_D))	!RIGHT LINE
	      CALL WNMCDL(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,R1,RA,DBLE((J2+R2)/FSC)) !GET M
	      IF (R1.EQ.-100. .AND. RA.EQ.-100.) THEN
	        PG(2,1)=POINXY(2,2)-1.
	      ELSE
	        PG(2,1)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	        IF (PG(2,1).LE.POINXY(2,2) .OR. 
	1			PG(2,1).GE.POINXY(2,1)) THEN
	          CALL WNMCD2(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			PI2*L,R1,RA,DBLE((J2+R2)/FSC)) !GET M
	          PG(2,1)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	         END IF
	      END IF
	      PG(1,1)=POINXY(1,2)
	      CALL WNMCDL(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			REAL(PI2*(L-(MPHD(MPH_SRA_D))*
	1			10./STEP(1))),R1,
	1			RA,DBLE((J2+R2)/FSC))	!GET M
	      IF (R1.EQ.-100. .AND. RA.EQ.-100.) THEN
	        PG(2,2)=POINXY(2,2)-1.
	      ELSE
	        PG(2,2)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	        IF (PG(2,2).LE.POINXY(2,2) .OR.
	1		PG(2,2).GE.POINXY(2,1)) THEN
	          CALL WNMCD2(((MPHD(MPH_RA_D))),
	1			((MPHD(MPH_DEC_D))),
	1			REAL(PI2*(L-(MPHD(MPH_SRA_D))*
	1			10./STEP(1))),R1,
	1			RA,DBLE((J2+R2)/FSC))	!GET M
	          PG(2,2)=STEP(2)*(R1/PI2-M)/
	1	    (MPHD(MPH_SDEC_D))+POINXY(2,2)
	        END IF
	      END IF
	      PG(1,2)=PG(1,1)-10.
	      IF (PG(2,1).GE.POINXY(2,2) .AND. PG(2,1).LE.POINXY(2,1) .AND.
	1		PG(2,2).GE.POINXY(2,2) .AND.
	1		PG(2,2).LE.POINXY(2,1)) THEN
	        CALL WQPOLL(2,PG)	!TICK
	      END IF
	      IF (CRDTYP.GT.1 .AND.
	1	   ABS(CCRD(2,1)).LT.80.0/360.) THEN !DRAW GRID
	        L=L-(TAREA(2)-1)*(MPHD(MPH_SRA_D))	!LEFT LINE
	        DO I1=0,64
	          R3=I1*((TAREA(2)-1)/64.) 		!GRID POINT
	          CALL WNMCDL(((MPHD(MPH_RA_D))),
	1				((MPHD(MPH_DEC_D))),
	1				REAL(PI2*(L+R3*(MPHD(MPH_SRA_D)))),
	1				R1,
	1				RA,DBLE((J2+R2)/FSC)) !GET M
		  IF (R1.EQ.-100. .AND. RA.EQ.-100.) THEN
		    PGRD(2,I1)=POINXY(2,2)-1.
		  ELSE
		    PGRD(2,I1)=STEP(2)*(R1/PI2-M)/
	1		(MPHD(MPH_SDEC_D))+POINXY(2,2)
		  END IF
	          PGRD(1,I1)=POINXY(1,1)+STEP(1)*R3
	        END DO
	        J3=0					!TEST INSIDE
	        DO WHILE (J3.LT.65 .AND. (PGRD(2,J3).LT.POINXY(2,2) .OR.
	1		PGRD(2,J3).GT.POINXY(2,1)))
		  J3=J3+1				!SKIP
	        END DO
	        J4=J3
	        DO WHILE (J4.LT.64 .AND. (PGRD(2,J4+1).LE.POINXY(2,1) .AND.
	1		PGRD(2,J4+1).GE.POINXY(2,2)))
	          J4=J4+1
	        END DO
	        CALL WQPOLL(J4-J3+1,PGRD(1,J3))		!DRAW
	      END IF
	    END IF
	    J2=J2+J1					!NEXT POS.
	  END DO
	  J6=J1			!SAVE DEC STEP
	  R6=R2/FSC		!AND OFFSET
C
C CONTOUR TYPE GRID
C
C DEC
C
	  IF (ABS(CCRD(2,1)).GE.80.0/360.) THEN !NEAR POLE
	       COCOLP=HAINT
	     IF (.NOT.WNGGVA((COCOLP+1)*LB_E,COCOP)) THEN
		CALL WNCTXT(F_TP,'Cannot obtain coordinate line buffer')
		CALL WNGEX	!STOP PROGRAM
	     END IF
	     COCOPE=(COCOP-A_OB)/LB_E
	     L=(-(TAREA(2)/2)+TAREA(0))*(MPHD(MPH_SRA_D))+
	1	  (MPHD(MPH_SHR_D)) !LEFT LINE
	     M=(-(TAREA(3)/2)+TAREA(1))*(MPHD(MPH_SDEC_D))+
	1	  (MPHD(MPH_SHD_D)) !BOTTOM LINE
	     J2=WNMEJF((79.-R6*360.)*3600./J6) !LOWEST CONTOUR
	     CONTLP=WNMEJC((90.-R6*360.)*3600./J6)-J2+1 !LENGTH CONTOUR BUFFER
	     IF(.NOT.WNGGVA(CONTLP*LB_E,CONTP)) THEN
		CALL WNCTXT(F_TP,'Cannot obtain contour buffer')
		CALL WNGEX	!STOP PROGRAM
	     END IF
	     CONTPE=(CONTP-A_OB)/LB_E
	     DO I2=0,CONTLP-1
		A_E(CONTPE+I2)=(J2+I2)*J6
	     END DO
	     IF (CRDTYP.GT.1) THEN	!FULL GRID
	       PC(1)=POINXY(1,1)	!BOTTOM LEFT CORNER
	       PC(2)=POINXY(2,2)
	       PCD(1,1)=STEP(1)*(TAREA(2)-1)/REAL(COCOLP) !STEP ALONG LINE
	       PCD(2,1)=0.
	       PCD(1,2)=0.	!STEP VERTICAL
	       PCD(2,2)=STEP(2)*(TAREA(3)-1)/REAL(COCOLP)
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,3) !DOTTED
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,1)
	       END IF
	       R4=0		!BOTTOM LINE
 	       DO I2=0,COCOLP	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(2)-1)/REAL(COCOLP)) !GRID POINT L
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R3*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R4*
	1		(MPHD(MPH_SDEC_D)))),
	1		RA,D0)
		   A_E(COCOPE+I1)=REAL(D0-R6)*360.*3600. !DEC
		 END DO
	         CALL WQ_CONT(CIDC2,A_E(COCOPE))
	         R4=R4+((TAREA(3)-1)/REAL(COCOLP)) !LINE M
	       END DO
	       CALL WQ_CONX(CIDC2)
	     ELSE		!TICKS ONLY
	       PC(1)=POINXY(1,1)	!BOTTOM LEFT CORNER
	       PC(2)=POINXY(2,2)
	       PCD(1,1)=0.	!STEP ALONG LINE
	       PCD(2,1)=STEP(2)*(TAREA(3)-1)/REAL(COCOLP)
	       PCD(1,2)=10.	!STEP VERTICAL
	       PCD(2,2)=0.
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,3) !DOTTED
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,1)
	       END IF
	       R4=0		!LEFT LINE
 	       DO I2=0,1	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(3)-1)/REAL(COCOLP)) !GRID POINT M
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R4*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R3*
	1		(MPHD(MPH_SDEC_D)))),
	1		RA,D0)
		   A_E(COCOPE+I1)=REAL(D0-R6)*360.*3600. !DEC
		 END DO
	         CALL WQ_CONT(CIDC2,A_E(COCOPE))
	         R4=R4+10./STEP(1)
	       END DO
	       CALL WQ_CONX(CIDC2)
	       PC(1)=POINXY(1,2)	!BOTTOM RIGHT CORNER
	       PC(2)=POINXY(2,2)
	       PCD(1,1)=0.	!STEP ALONG LINE
	       PCD(2,1)=STEP(2)*(TAREA(3)-1)/REAL(COCOLP)
	       PCD(1,2)=-10.	!STEP VERTICAL
	       PCD(2,2)=0.
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,3) !DOTTED
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,1)
	       END IF
	       R4=TAREA(2)-1		!RIGHT LINE
 	       DO I2=0,1	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(3)-1)/REAL(COCOLP)) !GRID POINT M
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R4*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R3*
	1		(MPHD(MPH_SDEC_D)))),
	1		RA,D0)
		   A_E(COCOPE+I1)=REAL(D0-R6)*360.*3600. !DEC
		 END DO
	         CALL WQ_CONT(CIDC2,A_E(COCOPE))
	         R4=R4-10./STEP(1)
	       END DO
	       CALL WQ_CONX(CIDC2)
	     END IF
	     CALL WNGFVA(CONTLP*LB_E,CONTP) !FREE LINE BUFFER
C
C RA
C
	     CONTLP=WNMEJC(24.*3600./J5+1) !LENGTH CONTOUR BUFFER
	     IF(.NOT.WNGGVA(CONTLP*LB_E,CONTP)) THEN
		CALL WNCTXT(F_TP,'Cannot obtain contour buffer')
		CALL WNGEX	!STOP PROGRAM
	     END IF
	     CONTPE=(CONTP-A_OB)/LB_E
	     DO I2=0,CONTLP-1
		A_E(CONTPE+I2)=(I2-WNMEJF(R5*24.*3600./J5))*J5
	     END DO
	     IF (CRDTYP.GT.1) THEN	!FULL GRID
	       PC(1)=POINXY(1,1)	!BOTTOM LEFT CORNER
	       PC(2)=POINXY(2,2)
	       PCD(1,1)=STEP(1)*(TAREA(2)-1)/REAL(COCOLP) !STEP ALONG LINE
	       PCD(2,1)=0.
	       PCD(1,2)=0.	!STEP VERTICAL
	       PCD(2,2)=STEP(2)*(TAREA(3)-1)/REAL(COCOLP)
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),1.E20,3)
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),1.E20,1)
	       END IF
	       R4=0		!BOTTOM LINE
 	       DO I2=0,COCOLP	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(2)-1)/REAL(COCOLP)) !GRID POINT L
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R3*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R4*
	1		(MPHD(MPH_SDEC_D)))),
	1		D0,DEC)
		   D0=WNGDPF(D0-R5)
		   IF (ABS(DEC*360.).GT.90.-J6/3600.) THEN
		      A_E(COCOPE+I1)=1.E20
		   ELSE IF (D0.GT.(1.-J5/360./360.)) THEN
		      IF (D0.GT.(1.-J5/720./360.)) THEN
			 A_E(COCOPE+I1)=REAL(D0-1.)*24.*3600.
		      ELSE
			 A_E(COCOPE+I1)=1.E20
		      END IF
		   ELSE
		      A_E(COCOPE+I1)=REAL(D0)*24.*3600. !RA
		   END IF
		 END DO
		 CALL WQ_CONT(CIDC2,A_E(COCOPE))
		 R4=R4+((TAREA(3)-1)/REAL(COCOLP)) !LINE M
	       END DO
	       CALL WQ_CONX(CIDC2)
	     ELSE		!TICKS ONLY
	       PC(1)=POINXY(1,1)	!BOTTOM LEFT CORNER
	       PC(2)=POINXY(2,2)
	       PCD(1,1)=STEP(1)*(TAREA(2)-1)/REAL(COCOLP) !STEP ALONG LINE
	       PCD(2,1)=0.
	       PCD(1,2)=0.	!STEP VERTICAL
	       PCD(2,2)=10.
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,3) !DOTTED
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,1)
	       END IF
	       R4=0		!BOTTOM LINE
 	       DO I2=0,1	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(2)-1)/REAL(COCOLP)) !GRID POINT L
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R3*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R4*
	1		(MPHD(MPH_SDEC_D)))),
	1		D0,DEC)
		   D0=WNGDPF(D0-R5)
		   IF (D0.GT.(1.-J5/360./360.)) THEN
		      IF (D0.GT.(1.-J5/720./360.)) THEN
			 A_E(COCOPE+I1)=REAL(D0-1.)*24.*3600.
		      ELSE
			 A_E(COCOPE+I1)=1.E20
		      END IF
		   ELSE
		      A_E(COCOPE+I1)=REAL(D0)*24.*3600. !RA
		   END IF
		 END DO
	         CALL WQ_CONT(CIDC2,A_E(COCOPE))
	         R4=R4+10./STEP(2)
	       END DO
	       CALL WQ_CONX(CIDC2)
	       PC(1)=POINXY(1,1)	!TOP LEFT CORNER
	       PC(2)=POINXY(2,1)
	       PCD(1,1)=STEP(1)*(TAREA(2)-1)/REAL(COCOLP) !STEP ALONG LINE
	       PCD(2,1)=0.
	       PCD(1,2)=0.	!STEP VERTICAL
	       PCD(2,2)=-10.
	       IF (CRDTYP.EQ.2) THEN
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,3) !DOTTED
	       ELSE
 		 CALL WQ_CONJ(CIDC2,COCOLP+1,PC,PCD,
	1		CONTLP,A_E(CONTPE),0.0,1)
	       END IF
	       R4=TAREA(3)-1		!TOP LINE
 	       DO I2=0,1	!LINES
		 DO I1=0,COCOLP	!POINTS IN LINE
		   R3=I1*((TAREA(2)-1)/REAL(COCOLP)) !GRID POINT L
		   CALL WNMCLM(((MPHD(MPH_RA_D))),
	1		((MPHD(MPH_DEC_D))),
	1		REAL(PI2*(L+R3*
	1		(MPHD(MPH_SRA_D)))),
	1		REAL(PI2*(M+R4*
	1		(MPHD(MPH_SDEC_D)))),
	1		D0,DEC)
		   D0=WNGDPF(D0-R5)
		   IF (D0.GT.(1.-J5/360./360.)) THEN
		      IF (D0.GT.(1.-J5/720./360.)) THEN
			 A_E(COCOPE+I1)=REAL(D0-1.)*24.*3600.
		      ELSE
			 A_E(COCOPE+I1)=1.E20
		      END IF
		   ELSE
		      A_E(COCOPE+I1)=REAL(D0)*24.*3600. !RA
		   END IF
		 END DO
	         CALL WQ_CONT(CIDC2,A_E(COCOPE))
	         R4=R4-10./STEP(2)
	       END DO
	       CALL WQ_CONX(CIDC2)
	     END IF
	     CALL WNGFVA(CONTLP*LB_E,CONTP)
	     CALL WNGFVA((COCOLP+1)*LB_E,COCOP)
	  END IF
C
C ANNOTATION
C

	  CALL WQSPLI(1)				!SELECT FULL DRAWN LINE
	  CALL WQSTXU(DIR(1,1))				!SET HORIZONTAL
	  PG(1,1)=POINXY(1,1)				!COORDINATE TYPE
	  PG(2,1)=POINXY(2,2)-30.
	  IF (ABS(CRD).LE.4) THEN
	    CALL WNCTXS(STR,'RA (h:m:s,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	    CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  ELSE
	    CALL WNCTXS(STR,'RA (deg,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	    CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  END IF
	  PG(1,1)=10.
	  PG(2,1)=POINXY(2,2)
	  CALL WQSTXU(DIR(1,2))				!VERTICAL
	  IF (ABS(CRD).LE.4) THEN
	    CALL WNCTXS(STR,'DEC (d.m.s,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	    CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  ELSE
	    CALL WNCTXS(STR,'DEC (deg,!E6.1)',MPHE(MPH_EPO_E)) !EPOCH
	    CALL WQTEXT(PG,STR(:WNCALN(STR)))
	  END IF
	  CALL WQSTXU(DIR(1,1))				!SET HORIZONTAL
	END IF
C
C SOURCES
C
	IF (PLTSRC.GT.0) THEN
#ifndef wn_vx__
	  R0=2
	  IF (PLDEV.EQ.'X11') CALL XWDRIV(15,R0,1,' ',0)
#endif
	  CALL WQSTXX(1.0)				!CHARACTER EXPANSION
C
	  CALL NMOGSH(GDES)				!GET SOURCE HEADER
	  DO J=0,GDESJ(MDH_NSRC_J)-1			!ALL SOURCES
	    CALL WNGMV(MDLHDL,A_B(GDESJ(MDH_MODP_J)+J*MDLHDL-A_OB),
	1		MDL)				!GET MODEL LINE
	    IF (PLTSRC.GT.1) JS=NMONAM(MDL,GDES,STR,.TRUE.) !GET NAME FOR SOURCE
	    CALL NMOEXT(MDL)				!MAKE EXTERNAL FORMAT
	    IF (MDLE(MDL_I_E).NE.0 .AND.		!NOT DELETED
	1			MDL(MDL_TP1_B).LE.4) THEN !AND WANTED
	      IF (MDL(MDL_TP1_B).EQ.0) THEN
			CALL WQSPMI(2)			!+
	      ELSE IF (MDL(MDL_TP1_B).EQ.1) THEN
			CALL WQSPMI(5)			!X
	      ELSE IF (MDL(MDL_TP1_B).EQ.2) THEN
			CALL WQSPMI(3)			!*
	      ELSE IF (MDL(MDL_TP1_B).EQ.3) THEN
			CALL WQSPMI(1)			!.
	      ELSE IF (MDL(MDL_TP1_B).EQ.4) THEN
			CALL WQSPMI(4)			!O
	      END IF
	      PLCR=.TRUE.				!ASSUME INSIDE MAP
	      DO I=1,2					!GET X,Y
		R0=(MDLE(MDL_L_E+I-1)/360./3600.-
	1			(MPHD(MPH_SHR_D+I-1)))/
	1			(MPHD(MPH_SRA_D+I-1))	!GRID POINT SOURCE
		R0=R0-(TAREA(I-1)-(TAREA(I+1)/2))	!GRID POINT OFFSET
		IF (R0.GE.0 .AND. R0.LT.TAREA(I+1)) THEN !INSIDE MAP
		  PG(I,1)=R0*STEP(I)+POINXY(I,I)	!PLOT COORDINATES
		ELSE
		  PLCR=.FALSE.				!DO NOT PLOT
		END IF
	      END DO
	      IF (PLCR) THEN
		CALL WQPOLM(1,PG)		!SET POSITION
		IF (PLTSRC.GT.1) THEN
		   TXTXY(1)=PG(1,1)+10*STEP(1)
		   TXTXY(2)=PG(2,1)+ 5*STEP(2)
		   CALL WQTEXT(TXTXY,STR)
	        END IF
	      END IF
	    END IF
	  END DO
C
	  IF (PLTSRC.GT.2) THEN				!CONNECTIONS
	     DONE=.FALSE.
#ifndef wn_vx__
	     R0=3
	     IF (PLDEV.EQ.'X11') CALL XWDRIV(15,R0,1,' ',0)
#endif
	     CALL WQSTXX(0.5)				!CHARACTER EXPANSION
C
	     DO WHILE (.NOT.DONE) 
	        IF (.NOT.WNDPAR('SOURCES',NAMES,
	1	               2*LEN(NAMES(1)),J0,'*')) DONE=.TRUE.
	        IF (J0.LT.2) DONE=.TRUE.
	        IF (.NOT.DONE) THEN			!FIND SOURCES
C
		  I1=0					!NO MATCH YET
	          DO J=0,GDESJ(MDH_NSRC_J)-1		!ALL SOURCES
	           CALL WNGMV(MDLHDL,
	1	          A_B(GDESJ(MDH_MODP_J)+J*MDLHDL-A_OB),
	1		  MDL)				!GET MODEL LINE
	           JS=NMONAM(MDL,GDES,STR,.FALSE.)	!GET NAME FOR SOURCE
	           IF (STR.EQ.NAMES(1).OR.STR.EQ.NAMES(2)) THEN !MATCH
	             CALL NMOEXT(MDL)			!MAKE EXTERNAL FORMAT
	             PLCR=.TRUE.			!ASSUME INSIDE MAP
	             DO I=1,2				!GET X,Y
		       R0=(MDLE(MDL_L_E+I-1)/360./3600.-
	1			(MPHD(MPH_SHR_D+I-1)))/
	1			(MPHD(MPH_SRA_D+I-1))	 !GRID POINT SOURCE
		       R0=R0-(TAREA(I-1)-(TAREA(I+1)/2)) !GRID POINT OFFSET
		       IF (R0.GE.0 .AND. R0.LT.TAREA(I+1)) THEN !INSIDE MAP
		          PG(I,I1+1)=R0*STEP(I)+POINXY(I,I) !SAVE POSITION
	                  RD(I,I1+1)=MDLE(MDL_L_E+I-1)	    !SAVE COORDINATE
		       ELSE
		          PLCR=.FALSE.			!DO NOT USE
		       END IF
	             END DO
	             IF (PLCR) I1=I1+1			!COUNT MATCH
	           END IF
	          END DO
C
	          IF (I1.NE.2) THEN			!TOO FEW FOUND
	             CALL WNCTXT(F_TP,
	1	        'Not both sources found inside map')
	          ELSE
		     CALL WQPOLL(2,PG)			!DRAW LINE
		     R0=SQRT( ( (RD(1,1)-RD(1,2)) )**2 + 
	1		      ( (RD(2,1)-RD(2,2)) )**2 ) !DISTANCE
	             CALL WNCTXS(STR,'!6$E6.2 deg',R0/3600)	!IN DEGREES
	             IF (WNDPAR('TEXT',STR,LEN(STR),J0,STR)) THEN
	                IF (J0.GT.0.AND.STR.NE.' ') THEN
			   IF ( (PG(1,1)-PG(1,2))*
	1	                (PG(2,1)-PG(2,2)) .LE. 0) THEN
		   	     TXTXY(1)=(PG(1,1)+PG(1,2))/2+4*STEP(1)
			     TXTXY(2)=(PG(2,1)+PG(2,2))/2+4*STEP(2)
		           ELSE
		   	     TXTXY(1)=(PG(1,1)+PG(1,2))/2+4*STEP(1)
			     TXTXY(2)=(PG(2,1)+PG(2,2))/2-8*STEP(2)
			   END IF
			   CALL WQTEXT(TXTXY,STR)
		        END IF
		     END IF
	          END IF
	        END IF
	     END DO
	  END IF
C
#ifndef wn_vx__
	  R0=1
	  IF (PLDEV.EQ.'X11') CALL XWDRIV(15,R0,1,' ',0)
#endif
	END IF
C
C FINISH PLOT
C
CCC9000	CONTINUE
	CALL NPLCLO(DQID2,NHV)			!CLOSE
CCC	CALL WNGSLP(1)				! allow for 2nd control-C
CCC	IF (WNGCCN().GT.1) NO_MORE=.TRUE.	! two seen?
CCC  	CALL WNGCCC				! clear control-C count
C
	RETURN
C
	END

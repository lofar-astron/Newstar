C+ NFLFL0.FOR
C  WNB 930610
C
C  Revisions:
C	WNB 930615	Use FLF_O
C	WNB 930615	Add DF5,6,7,8,3; DFS
C	WNB 930616	Use FLH_O
C	WNB 930617	Make sure 2nd entry in DF2; create DF7
C	WNB 930617	Split off NSCDF5.FOR
C	HJV 930618	Symbolic names for mask bits in CBITS_O_DEF
C	WNB 930618	Renamed from NSCDF0
C	WNB 930714	Correct ranges initialisation; add FLR
C	CMV 930803	Move scaling of DFAR
C	WNB 930807	Change to CBITS_DEF
C
	LOGICAL FUNCTION NFLFL0(DFAR)
C
C  Make and handle flagging files
C
C  Result:
C
C	NFLFL0_L = NFLFL0( DFAR_J:IO)
C				will create area DFAR (if not 0) and a
C				temporary file.
C	NFLFL9_L = NFLFL9( DFAR_J:IO)
C				will remove area and file
C	NFLFL1_L = NFLFL1( DFAR_J:I, FLF1_B(0:*):I)
C				add entry to list
C	NFLFL2_L = NFLFL2( DFAR_J:I, FLF1_B(0:*):O, FLF2_B(0:*):O)
C				get (area) entry from list
C	NFLFLR_L = NFLFLR( DFAR_J:IO)
C				reset get area for FL2
C	NFLFLS_L = NFLFLS( DFAR_J:I, CFLH_B(0:*):O)
C				Return status:	Current header
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'CBITS_DEF'
	INCLUDE 'GFH_O_DEF'
	INCLUDE 'FLH_O_DEF'	!FLF HEADER
	INCLUDE 'FLF_O_DEF'	!FLF ENTRY
C
C  Entry points:
C
	LOGICAL NFLFL9,NFLFL1,NFLFL2
	LOGICAL NFLFLS,NFLFLR
C
C  Parameters:
C
	INTEGER MXENT		!ENTRIES IN CORE
	  PARAMETER (MXENT=8192)
	INTEGER MXRANG		!MAX. RANGE VALUE
	  PARAMETER (MXRANG=65536*16)
C
C  Arguments:
C
	INTEGER DFAR		!AREA FOR FLAGS
	BYTE FLF1(0:*)		!ENTRY
	BYTE FLF2(0:*)		!ENTRY
	BYTE CFLH(0:*)		!FILE HEADER
C
C  Function references:
C
	LOGICAL WNGGVM		!GET VIRTUAL MEMORY
	LOGICAL WNFOP		!OPEN FILE
	LOGICAL WNFRD,WNFWR	!READ/WRITE FILE
	CHARACTER*20 WNFFNM	!FILE NAME
C
C  Data declarations:
C
C
C  Common:
C
	INTEGER BCNT		!FILE COUNT
	INTEGER GCNT		!GET COUNT
	INTEGER FCA		!FILE AREA
	BYTE FLH(0:FLHHDL-1)	!CURRENT FILE HEADER
	  INTEGER FLHJ(0:FLHHDL/LB_J-1)
	  REAL FLHE(0:FLHHDL/LB_E-1)
	  EQUIVALENCE (FLH,FLHJ,FLHE)
	COMMON /FLF_COM/ FLH,BCNT,GCNT,FCA
C-
C
C FL0
C
	NFLFL0=.TRUE.				!ASSUME OK
	IF (DFAR.EQ.0) THEN			!NONE YET
	  IF (.NOT.WNGGVM(MXENT*FLFHDL,DFAR)) THEN !GET AREA
	    DFAR=0
	    GOTO 900
	  END IF
	  DFAR=(DFAR-A_OB)/LB_J			!ARRAY POINTER
	  FCA=0
	  IF (.NOT.WNFOP(FCA,WNFFNM('FLF','TMP'),'WT')) THEN !OPEN TMP FILE
	    GOTO 900
	  END IF
	  BCNT=0				!BLOCK COUNT
	  GCNT=0				!GET COUNT
	  CALL WNGMVZ(FLHHDL,FLH)		!INIT HEADER
	  FLHJ(FLH_VER_J)=FLFHDV		!VERSION
	  FLHJ(FLH_FLFL_J)=FLFHDL		!ENTRY LENGTH
	  FLHJ(FLH_FLFP_J)=GFHHDL+FLHHDL	!ENTRY POINTER
	  DO I=0,1				!RANGES
	    FLHJ(FLH_RCHAN_J+I)=MXRANG-2*I*MXRANG
	    FLHJ(FLH_RIFR_J+I)=MXRANG-2*I*MXRANG
	    FLHJ(FLH_RPOL_J+I)=MXRANG-2*I*MXRANG
	    FLHE(FLH_RHA_E+I)=MXRANG-2*I*MXRANG
	  END DO
	END IF
C
	RETURN
C
C FL9
C
	ENTRY NFLFL9(DFAR)
C
	NFLFL9=.TRUE.				!ASSUME OK
	GOTO 901				!READY
C
C FL1
C
	ENTRY NFLFL1(DFAR,FLF1)
C
	IF (DFAR.EQ.0) GOTO 901			!CANNOT DO
	NFLFL1=.TRUE.				!ASSUME OK
	IF (GCNT.NE.0) THEN			!RESET BUFFERS
	  IF (BCNT.GT.0) THEN
	    IF (.NOT.WNFRD(FCA,MOD(FLHJ(FLH_FLFN_J),MXENT)*FLFHDL,A_J(DFAR),
	1		(BCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	  END IF
	  GCNT=0				!GET FROM START
	END IF
	I=DFAR+MOD(FLHJ(FLH_FLFN_J),MXENT)*FLFHDL/LB_J
	CALL WNGMV(FLFHDL,FLF1,A_J(I))		!GET ENTRY
	FLHJ(FLH_FLAG_J)=IOR(FLHJ(FLH_FLAG_J),A_J(I+FLF_FLAG_J)) !TOTAL FLAG
	IF (A_J(I+FLF_CHAN_J).EQ.-1) THEN	!GET RANGE IN LIST
	  FLHJ(FLH_CHAN_J)=-1
	ELSE IF (FLHJ(FLH_CHAN_J).NE.-1) THEN
	  FLHJ(FLH_RCHAN_J+0)=MIN(A_J(I+FLF_CHAN_J),FLHJ(FLH_RCHAN_J+0))
	  FLHJ(FLH_RCHAN_J+1)=MAX(A_J(I+FLF_CHAN_J),FLHJ(FLH_RCHAN_J+1))
	END IF
	IF (A_J(I+FLF_HA_E).EQ.-1) THEN
	  FLHJ(FLH_HA_J)=-1
	ELSE IF (FLHJ(FLH_HA_J).NE.-1) THEN
	  FLHE(FLH_RHA_E+0)=MIN(A_E(I+FLF_HA_E),FLHE(FLH_RHA_E+0))
	  FLHE(FLH_RHA_E+1)=MAX(A_E(I+FLF_HA_E),FLHE(FLH_RHA_E+1))
	END IF
	I=I*(LB_J/LB_I)
	I1=A_I(I+FLF_IFR_I)
	IF (I1.EQ.-1) THEN
	  FLHJ(FLH_IFR_J)=-1
	ELSE IF (FLHJ(FLH_IFR_J).NE.-1) THEN
	  FLHJ(FLH_RIFR_J+0)=MIN(I1,FLHJ(FLH_RIFR_J+0))
	  FLHJ(FLH_RIFR_J+1)=MAX(I1,FLHJ(FLH_RIFR_J+1))
	END IF
	I1=A_I(I+FLF_POL_I)
	IF (I1.EQ.-1) THEN
	  FLHJ(FLH_POL_J)=-1
	ELSE IF (FLHJ(FLH_POL_J).NE.-1) THEN
	  FLHJ(FLH_RPOL_J+0)=MIN(I1,FLHJ(FLH_RPOL_J+0))
	  FLHJ(FLH_RPOL_J+1)=MAX(I1,FLHJ(FLH_RPOL_J+1))
	END IF
	FLHJ(FLH_FLFN_J)=FLHJ(FLH_FLFN_J)+1
	IF (MOD(FLHJ(FLH_FLFN_J),MXENT).EQ.0) THEN
	  IF (.NOT.WNFWR(FCA,MXENT*FLFHDL,A_J(DFAR),BCNT*FLFHDL)) GOTO 900
	  BCNT=BCNT+MXENT			!COUNT FILE
	END IF
C
	RETURN
C
C FL2
C
	ENTRY NFLFL2(DFAR,FLF1,FLF2)
C
	IF (DFAR.EQ.0) GOTO 901			!CANNOT DO
	NFLFL2=.TRUE.				!ASSUME OK
	IF (GCNT.EQ.0 .AND. BCNT.GT.0) THEN	!SAVE CURRENT BUFFER
	  IF (.NOT.WNFWR(FCA,MOD(FLHJ(FLH_FLFN_J),MXENT)*FLFHDL,A_J(DFAR),
	1		(BCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	  IF (.NOT.WNFRD(FCA,MXENT*FLFHDL,A_J(DFAR),0)) GOTO 900 !1ST BUFFER
	END IF
	IF (GCNT.GE.FLHJ(FLH_FLFN_J)) THEN	!NO MORE
	  GCNT=0				!RESTART
	  IF (BCNT.GT.0) THEN			!REREAD LAST BUFFER
	    IF (.NOT.WNFRD(FCA,MOD(FLHJ(FLH_FLFN_J),MXENT)*FLFHDL,A_J(DFAR),
	1		(BCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	  END IF
	  NFLFL2=.FALSE.
	  GOTO 902
	END IF
	IF (MOD(GCNT,MXENT).EQ.0) THEN		!READ NEXT BUFFER
	  IF (BCNT.GT.0) THEN
	    IF (.NOT.WNFRD(FCA,MIN(FLHJ(FLH_FLFN_J)-GCNT,MXENT)*FLFHDL,
	1		A_J(DFAR),
	1		(GCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	  END IF
	END IF
	I=DFAR+MOD(GCNT,MXENT)*FLFHDL/LB_J
	GCNT=GCNT+1				!NEXT
	IF (IAND(A_J(I+FLF_FLAG_J),1).NE.0) THEN !GET SECOND ENTRY
	  IF (GCNT.GE.FLHJ(FLH_FLFN_J)) THEN	!NO MORE
	    NFLFL2=.FALSE.			!FORMAT ERROR
	    GOTO 902
	  END IF
	  IF (MOD(GCNT,MXENT).EQ.0) THEN	!READ NEXT BUFFER
	    IF (BCNT.GT.0) THEN
	      IF (.NOT.WNFRD(FCA,MIN(FLHJ(FLH_FLFN_J)-GCNT,MXENT)*FLFHDL,
	1		A_J(DFAR),
	1		(GCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	    END IF
	  END IF
	  I1=DFAR+MOD(GCNT,MXENT)*FLFHDL/LB_J
	  GCNT=GCNT+1				!NEXT
	  IF (IAND(A_J(I1+FLF_FLAG_J),2).EQ.0) THEN
	    NFLFL2=.FALSE.			!FORMAT ERROR
	    GOTO 902
	  END IF
	  IF (A_J(I+FLF_CHAN_J).NE.-1 .AND.
	1		A_J(I+FLF_CHAN_J).GT.A_J(I1+FLF_CHAN_J)) THEN !MAX
	    I2=A_J(I+FLF_CHAN_J)
	    A_J(I+FLF_CHAN_J)=A_J(I1+FLF_CHAN_J)
	    A_J(I1+FLF_CHAN_J)=I2
	  END IF
	  IF (A_J(I+FLF_HA_E).NE.-1 .AND.
	1		A_E(I+FLF_HA_E).GT.A_E(I1+FLF_HA_E)) THEN !MAX
	    R0=A_E(I+FLF_HA_E)
	    A_E(I+FLF_HA_E)=A_E(I1+FLF_HA_E)
	    A_E(I1+FLF_HA_E)=R0
	  END IF
	  I=I*(LB_J/LB_I)
	  I1=I1*(LB_J/LB_I)
	  IF (A_I(I+FLF_IFR_I).NE.-1 .AND.
	1		A_I(I+FLF_IFR_I).GT.A_I(I1+FLF_IFR_I)) THEN !MAX
	    I2=A_I(I+FLF_IFR_I)
	    A_I(I+FLF_IFR_I)=A_I(I1+FLF_IFR_I)
	    A_I(I1+FLF_IFR_I)=I2
	  END IF
	  IF (A_I(I+FLF_POL_I).NE.-1 .AND.
	1		A_I(I+FLF_POL_I).GT.A_I(I1+FLF_POL_I)) THEN !MAX
	    I2=A_I(I+FLF_POL_I)
	    A_I(I+FLF_POL_I)=A_I(I1+FLF_POL_I)
	    A_I(I1+FLF_POL_I)=I2
	  END IF
	  CALL WNGMV(FLFHDL,A_I(I),FLF1)	!GET ENTRY
	  CALL WNGMV(FLFHDL,A_I(I1),FLF2)	!GET ENTRY
	ELSE
	  CALL WNGMV(FLFHDL,A_J(I),FLF1)	!GET ENTRY
	  CALL WNGMV(FLFHDL,A_J(I),FLF2)	!COPY ENTRY
	END IF
C
	RETURN
C
C FLR
C
	ENTRY NFLFLR(DFAR)
C
	IF (DFAR.EQ.0) GOTO 901			!CANNOT DO
	NFLFLR=.TRUE.				!ASSUME OK
	IF (GCNT.NE.0) THEN			!RESET BUFFERS
	  IF (BCNT.GT.0) THEN
	    IF (.NOT.WNFRD(FCA,MOD(FLHJ(FLH_FLFN_J),MXENT)*FLFHDL,A_J(DFAR),
	1		(BCNT/MXENT)*MXENT*FLFHDL)) GOTO 900
	  END IF
	  GCNT=0				!GET FROM START
	END IF
C
	RETURN
C
C FLS
C
	ENTRY NFLFLS(DFAR,CFLH)
C
	IF (DFAR.EQ.0) GOTO 901			!CANNOT DO
	NFLFLS=.TRUE.				!ASSUME OK
	CALL WNGMV(FLHHDL,FLH,CFLH)		!RETURN HEADER
C
	RETURN
C
C ERRORS
C
 900	CONTINUE
	NFLFL0=.FALSE.				!RETURN ERROR
 901	CONTINUE
	CALL WNCFCL(F_0)			!MAKE SURE FILE CLOSED
	CALL WNFCL(FCA)				!CLOSE TMP FILE
	IF (DFAR.NE.0) CALL WNGFVM(MXENT*FLFHDL,
	1		DFAR*LB_J+A_OB)		!REMOVE AREA
	DFAR=0
 902	CONTINUE
C
	RETURN
C
C
	END

C+ NMOUPD.FOR
C  WNB 910801
C
C  Revisions:
C	WNB 910909	Add average print
C	WNB 930423	Correct negative DEC error
C	HjV 930518	Change some text
C	WNB 930623	Prepare for Spectral Update
C	WNB 930825	Add dipole position
C	WNB 930826	New model data calculation
C	WNB 931008	Add MINST
C	WNB 931011	Add SI; MBAS
C	WNB 940821	Add polarisation
C       WNB 950611	New LSQ routines
C       WNB 950626	Add grouped types
C       WNB 950630	More options
C       WNB 950706	Add loops
C	WNB 990729	Add X00-X03 options (but assume them all to be ILM)
C
	SUBROUTINE NMOUPD(LEXT)
C
C  Update source flux and positions
C
C  Result:
C
C	CALL NMOUPD( LEXT_I:IO)	Update a source list flux and positions, using
C				a set of scan files. LEXT types (see MDU)
C
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'NMO_DEF'
	INCLUDE 'LSQ_O_DEF'
	INCLUDE 'MDU_O_DEF'
	INCLUDE 'STH_O_DEF'	!SET HEADER
	INCLUDE 'SCH_O_DEF'	!SCAN HEADER
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER LEXT
C
C  Function references:
C
	CHARACTER*32 WNTTSG	!SHOW SET NAME
	LOGICAL WNMLGA		!GET LSQ AREA
	LOGICAL NMORDH		!MODEL HEADER DATA
	LOGICAL NMOMSC		!GET MODEL DATA FOR SCAN FILE
	LOGICAL NMOUP0		!GET LSQ AREA FOR UPDATE
	LOGICAL NSCSTG		!GET A SET
	LOGICAL NSCSCR		!GET A SCAN
	LOGICAL NSCSIF		!READ INTERFEROMETERS
C
C  Data declarations:
C
	INTEGER CSTNAM(0:7)			!CHECK SET NAME
	  DATA CSTNAM/8*-1/
	INTEGER LSQA(1:4)			!LSQ AREAS FOR AVERAGES
	INTEGER*2 IFRT(0:STHIFR-1)		!INTERFEROMETER TABLE
	INTEGER IFRA(0:1,0:STHIFR-1)
	REAL ANG(0:2,0:STHIFR-1)
	REAL BASEL(0:STHIFR-1)			!BASELINE TABLE
	REAL MBAS				!MAX. BASELINE
	REAL WGT(0:STHIFR-1,0:3)		!DATA WEIGHTS XX,XY,YX,YY
	REAL DAT(0:1,0:STHIFR-1,0:3)		!DATA XX,XY,YX,YY
	  COMPLEX CDAT(0:STHIFR-1,0:3)
	  EQUIVALENCE (DAT,CDAT)
	COMPLEX CMOD(0:3,0:STHIFR-1)		!MODEL
	REAL HA					!HA OF SCAN
	INTEGER NPOL				!# OF POL.
	INTEGER STP				!SOURCE TYPE
	DOUBLE PRECISION  SRA,SDEC,SFRQ		!SOURCE RA, DEC, FREQ
	REAL UV0(0:3)				!BASIC UV COORDINATES
	REAL LM0(0:1)				!BASIC SOURCE DISPLACEMENT
	DOUBLE PRECISION FRQ0			!BASIC FREQUENCY
	REAL TF(0:1)				!INTEGR. TIME, BANDWIDTH
	INTEGER MINST				!INSTRUMENT
	REAL DX0,DY0				!HALFWIDTH BEAM
	REAL SOL(4),MU,SD			!SOLVE AVERAGES
	INTEGER SNAM(0:7)			!SET NAME
	INTEGER STHP				!SET HEADER POINTER
	REAL FIT				!LOOP FIT
	INTEGER LCNT				!LCNT
	BYTE STH(0:STH__L-1)			!SET HEADER
	  INTEGER*2 STHI(0:STH__L/LB_I-1)
	  INTEGER STHJ(0:STH__L/LB_J-1)
	  REAL STHE(0:STH__L/LB_E-1)
	  DOUBLE PRECISION STHD(0:STH__L/LB_D-1)
	  EQUIVALENCE (STH,STHI,STHJ,STHE,STHD)
	BYTE SCH(0:SCH__L-1)			!SCAN HEADER
	  INTEGER*2 SCHI(0:SCH__L/LB_I-1)
	  INTEGER SCHJ(0:SCH__L/LB_J-1)
	  REAL SCHE(0:SCH__L/LB_E-1)
	  EQUIVALENCE (SCH,SCHI,SCHJ,SCHE)
C-
C
C INIT
C
	IF (IAND(LEXT,MDU_T_X00).NE.0) THEN
	   LEXT=IOR(LEXT,MDU_T_ILM)
	   CALL WNCTXT(F_TP,'X00 not implemented yet. ILM assumed')
	ELSE IF (IAND(LEXT,MDU_T_X01).NE.0) THEN
	   LEXT=IOR(LEXT,MDU_T_ILM)
	   CALL WNCTXT(F_TP,'X01 not implemented yet. ILM assumed')
	ELSE IF (IAND(LEXT,MDU_T_X02).NE.0) THEN
	   LEXT=IOR(LEXT,MDU_T_ILM)
	   CALL WNCTXT(F_TP,'X02 not implemented yet. ILM assumed')
	ELSE IF (IAND(LEXT,MDU_T_X03).NE.0) THEN	!ASSUME THAT X == ILM
	   LEXT=IOR(LEXT,MDU_T_ILM)
	   CALL WNCTXT(F_TP,'X03 not implemented yet. ILM assumed')
	END IF
	IF (IAND(LEXT,MDU_T_SILM).NE.0) THEN
	   I3=4						!# UNKNOWNS
	ELSE IF (IAND(LEXT,MDU_T_PEST).NE.0) THEN
	   I3=1
	ELSE IF (IAND(LEXT,MDU_T_LM).NE.0) THEN
	   I3=2
	ELSE IF (IAND(LEXT,MDU_T_I).NE.0) THEN
	   I3=1
	ELSE
	   I3=3
	END IF
	LCNT=MXLCNT					!MAX LOOP COUNT
	CALL WNCTXT(F_TP,' ')				!CR
	CALL NMOSRT(0,GDESJ)				!SORT ON INTENSITY
	IF (.NOT.NMOUP0(LEXT)) THEN			!GET LSQ AREA, INIT.
 30	  CONTINUE
	  CALL WNCTXT(F_TP,'No memory for update process')
	  GOTO 901
	END IF
	DO I=1,I3					!GET AVERAGE LSQ
	  IF (.NOT.WNMLGA(LSQA(I),LSQ_T_REAL,1)) GOTO 30
	END DO
C
C EXECUTE LOOP
C
 40	CONTINUE
	IF (.NOT.NMOMSC(FCAIN,SETS)) THEN		!CALCULATE MODEL DATA
	  CALL WNCTXT(F_TP,'Error in model calculation')
	  GOTO 900
	END IF
	DO I=0,7					!TEST SET
	  CSTNAM(I)=-1
	END DO
	MBAS=0						!MAX. BASELINE
	DO I=1,I3					!INIT AVERAGE LSQ
	  CALL WNMLIA(LSQA(I),LSQ_I_ALL)
	END DO
C
C DO SETS
C
	DO WHILE (NSCSTG(FCAIN,SETS,STH,STHP,SNAM))	!NEXT SET
C
C GET IFR TABLES
C
	  IF (.NOT.NSCSIF(FCAIN,STH,IFRT,IFRA,ANG)) THEN !READ IFR TABLE
	    CALL WNCTXT(F_TP,'!/Error reading IFR table !AS',
	1		WNTTSG(SNAM,0))
	    GOTO 10					!TRY NEXT SET
	  END IF
	  CALL NSCMBL(STHE(STH_RTP_E),STHJ(STH_NIFR_J),IFRT,
	1			SIFRS,BASEL)		!MAKE BASEL.
	  DO I1=0,STHJ(STH_NIFR_J)-1			!BASELINES FOR ARCSEC
	    BASEL(I1)=BASEL(I1)/3600./DEG
	  END DO
C
C SHOW CURRENT SET
C
	  DO I1=0,3
	    IF (CSTNAM(I1).NE.SNAM(I1)) THEN
	      DO I2=0,3
		CSTNAM(I2)=SNAM(I2)
	      END DO
	      CALL WNCTXT(F_TP,'Sector: !AS',WNTTSG(CSTNAM,0))
	    END IF
	  END DO
C
C SOURCE MODEL
C
	  NPOL=STHI(STH_PLN_I)				!# OF POL.
	  IF (.NOT.NMORDH(6,STP,SRA,SDEC,SFRQ)) GOTO 10 !MODEL PARAMETERS
	  CALL NMOMST(STP,SRA,SDEC,STH,LM0,FRQ0,TF,MINST) !GET SOME DATA
C
C DO SCANS
C
	  DO I=0,STHJ(STH_SCN_J)-1			!ALL SCANS
C
C INIT
C
	    HA=STHE(STH_HAB_E)+I*STHE(STH_HAI_E)	!HA OF SCAN
	    IF (HA.LT.HARAN(1) .OR. HA.GT.HARAN(2)) GOTO 20 !FORGET
C
C GET DATA
C
	    IF (.NOT.NSCSCR(FCAIN,STH,IFRT,I,CORAP,CORDAP,
	1			SCH,WGT,DAT)) THEN	!READ SCAN DATA
	      CALL WNCTXT(F_TP,'!6$EAF6.2 Error reading scan data',HA)
	      GOTO 10					!TRY NEXT SET
	    END IF
C
C GET SOURCE MODEL
C
	    CALL NMOMUV(STP,SRA,SDEC,STH,SCH,UV0)	!GET UV DATA
	    CALL NMOMU4(0,FCAIN,I,STH,UV0,LM0,FRQ0,
	1		STHE(STH_RTP_E),NPOL,STHJ(STH_NIFR_J),
	1		IFRT,TF,MINST,CMOD)		!GET MODEL
	    CALL NMOMUA(1,UV0,LM0,FRQ0,STHE(STH_RTP_E),4,
	1		STHJ(STH_NIFR_J),IFRT,TF,MINST,CMOD) !ADD TYPES 1
	    CALL NMOCIY(STHJ,SCHE,ANG,CDAT,CMOD,-1)	!CORRECT DATA
C
C MAKE EQUATIONS
C
	    CALL NMOUP1(LEXT,UV0,LM0,FRQ0,STHE(STH_RTP_E),
	1		STHJ(STH_NIFR_J),IFRT,TF,MINST,
	1		SPOL,BASEL,MBAS,WGT,DAT,
	1		STH,SCH,ANG)			!MAKE EQUATIONS
C
C NEXT SCAN
C
 20	    CONTINUE
	  END DO
C
C NEXT SET
C
 10	  CONTINUE
	END DO						!END SETS
C
C SOLVE
C
	IF (MBAS.LE.0) THEN				!MAKE GUESS FOR BEAM
	  DX0=1.5/(3000.*PI2*STHD(STH_FRQ_D)/CL/(1.E-6)) !BEAM RADIANS
	ELSE
	  DX0=1.5/(MBAS*3600.*DEG*PI2*STHD(STH_FRQ_D)/CL/(1.E-6)) !BEAM RADIANS
	END IF
	DY0=DX0/ABS(SIN(STHD(STH_DEC_D))*DPI2)
	CALL NMOUP2(LEXT,DX0,DY0,LSQA,FIT)		!SOLVE EQUATIONS
C
C SHOW RESULTS
C
	CALL NMOUP3(LEXT)				!SHOW RESULTS
C
C SHOW AVERAGES
C
	DO I=1,I3					!GET AVERAGES
	  CALL WNMLTR(LSQA(I),I0)			!CAN SOLVE
	  CALL WNMLSN(LSQA(I),SOL(I),MU,SD)
	END DO
	IF (IAND(LEXT,MDU_M_LOOP+MDU_M_ELOOP).EQ.MDU_M_LOOP) THEN
	   CALL WNCTXT(F_TP,'Loop !UJ produced goodness !E12.4',
	1	MXLCNT-LCNT,FIT)
	END IF
	IF (IAND(LEXT,MDU_T_ILM+MDU_T_SILM).NE.0) THEN 	!SHOW AVERAGES
	  CALL WNCTXT(F_TP,'Average weighted amplitude '//
	1		'gain (A(old)/A(new)):!60C!E10.3',
	1		SOL(1))
	  CALL WNCTXT(F_TP,'Average weighted l,m shift '//
	1		'(arcsec, old-new):!60C!2E10.3',
	1		SOL(2))
	  IF (IAND(LEXT,MDU_T_SILM).NE.0) THEN
	    CALL WNCTXT(F_TP,'Average weighted SI update '//
	1		'(old-new):!60C!E10.3',
	1		SOL(4))
	  END IF
	ELSE IF (IAND(LEXT,MDU_T_I).NE.0) THEN
	  CALL WNCTXT(F_TP,'Average weighted amplitude '//
	1		'gain (A(old)/A(new)):!60C!E10.3',
	1		SOL(1))
	ELSE IF (IAND(LEXT,MDU_T_LM).NE.0) THEN
	  CALL WNCTXT(F_TP,'Average weighted l,m shift '//
	1		'(arcsec, old-new):!60C!2E10.3',
	1		SOL(1))
	ELSE IF (IAND(LEXT,MDU_T_EXT).NE.0) THEN 	!EXTENDED
C	  CALL WNCTXT(F_TP,'Average weighted updates '//
C	1		'(old-new):!60C!3E10.3',
C	1		SOL(1))
	ELSE IF (IAND(LEXT,MDU_T_QUV).NE.0) THEN	!POL
	  CALL WNCTXT(F_TP,'Average weighted QUV '//
	1		'gain (A(old)/A(new)):!60C!3E10.3',
	1		SOL(1))
	ELSE						!ESTIMATE
	  CALL WNCTXT(F_TP,'***Estimate not yet implemented***') 
	END IF
C
C LOOP
C
	IF (IAND(LEXT,MDU_M_LOOP+MDU_M_ELOOP).EQ.MDU_M_LOOP) THEN
	   IF ((FIT.GT.0 .OR. FIT.LT.-.001) .AND. LCNT.GT.0) THEN
	      LCNT=LCNT-1
	   ELSE
	      LEXT=LEXT+MDU_M_ELOOP
	   END IF
	   GOTO 40					!LOOP
	END IF
C
C READY
C
 900	CONTINUE
	CALL NMOUP9(LEXT)				!DELETE LSQ AREA
	DO I=1,I3					!FREE LSQ AVERAGE
	  CALL WNMLFA(LSQA(I))
	END DO
 901	CONTINUE
	CALL WNFCL(FCAIN)				!CLOSE INPUT
C
	RETURN
C
C
	END

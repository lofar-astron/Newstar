C+ NSCLRD.FOR
C  WNB 900226
C
C  Revisions:
C	WNB 910513	System 52 error
C	WNB 910930	Cater for variable integration time in non-mozaick
C	HjV 920520	HP does not allow extended source lines
C	WNB 920815	Add DWELT argument
C	WNB 920816	Add SPLIT argument
C	WNB 920818	Add Tsys weights
C	WNB 920828	Update velocity and frequency for line
C	WNB 930604	Change weight/flagging, add FWGT
C	WNB 930618	Correction weight scales for OF
C	WNB 930621	Correct weight for UF
C	WNB 930803	New OFFSET definitions for RECORD
C	JPH 931213	Report which ifr in case of Format error; comments
C       HjV 940407      Correct for 'older' tape-versions (= <6)
C	CMV 940418	Correct test on DCB bandwidth
C	CMV 940518	Correct frequency
C	CMV 940815	Correct bandwidth (SFREQ*0.0001, not 0.00001)
C	CMV 940830	Save WSRT applied gain corrections
C	CMV 941121	Add entry NSCLR2 to get DWELT and DRADT
C	CMV 950307	Correct AOTH correction if telescopes deleted
C	HjV 950424	Check if IF is present
C	CMV 960910	Also use band 8 for DCB if FVERS<46....
C
C
	LOGICAL FUNCTION NSCLRD(INFCA,SHP,FCAT,VS,FVERS,BECODE,SFREQ,
	1                       BINT,HABOFF,ONS,OHAB,NIFR,IFRT,STHJ,
	1			STHE,STHD,DWELT,SPLIT,TSYS,FWGT,
	1			IFHJ,IFHE,TPBUF,OBUF,DBUF,TMPBUF)
C
C  Read WSRT data into TMP file
C
C  Result:
C
C	NSCLRD_J = NSCLRD( INFCA_J:I, SHP_J:I, FCAT_J:I, VS_J:I,
C                       FVERS_J:I, BECODE_C(4):I, SFREQ_J:I,
C			BINT_J:I, HABOFF_E:I, ONS_J(6):IO, OHAB_E:IO,
C			NIFR_J:IO, IFRT_J(9,0:*):IO,
C			STHJ_J(0:*):IO, STHE_E(0:*):IO, STHD_D(0:*):IO,
C			DWELT_J:O, SPLIT_L:I, TSYS_E(0:1,0:*):I, FWGT_E:IO, 
C			IFHJ_J(0:*):I,IFHE_E(0:*):I,
C			TPBUF_I(2,0:1,0:STHTEL-1,0:*):I, 
C			OBUF_E(0:1,0:STHTEL-1,0:*):O, 
C			DBUF_I(2,0:*):I, TMPBUF_I(3:0:*))
C				Read WSRT data from tape/disk to TMP file.
C				INFCA indicates the file to read, SHP the
C				record number of the SH block. FCAT is the
C				TMP file; VS the software version (e.g.42).
C				FVERS the tape version.
C				BECODE the Back-End code (e.g. DLB).
C				SFREQ is spacing frequency points.
C				BINT is the basic integration time (10 s).
C				HABOFF gives the start of integration.
C				ONS gives the integration data, OHAB the
C				start HA of the output. If ONS(1)<0 the
C				start of a new channel is indicated.
C				NIFR is the number of inetrferometers found,
C				IFRT describes the interferometers.
C				STH is the template set header
C				DWELT is returned from IH
C				SPLIT indicates normal(GM or NM type)
C				TSYS are the X,Y 1/Tsys weights for telescopes.
C				FWGT the max. value of all integration times
C				IFHJ and IFHE are the IF-header for TPBUF
C				TPBUF contains total power data
C				DBUF is an input buffer, TMBUF is used for
C				writing, OBUF returns the AOTH corrections.
C
C	NSCLR2_J = NSCLR2( INFCA_J:I, SHP_J:I, 
C			VS_J:I, FVERS_J:I, BECODE_C(4):I, SFREQ_J:I,
C			DWELT2_J:O, DRADT2_J:O)
C
C			Just read SH and IH to get DWELT and DRADT
C	
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'NSC_DEF'
	INCLUDE 'SHW_O_DEF'			!SH BLOCK
	INCLUDE 'SHW_T_DEF'
	INCLUDE 'IHW_O_DEF'			!IH BLOCK
	INCLUDE 'IHW_T_DEF'
	INCLUDE 'STH_O_DEF'			!SET HEADER
	INCLUDE 'IFH_O_DEF'			!IF-SET HEADER
C
C  Parameters:
C
C
C  Entry points:
C
	LOGICAL NSCLR2				!GET DWELT AND DRADT
C
C  Arguments:
C
	INTEGER INFCA				!INPUT FILE DESCRIPTOR
	INTEGER SHP				!RECORD # SH BLOCK
	INTEGER FCAT				!TMP OUTPUT FILE DESCRIPTOR
	INTEGER VS				!TAPE SOFTWARE VERSION
	INTEGER FVERS				!TAPE FORMAT VERSION
	CHARACTER*4 BECODE			!BACKEND CODE
	INTEGER SFREQ				!SFREQ FROM OH
	INTEGER BINT				!BASIC INTEGRATION IN SEC
	REAL HABOFF				!INTEGRATION START OFFSET
	INTEGER ONS(6)				!INTEGRATION DATA
	REAL OHAB				!START HA
	INTEGER NIFR				!# OF IFRS FOUND
	INTEGER IFRT(9,0:*)			!IFR DESCRIPTION
	INTEGER STHJ(0:*)			!SET HEADER
	REAL STHE(0:*)
	REAL*8 STHD(0:*)
	INTEGER DWELT				!DWELL TIME
	LOGICAL SPLIT
	REAL TSYS(0:1,0:*)			!1/TSYS
	REAL FWGT				!MAX. INT. TIMES
	INTEGER IFHJ(0:*)			!IF-Header
	REAL IFHE(0:*)				!IF-Header
	INTEGER*2 TPBUF(2,0:1,0:STHTEL-1,0:MXDATN-1)	!BUFFER FOR IF-DATA
	INTEGER*2 DBUF(2,0:MXDATN-1)		!INPUT BUFFER
	REAL*4 OBUF(0:1,0:STHTEL-1,0:MXDATN-1)	!OUTPUT BUFFER FOR AOTH
	INTEGER*2 TMPBUF(3,0:MXDATX-1)		!OUTPUT BUFFER FOR WRITING
C
	INTEGER DWELT2				!OUTPUT FOR NSCLR2
	INTEGER DRADT2
C
C  Function references:
C
	LOGICAL WNFRD				!READ DATA
	LOGICAL WNFWR				!WRITE DATA
	INTEGER WNFEOF				!FILE POSITION
C
C  Data declarations:
C
	LOGICAL MOS_ONLY			!JUST GET DWELT/DRADT (NSCLR2)
	REAL SUMC,SUMS				!INTEGRATE
	INTEGER N				!# OF INTEGRATED POINTS
	REAL GBUF(0:1,0:STHTEL-1,4)		!INTEGRATE GAINS
	REAL SFAC				!DATA SCALE
	INTEGER NS(-6:6)			!INTEGRATION DATA
	REAL HAB				!START HA
	REAL WFAC				!WEIGHT FACTOR
	INTEGER WEXP				!WEIGHT EXPONENTXXX
C
	INTEGER*2 DBH_T(2,2)			!TRANSLATE DATA
	  DATA DBH_T/2,0,0,1/
	INTEGER BFJ
	REAL BFR
	EQUIVALENCE (BFR,BFJ)
	INTEGER*2 BF_T1(2,2)
	  DATA BF_T1(1,1),BF_T1(2,1)/3,1/
	  DATA BF_T1(1,2),BF_T1(2,2)/0,1/
	INTEGER*2 BF_T2(2,2)
	  DATA BF_T2(1,1),BF_T2(2,1)/4,1/
	  DATA BF_T2(1,2),BF_T2(2,2)/0,1/
C
	BYTE SHW(0:SHWHDL-1)			!SH RECORD
	  INTEGER*2 SHWI(0:SHWHDL/2-1)
	  INTEGER   SHWJ(0:SHWHDL/4-1)
	  REAL SHWE(0:SHWHDL/4-1)
	  EQUIVALENCE (SHW,SHWI,SHWJ,SHWE)
	BYTE IHW(0:IHWHDL-1)			!IH RECORD
	  INTEGER*2 IHWI(0:IHWHDL/2-1)
	  INTEGER   IHWJ(0:IHWHDL/4-1)
	  REAL IHWE(0:IHWHDL/4-1)
	  EQUIVALENCE (IHW,IHWI,IHWJ,IHWE)
C-
C
C INIT
C
	MOS_ONLY=.FALSE.
	GOTO 100
C
	ENTRY NSCLR2(INFCA, SHP, VS, FVERS, BECODE, SFREQ, 
	1		DWELT2, DRADT2)
C
	MOS_ONLY=.TRUE.
C
  100	CONTINUE
C
	NSCLRD=.TRUE.				!ASSUME OK
	DBH_T(2,1)=2*MXDATN			!ENOUGH TRANSLATION
	IF (.NOT.WNFRD(INFCA,SHWHDL,SHW,SHP*SRTRCL)) THEN !READ SH BLOCK
	  CALL WNCTXT(F_TP,'!/Read error SH block #!UJ (!XJ)',
	1			SHP,E_C)
	  GOTO 900				!FINISH
	END IF
	IF (IBMSW) CALL WNTTIL(SHWHDL,SHW,SHW_T) !TRANSLATE
	IF (DECSW) CALL WNTTDL(SHWHDL,SHW,SHW_T)
	IF (SHWI(SHW_CBI_I).NE.32767 .OR.
	1		SHW(SHW_CBT_1).NE.ICHAR('S') .OR.
	1		SHW(SHW_CBT_1+1).NE.ICHAR('H')) THEN
	  CALL WNCTXT(F_TP,'!/Cannot find SH block #!UJ',SHP)
	  GOTO 900
	END IF
	SHWJ(SHW_LSH_J)=SHWHDL			!LENGTH SH
C
C REPAIR SH
C
	IF (FVERS.LT.2) THEN			!REPAIR BFREQ
	  BFJ=SHWJ(SHW_BFREQ_J)
	  IF (IBMSW) CALL WNTTLI(LB_J,BFJ,BF_T1)
	  IF (DECSW) CALL WNTTLD(LB_J,BFJ,BF_T1)
	  IF (IBMSW) CALL WNTTIL(LB_J,BFR,BF_T2)
	  IF (DECSW) CALL WNTTDL(LB_J,BFR,BF_T2)
	  SHWJ(SHW_BFREQ_J)=NINT(BFR*65536.)
	END IF
	IF (FVERS.LT.3) SHWI(SHW_STIM_I)=SHWI(SHW_STIM_I)*6
	IF (FVERS.LT.6) SHWI(SHW_BANDNR_I)=(SHWI(SHW_BANDNR_I)-1)/4
	IF (VS.LT.46) THEN			!FIND WIDTH
	  IF (BECODE(1:3).EQ.'DCB') THEN
	    I1=SHWI(SHW_BANDNR_I)-1
	    IF (I1.GE.0.AND.I1.LE.7) THEN	!VALID BAND
	      IF (IAND(SFREQ,2**I1)) THEN	!TEST BAND USED
	        IF (IAND(SFREQ,2**(I1+8))) THEN	!TEST BANDWIDTH
		  SHWE(SHW_WIDTH_E)=5.0
	        ELSE
		  SHWE(SHW_WIDTH_E)=10.0
	        END IF
	      ELSE				!NOT USED???
		CALL WNCTXT(F_P,'Band !SJ seems not in use???',I1+1)
		SHWE(SHW_WIDTH_E)=10.0		!ASSUME 10
	      END IF
	    ELSE				!CONTINUUM, SET TO 10
	      SHWE(SHW_WIDTH_E)=10.0
	    END IF
	  ELSE
	    SHWE(SHW_WIDTH_E)=SFREQ*0.0001	!SFREQ IS IN 0.1 KHZ
	  END IF
	END IF
C
C SAVE SH AND FILL IN STH
C
	IF (.NOT.MOS_ONLY) THEN
	  STHJ(STH_NSH_J)=SHWHDL		!SAVE SH BLOCK
	  STHJ(STH_SHP_J)=WNFEOF(FCAOUT)
	  IF (.NOT.WNFWR(FCAOUT,SHWHDL,SHW,STHJ(STH_SHP_J))) THEN !SAVE SH
	    CALL WNCTXT(F_TP,'!/Write error SCN file (!XJ)',E_C)
	    GOTO 900
	  END IF
	  STHD(STH_FRQ_D)=SHWJ(SHW_BFREQ_J)/65536. !FREQUENCY
	  STHD(STH_FRQE_D)=SHWJ(SHW_BFREQ_J)/65536. !FREQUENCY EPOCH
	  STHE(STH_BAND_E)=SHWE(SHW_WIDTH_E)	!BANDWIDTH
	  STHD(STH_FRQV_D)=STHD(STH_FRQ_D)	!REAL FREQUENCY LINE
	  IF (STHJ(STH_VELC_J).LE.0) THEN		!CONTINUUM
	    STHE(STH_VEL_E)=0			!VELOCITY
	  ELSE					!LINE
	    IF (STHD(STH_FRQV_D).LE.0) 
	1		STHD(STH_FRQV_D)=STHD(STH_FRQ_D) !MAKE ONE
	    IF (STHD(STH_FRQC_D).LE.0) 
	1		STHD(STH_FRQC_D)=STHD(STH_FRQ_D) !MAKE ONE
	    IF (STHJ(STH_VELC_J).EQ.1 .OR.
	1		STHJ(STH_VELC_J).EQ.2) THEN !RADIO
	      STHE(STH_VEL_E)=STHE(STH_VELR_E)*STHD(STH_FRQV_D)/
	1		STHD(STH_FRQC_D)+
	1		CL*(STHD(STH_FRQC_D)-STHD(STH_FRQV_D))/
	1		STHD(STH_FRQC_D)
	    ELSE					!OPTICAL
	      STHE(STH_VEL_E)=STHE(STH_VELR_E)*STHD(STH_FRQC_D)/
	1		STHD(STH_FRQV_D)+
	1		CL*(STHD(STH_FRQC_D)-STHD(STH_FRQV_D))/
	1		STHD(STH_FRQV_D)
	    END IF
	  END IF
	END IF

C
C READ IFRS
C
	DO I=0,SHWI(SHW_NENT_I)-1		!ALL INTERFEROMETERS
	  I1=SHW_IFR_1+I*SHWI(SHW_LENT_I)	!TABLE ENTRY
	  I2=I1/LB_I				!AS I2
	  I4=I1/LB_J				!AS I4
	  J=SHWJ(I4+IFR_NIH_J)*SRTRCL		!DISK POINTER IH
	  IF (.NOT.WNFRD(INFCA,IHWHDL,IHW,J)) THEN !READ IH BLOCK
	    CALL WNCTXT(F_TP,'!/Read error IH block #!UJ (!XJ)',
	1		J/SRTRCL,E_C)
	    GOTO 10				!NEXT
	  END IF
	  IF (IBMSW) CALL WNTTIL(IHWHDL,IHW,IHW_T) !TRANSLATE
	  IF (DECSW) CALL WNTTDL(IHWHDL,IHW,IHW_T)
	  IF (IHWI(IHW_CBI_I).NE.32767 .OR.
	1		IHW(IHW_CBT_1).NE.ICHAR('I') .OR.
	1		IHW(IHW_CBT_1+1).NE.ICHAR('H')) THEN
	    CALL WNCTXT(F_TP,'!/Cannot find IH block #!UJ',J/SRTRCL)
	    GOTO 10
	  END IF
C
C REPAIR IH
C
	  IF (FVERS.LT.3) IHWI(IHW_STIM_I)=IHWI(IHW_STIM_I)*6
	  IF (VS.LT.53) THEN
	    IHWE(IHW_INTT_E)=IHWI(IHW_INCT_I)
	  END IF
	  IF (VS.LT.60) THEN
	    IHWI(IHW_DWELT_I)=IHWI(IHW_INCT_I)
	    IHWI(IHW_DRADT_I)=IHWI(IHW_INCT_I)
	  END IF
	  IF (FVERS.LT.2) THEN			!UPDATE IFR CODE
	    I1=NINT(MOD(IHWI(IHW_INFNR_I),40)/2.)	!FIXED
	    I2=NINT(IHWI(IHW_INFNR_I)/40.)+9+MOD(IHWI(IHW_INFNR_I),2)	!MOVABLE
	    IHWI(IHW_INFNR_I)=256*I1+I2
	  END IF
C
C IF MOS_ONLY, GET VALUES HERE AND EXIT
C
	  IF (MOS_ONLY) THEN
	     DWELT2=IHWI(IHW_DWELT_I)
	     DRADT2=IHWI(IHW_DRADT_I)
	     RETURN				!DIRTY WAY TO JUMP OUT OF LOOP
	  END IF
C
C DETERMINE STEPS
C
	  DWELT=IHWI(IHW_DWELT_I)		!DWELL TIME
	  IF (VS.EQ.52) THEN			!FORMAT ERROR SYSTEM 52
	    IHWI(IHW_INCT_I)=NINT(IHWE(IHW_DHA_E)/CVUTST*
	1		240.*360.)		!UT STEP IN SECONDS
	  END IF
	  IF (VS.EQ.42) THEN			!TAPE FORMAT ERROR SYSTEM 42
	    SFAC=1.
	  ELSE
	    SFAC=2.E0**FLOAT(IHWI(IHW_NEXP_I))*FLOAT(IHWI(IHW_FSCAL_I)) !SCALE
	  END IF
	  NS(-3)=NINT(HABOFF/BINT)		!START INTEGRATION OFFSET
	  NS(0)=IHWI(IHW_INCT_I)/BINT		!INPUT INTEGRATION POINTS
	  NS(-1)=IHWI(IHW_NDATP_I)		!INPUT DATA POINTS
	  NS(1)=OINT/BINT			!OUTPUT INTEGRATION POINTS
	  IF (VS.GE.59 .OR. .NOT.SPLIT) THEN	!MOSAIC
	    NS(-2)=DWELT/BINT			!DWELL TIME
	    NS(3)=IHWI(IHW_DRADT_I)/BINT	!TIME BETWEEN RADIALS
	    IF (NS(-2).EQ.NS(0)) THEN		!NO MOSAIC
	      NS(-2)=IHWI(IHW_NDATP_I)*NS(0)
	      NS(3)=NS(-2)
	    END IF
	  ELSE					!NO MOSAIC
	    NS(-2)=IHWI(IHW_NDATP_I)*NS(0)
	    NS(3)=NS(-2)
	  END IF
	  IF (NS(-2)-NS(-3).LT.NS(1)) THEN	!INTEGRATION TOO LONG
	    CALL WNCTXT(F_TP,'Dwell time (!UJ s) less than '//
	1		'integration time (!UJ s)',
	2		(NS(-2)-NS(-3))*BINT,NS(1)*BINT)
	    GOTO 900
	  END IF
	  NS(2)=NS(-1)/(NS(-2)/NS(0))		!# OF SUBSETS
	  NS(4)=(NS(-2)-NS(-3))/NS(1)		!# OUTPUT DWELL POINTS
	  NS(5)=NS(2)*NS(4)			!# OUTPUT DATAPOINTS
	  NS(6)=0				!TMP DISK POINTER
	  HAB=IHWE(IHW_HAB_E)+CVUTST*((NS(1)-NS(0))/2.+NS(-3))*
	1		BINT/24./3600.		!START HA
C
C READ/CHECK DATA
C
	  IF (.NOT.WNFRD(INFCA,NS(-1)*4,DBUF,
	1			J+SRTRCL*IHWJ(IHW_LIH_J))) THEN !READ DB BLOCK
	    CALL WNCTXT(F_TP,'!/Read error DB block #!UJ (!XJ)',
	1			J/SRTRCL,E_C)
	    GOTO 10				!NEXT
	  END IF
	  IF (IBMSW) CALL WNTTIL(NS(-1)*4,DBUF,DBH_T) !TRANSLATE
	  IF (DECSW) CALL WNTTDL(NS(-1)*4,DBUF,DBH_T)
	  IF (ONS(1).LT.0) THEN			!NEW CHANNEL
	    CALL WNGMVZ(2*STHTEL*MXDATN,OBUF)	!CLEAR AOTH BUFFER
	    DO I1=1,6
	      ONS(I1)=NS(I1)			!SAVE DATE
	    END DO
	    OHAB=HAB
	  ELSE
	    DO I1=1,5
	      IF (ONS(I1).NE.NS(I1)) THEN	!FORMAT ERROR
		IF (I1.EQ.3 .AND. NS(2).EQ.1) THEN !ACCEPT WRONG OBS. LENGTH
		ELSE
 20	          CALL WNCTXT(F_TP,
	1	'!/Format error DB block #!UJ, interferometer !1$XI!1$XI',
	1		J/SRTRCL,IHWI(IHW_WTEL_I),IHWI(IHW_OTEL_I))
	          GOTO 10			!NEXT
		END IF
	      END IF
	    END DO
C Check for correct HAB; a margin of .1 sec is accepted to account for precision
C  effects on different machines; the corresponding rotation of 1.15E-6 circles
C  is acceptable (Email WNB to JPH, 931214)
	    IF (ABS(OHAB-HAB).GE.0.1E0/24./3600.) GOTO 20
	  END IF
C
C MAKE entry for this polarisation and ifr in temporary IFR TABLE
C
	  DO I1=0,NIFR-1			!CHECK PRESENCE
	    IF (IFRT(1,I1).EQ.IHWI(IHW_WTEL_I) .AND.
	1		IFRT(2,I1).EQ.IHWI(IHW_OTEL_I)) THEN !FOUND
	      I2=MOD(IHWI(IHW_INFNR_I)/256,2)*2+
	1		MOD(IHWI(IHW_INFNR_I),2) !POL. #
	      IFRT(3+I2,I1)=ONS(6)/NS(5)/6	!TMP LINE #
	      GOTO 30
	    END IF
	  END DO
	  IFRT(1,NIFR)=IHWI(IHW_WTEL_I)		!WEST TEL.
	  IFRT(2,NIFR)=IHWI(IHW_OTEL_I)		!EAST TEL.
	  IF (IFRT(1,NIFR).GT.IFRT(2,NIFR)) GOTO 10 !FORGET INVERTED IFR
	  IF (IFRT(2,NIFR).GE.STHTEL) GOTO 10	!FORGET DUMMY INTERFEROMETERS
	  DO I2=3,6				!SET NO POL.
	    IFRT(I2,NIFR)=-1
	  END DO
	  I2=MOD(IHWI(IHW_INFNR_I)/256,2)*2+MOD(IHWI(IHW_INFNR_I)*1,2) !POL. #
	  IFRT(3+I2,NIFR)=ONS(6)/NS(5)/6	!TMP LINE #
	  IFRT(7,NIFR)=NINT(IHWE(IHW_DRT_E))	!BASELINE
	  NIFR=NIFR+1				!COUNT # IFRS
 30	  CONTINUE
C
C MAKE OUTPUT BUFFER
C
	  R0=TSYS(MOD(IHWI(IHW_INFNR_I)/256,2),
	1		IHWI(IHW_WTEL_I))*
	1		TSYS(MOD(IHWI(IHW_INFNR_I)*1,2),
	1		IHWI(IHW_OTEL_I))	!TSYS WEIGHT
	  R0=R0/4./NS(1)			!FIT SCALE
	  DO I1=0,NS(2)-1			!SUBSETS
	    J1=I1*NS(-2)+NS(-3)			!INPUT DATA PTR
	    J2=I1*NS(4)				!OUTPUT BUF PTR
	    DO I2=0,NS(4)-1			!OUTPUT POINTS PER DWELL
	      SUMC=0				!INTEGRATE
	      SUMS=0
	      N=0
C
	      IF (NIFR.EQ.1 .AND. IFHJ(IFH_TPINT_J).NE.0) THEN	!FIND GAINCORRECTIONS
	         DO I5=0,STHTEL-1
	           DO I4=0,1
	             GBUF(I4,I5,1)=0
	           END DO
	         END DO
	      END IF
C
	      DO I3=0,NS(1)-1			!# OF 10 SEC OUTPUT INTEGRAT.
	        J3=J1/NS(0)			!DATA POINT
	        IF (DBUF(1,J3).NE.IUND .AND. DBUF(2,J3).NE.IUND) THEN
		  SUMC=SUMC+SFAC*DBUF(1,J3)	!ADD
		  SUMS=SUMS+SFAC*DBUF(2,J3)
		  N=N+1
		END IF
C
C For first ifr, average gaincorrections
C
	        IF (NIFR.EQ.1 .AND. IFHJ(IFH_TPINT_J).NE.0) THEN
	           J3=J3*IHWI(IHW_INCT_I)/IFHJ(IFH_TPINT_J)	!TPBUF offset
		   CALL NSCGGN(GBUF(0,0,2),GBUF(0,0,3),GBUF(0,0,4),
	1			IFHJ,STHJ,TPBUF(1,0,0,J3))
	           DO I5=0,STHTEL-1
	             DO I4=0,1
	               GBUF(I4,I5,1)=GBUF(I4,I5,1)+GBUF(I4,I5,2)
	             END DO
	           END DO
		END IF
C
	        J1=J1+1				!NEXT 10 SEC
	      END DO
C
C Save AOTH data regardless of this point being ok for this ifr
C
	      IF (NIFR.EQ.1 .AND. IFHJ(IFH_TPINT_J).NE.0) THEN	!STORE AOTH correction
	         DO I5=0,STHTEL-1
	           DO I4=0,1
	             OBUF(I4,I5,J2)=LOG(ABS(NS(1)/GBUF(I4,I5,1)))
	           END DO
	         END DO
	      END IF
C
	      IF (N.EQ.NS(1)) THEN		!OK POINT
		TMPBUF(2,J2)=NINT(SUMC/N)	!OUTPUT DATA
		TMPBUF(3,J2)=NINT(SUMS/N)
		R1=MIN(MAX(N,NS(0))*R0,127.*256.) !TIME+TSYS WEIGTH
		FWGT=MAX(FWGT,R1)		!SAVE MAX.
		TMPBUF(1,J2)=NINT(R1)		!TIME+TSYS WEIGHT
	      ELSE
		DO I3=1,3
		  TMPBUF(I3,J2)=0		!ZERO WEIGHT
		END DO
	      END IF
	      J2=J2+1				!NEXT OUTPUT PTR
	    END DO
	  END DO
	  IF (.NOT.WNFWR(FCAT,NS(5)*6,TMPBUF,ONS(6))) THEN !WRITE TO TMP
	    CALL WNCTXT(F_TP,
	1		'!/Write error TMP file, IH block #!UJ (!XJ)',
	1		J/SRTRCL,E_C)
	    GOTO 10				!NEXT
	  END IF
	  ONS(6)=ONS(6)+NS(5)*6			!NEXT OUTPUT PTR
 10	  CONTINUE
	END DO
C
	RETURN					!READY
C
C ERROR FINISH
C
 900	CONTINUE
	NSCLRD=.FALSE.
C
	RETURN
C
C
	END










C+ NSCLWD.FOR
C  WNB 900304
C
C  Revisions:
C	HjV 920520	HP does not allow extended source lines
C	WNB 920808	Correct description
C	WNB 920814	Moved some from NSCLOD
C	WNB 920814	Add splitting
C	WNB 920815	More splitting
C	WNB 920817	More splitting
C	WNB 920828	Update for line velocity and frequency
C	WNB 920829	Change logics for speed in splitting
C	WNB 920901	Increase buffer
C	WNB 930604	New weight system, add FWGT
C	WNB 930625	Cater for weight UF
C       HjV 960618	Change length to read for OH
C
	LOGICAL FUNCTION NSCLWD(FCAT,ONS,OHAB,NIFR,IFRT,POLS,BINT,STHM,
	1			MJDHA0,SPLIT,CJOB,MSNP,OHP,BAND,
	1			DWELT,FSPLIT,RACMOS,FRCMOS,FWGT,
	1			OBUF,TMPBUF)
C
C  Unload TMP file into SCN files
C
C  Result:
C
C	NSCLWD_J = NSCLWD( FCAT_J:I,
C			ONS_J(6):I, OHAB_E:I,
C			NIFR_J:I, IFRT_J(9,0:*):I, POLS_J(0:3):I,
C			BINT_J:I, STHM_B(0:*):I, MJDHA0_D:I,
C			SPLIT_L:I, CJOB_J:I, MSNP_I:I, OHP_J(*):I,
C			BAND_J:I, DWELT_J:I, FSPLIT_L:IO,
C			RACMOS_D:I, FRCMOS_D:I, FWGT_E:I,
C			OBUF_E(0:1,0:STHTEL-1,0:*):I,TMPBUF_I(3,0:*):I)
C				Read WSRT data from TMP file to FCAOUT.
C				FCAT is the TMP file.
C				ONS gives the integration data, OHAB the
C				start HA of the output.
C				ONS:	1 # of 10 sec per output point
C					2 # of subsets
C					3 time between radials in 10 sec units
C					4 # of points per subset
C					5 total output points per ifr
C					6 length of TMP file
C				IFRT:	1 West telescope
C					2 East telescope
C					3 TMP line # XX
C					4            XY
C					5            YX
C					6            YY
C					7 baseline in m
C				NIFR is the number of interferometers found,
C				IFRT describes the interferometers.
C				POLS indicates (if >0) polarisation to do.
C				BINT is the basic time increment in s.
C				STHM is a template set header.
C				MJDHA0 is the MJD for HA=0
C				SPLIT .true. if normal (GM or NM)
C				CJOB current job
C				MSNP number of mosaic fields in pattern
C				OHP gives pointer to proper OH blocks
C				BAND the current band
C				DWELT the current dwell time
C				FSPLIT if first channel of OM type
C				RACMOS RA of mosaic centre
C				FRCMOS freq. of mosaic centre
C				FWGT factor to limit weight < 256
C				OBUF has AOTH corrections, 
C				TMPBUF is an input buffer
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'NSC_DEF'
	INCLUDE 'GFH_O_DEF'			!GENERAL FILE HEADER
	INCLUDE 'OHW_O_DEF'			!OH BLOCK
	INCLUDE 'SCH_O_DEF'			!SCAN HEADER
	INCLUDE 'STH_O_DEF'			!SET HEADER
	INCLUDE 'SGH_O_DEF'			!SUB-GROUP HEADER
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER FCAT				!TMP FILE DESCRIPTOR
	INTEGER ONS(6)				!INTEGRATION DATA
	REAL OHAB				!START HA
	INTEGER NIFR				!# OF IFRS FOUND
	INTEGER IFRT(9,0:*)			!IFR DESCRIPTION
	INTEGER POLS(0:3)			!POLARISATION TABLE
	INTEGER BINT				!BASIC TIME INCREMENT
	BYTE STHM(0:*)				!TEMPLATE SET HEADER
	DOUBLE PRECISION MJDHA0			!MJD AT HA0
	LOGICAL SPLIT				!INDICATE GM OR NM
	INTEGER CJOB				!CURRENT JOB
	INTEGER*2 MSNP				!# OF PATTERN POSITIONS
	INTEGER OHP(-1:MXNMOS-1)		!OH BLOCK POINTERS
	INTEGER BAND				!CURRENT BAND NUMBER
	INTEGER DWELT				!DWELL TIME
	LOGICAL FSPLIT				!FIRST CHANNEL IF OM TYPE
	DOUBLE PRECISION RACMOS			!RA CENTRE MOSAIC
	DOUBLE PRECISION FRCMOS			!FREQ. CENTRE MOSAIC
	REAL FWGT				!FACTOR TO LIMIT WGTS TO < 256
	REAL*4 OBUF(0:1,0:STHTEL-1,0:MXDATN-1)	!OUTPUT BUFFER FOR AOTH
	INTEGER*2 TMPBUF(0:2,0:MXDATX-1)	!SORT BUFFER
C
C  Function references:
C
	REAL WNGENF				!NORMALISE ANGLE
	LOGICAL WNFRD				!READ DATA
	LOGICAL WNFWR				!WRITE DATA
	INTEGER WNFEOF				!CURRENT EOF POINTER
	LOGICAL WNDLNK				!LINK A SET
	LOGICAL WNDLNG,WNDLNF			!LINK A SUB-GROUP
C
C  Data declarations:
C
	INTEGER TMPF,TMPL			!1ST AND LAST POINT/LINE IN TMP
	INTEGER TMPS				!# OF POINTS/LINE IN TMP BUF
	INTEGER*2 ODBUF(0:2,0:4*MXNIFR-1)	!OUTPUT DATA BUF
	INTEGER IFRTS(9,0:MXNIFR-1)		!SORTED IFR DATA
	BYTE IFRTP(0:MXNIFR-1)			!POL. IFR PRESENCE
	REAL MX					!FOR MAX. CALCULATION
	INTEGER IFRP				!POINTER TO IFR TABLE
	INTEGER*2 IFRS(0:MXNIFR-1)		!COMPRESSED IFR TABLE
	INTEGER CFLD				!CURRENT MOSAIC FIELD
	BYTE DOFLD(MXNMOS)			!FIELDS SELECTED
	BYTE STH(0:STHHDL-1)			!SET HEADER
	  INTEGER*2 STHI(0:STHHDL/2-1)
	  INTEGER STHJ(0:STHHDL/4-1)
	  REAL STHE(0:STHHDL/4-1)
	  REAL*8 STHD(0:STHHDL/8-1)
	  EQUIVALENCE (STH,STHI,STHJ,STHE,STHD)
	BYTE SCH(0:SCHHDL-1)			!SCAN HEADER
	  INTEGER*2 SCHI(0:SCHHDL/2-1)
	  INTEGER SCHJ(0:SCHHDL/4-1)
	  REAL SCHE(0:SCHHDL/4-1)
	  REAL*8 SCHD(0:SCHHDL/8-1)
	  EQUIVALENCE (SCH,SCHI,SCHJ,SCHE,SCHD)
	BYTE OHW(0:OHWHDL-1)			!OH BLOCK
	  INTEGER*2 OHWI(0:OHWHDL/2-1)
	  INTEGER OHWJ(0:OHWHDL/4-1)
	  REAL OHWE(0:OHWHDL/4-1)
	  REAL*8 OHWD(0:OHWHDL/8-1)
	  EQUIVALENCE (OHW,OHWI,OHWJ,OHWE,OHWD)
	INTEGER NL1
C-
C
C INIT
C
	NSCLWD=.TRUE.					!ASSUME OK
	DO I=0,NIFR-1					!COPY IFRT
	  DO I1=1,9
	    IFRTS(I1,I)=IFRT(I1,I)
	  END DO
	END DO
	DO I=0,NIFR-2					!SORT IFR ON BASELINE
	  DO I1=0,NIFR-2-I
	    IF (IFRTS(7,I1).GT.IFRTS(7,I1+1)) THEN	!MOVE ENTRY
	      DO I2=1,9
	        J=IFRTS(I2,I1)
	        IFRTS(I2,I1)=IFRTS(I2,I1+1)
	        IFRTS(I2,I1+1)=J
	      END DO
	    END IF
	  END DO
	END DO
	DO I=0,NIFR-1					!MAKE IFR OUTPUT TABLE
	  IFRS(I)=IFRTS(1,I)+256*IFRTS(2,I)
	END DO
	IFRP=WNFEOF(FCAOUT)				!POINTER TO IFR TABLE
	IF (.NOT.WNFWR(FCAOUT,NIFR*LB_I,IFRS(0),IFRP)) GOTO 10 !WRITE IT
	DO I=0,3					!MAKE POL. PRESENCE
	  DO I1=0,NIFR-1
	    IF (POLS(I).GT.0 .AND. IFRTS(3+I,I1).NE.-1) THEN !PRESENT
	      IFRTP(I1)=1
	    ELSE					!NOT PRESENT
	      IFRTP(I1)=0
	    END IF
	  END DO
	  IF (.NOT.WNFWR(FCAOUT,NIFR,IFRTP(0),IFRP+NIFR*(I+LB_I)))
	1		GOTO 10				!WRITE TABLE
	END DO
C
C SPLIT DATA
C
	IF (.NOT.SPLIT) THEN				!OM
	 DO CFLD=1,MSNP					!TRY ALL FIELDS
	  DOFLD(CFLD)=.FALSE.				!ASSUME NOT TO DO
	  IF (NPTC(CJOB).LT.0) THEN			!DO ALL FIELDS
	  ELSE
	    DO I=1,NPTC(CJOB)
	      IF(IPTC(I,CJOB).EQ.CFLD) GOTO 21		!DO THIS FIELD
	    END DO
	    GOTO 20					!TRY NEXT FIELD
	  END IF
 21	  CONTINUE
	  STHJ(STH_OHP_J)=OHP(CFLD-1)			!READ PROPER OH
	  IF (.NOT.WNFRD(FCAOUT,OHP(-1),OHW,OHP(CFLD-1))) GOTO 10
C
C SPLIT OH FINAL DATA
C
	  IF (FSPLIT) THEN				!FIRST CHANNEL
	    I3=OHWI(OHW_ETIM_I)-OHWI(OHW_STIM_I)	!LENGTH OBS.
	    IF (I3.LT.0) I3=I3+8640			!24 HRS
	    I4=OHWI(OHW_MSNP_I)*DWELT/BINT		!DRADT
	    I5=(CFLD-1)*DWELT/BINT			!START OFFSET THIS FIELD
	    IF (I5.GT.I3) GOTO 20			!FIELD NOT PRESENT
	    OHWI(OHW_STIM_I)=OHWI(OHW_STIM_I)+I5	!START TIME
	    IF (OHWI(OHW_STIM_I).GE.8640) THEN		!NEXT DAY
	      OHWI(OHW_STIM_I)=OHWI(OHW_STIM_I)-8640	!NORM.
	      OHWI(OHW_SDAY_I)=OHWI(OHW_SDAY_I)+1	!NEXT DAY
	    END IF
	    DO WHILE (I5.LE.I3)				!FIND END TIME
	      IF (I5+DWELT/BINT.LE.I3) THEN		!FULL DWELL
	        OHWI(OHW_ETIM_I)=OHWI(OHW_STIM_I)+I5+DWELT/BINT !MAYBE END
	      ELSE
	        OHWI(OHW_ETIM_I)=OHWI(OHW_STIM_I)+I3	!END
	      END IF
	      I5=I5+I4					!NEXT OF THIS FIELD
	    END DO
	    IF (OHWI(OHW_ETIM_I).GE.8640)		!NORM
	1		OHWI(OHW_ETIM_I)=OHWI(OHW_ETIM_I)-8640
	    IF (.NOT.WNFWR(FCAOUT,OHP(-1),OHW,OHP(CFLD-1))) GOTO 10 !REWRITE
	  END IF
	  DOFLD(CFLD)=.TRUE.				!DO THIS FIELD
 20	  CONTINUE
	 END DO						!NEXT FIELD
	 FSPLIT=.FALSE.					!INDICATE CHANNEL DONE
	END IF
C
C Fill final fields in Sector header, link subgroup
C
	NL1=ONS(6)/ONS(5)/6				!# OF LINES IN TMP
	TMPL=0						!LAST+1 POINT IN TMP
	DO I=0,ONS(2)-1					!ALL SUBSETS
	  IF (.NOT.SPLIT) THEN				!OM TYPE
	    CFLD=MOD(I,MSNP)+1				!CURRENT FIELD
	    IF (.NOT.DOFLD(CFLD)) GOTO 30		!SKIP SUBSET
	    IF (.NOT.WNFRD(FCAOUT,OHP(-1),OHW,OHP(CFLD-1))) GOTO 10 !GET OH
	    I2=MOD((CFLD-1)+OHWI(OHW_MPOSN_I),OHWI(OHW_MSNP_I)) !TABLE #
	    IF (.NOT.WNDLNF(SGPH(1)+SGH_LINKG_1,I2,SGH_GROUPN_1,FCAOUT,
	1		SGPH(2),SGNR(2))) GOTO 31	!FIND SUB-GROUP FIELD
	  END IF
	  CALL WNGMV(STHHDL,STHM(0),STH(0))		!MAKE SET HEADER
	  STHI(STH_CHAN_I)=BAND				!SET BAND
	  IF (.NOT.SPLIT) THEN				!OM TYPE: MAKE STH
	    STHJ(STH_OHP_J)=OHP(CFLD-1)			!PROPER OH PTR
	    STHI(STH_PTS_I)=MOD(OHWI(OHW_MPOSN_I)+CFLD-1,
	1		OHWI(OHW_MSNP_I))		!MOZAIC FIELD NUMBER
	    CALL WNGMV(STH_FIELD_N,OHW(OHW_FIELD_1),STH(STH_FIELD_1)) !NAME
	    STHD(STH_RA_D)=OHWD(OHW_RA0_D)		!RA, DEC APP.
	    STHD(STH_DEC_D)=OHWD(OHW_DEC0_D)
	    STHD(STH_RAE_D)=OHWD(OHW_RA1_D)		!RA, DEC EPOCH
	    STHD(STH_DECE_D)=OHWD(OHW_DEC1_D)
	  END IF
	  IF (.NOT.WNDLNF(SGPH(2)+SGH_LINKG_1,BAND,SGH_GROUPN_1,FCAOUT,
	1		SGPH(3),SGNR(3))) GOTO 31	!LINK SUB-GROUP CHANNEL
	  IF (I/MSNP.EQ.0)				!SHOW BAND
	1	CALL WNCTXT(F_TP,'!7C\Ch. !3$UJ: !UJ\.!UJ\.!UJ\.!UJ'//
	1		'!32C\F= !10$D15.5 B= !10$E15.5',
	1		BAND,SGNR(0),SGNR(1),SGNR(2),SGNR(3),
	1		STHD(STH_FRQE_D),STHE(STH_BAND_E))
	  STHE(STH_HAI_E)=ONS(1)*BINT*CVUTST/3600./24.	!INCR. HA
	  STHE(STH_HAV_E)=STHE(STH_HAI_E)		!AVER. HA
	  IF (SPLIT) THEN				!NM OR GM TYPE
	    STHE(STH_HAB_E)=OHAB+I*ONS(3)*BINT*CVUTST/3600./24. !FIRST HA
	    R0=WNGENF(STHE(STH_HAB_E))			!START HA
	    STHD(STH_MJD_D)=MJDHA0+R0/STHD(STH_UTST_D)	!START MJD
	  ELSE						!OM
	    STHE(STH_HAB_E)=OHAB+RACMOS-STHD(STH_RA_D)+
	1		I*(ONS(3)/OHWI(OHW_MSNP_I))*BINT*CVUTST/3600./24.
	    STHE(STH_HAB_E)=WNGENF(STHE(STH_HAB_E))	!NORMALISE
	    STHD(STH_FRQ_D)=STHD(STH_FRQ_D)-FRCMOS+OHWD(OHW_FREQ_D) !FREQ.
	    STHD(STH_FRQE_D)=STHD(STH_FRQE_D)-FRCMOS+OHWD(OHW_FREQ_D) !FREQ.
	    R0=STHD(STH_RA_D)-RACMOS+STHE(STH_HAB_E)	!START TIME
	    R0=WNGENF(R0)				!START TIME
	    STHD(STH_MJD_D)=MJDHA0+R0/STHD(STH_UTST_D)	!START MJD
	    STHD(STH_FRQV_D)=STHD(STH_FRQ_D)		!REAL FREQUENCY LINE
	    IF (STHJ(STH_VELC_J).LE.0) THEN		!CONTINUUM
	      STHE(STH_VEL_E)=0				!VELOCITY
	    ELSE					!LINE
	      IF (STHD(STH_FRQV_D).LE.0) STHD(STH_FRQV_D)=STHD(STH_FRQ_D)
	      IF (STHD(STH_FRQC_D).LE.0) STHD(STH_FRQC_D)=STHD(STH_FRQ_D)
	      IF (STHJ(STH_VELC_J).EQ.1 .OR.
	1		STHJ(STH_VELC_J).EQ.2) THEN	!RADIO
	        STHE(STH_VEL_E)=STHE(STH_VELR_E)*STHD(STH_FRQV_D)/
	1		STHD(STH_FRQC_D)+
	1		CL*(STHD(STH_FRQC_D)-STHD(STH_FRQV_D))/
	1		STHD(STH_FRQC_D)
	      ELSE					!OPTICAL
	        STHE(STH_VEL_E)=STHE(STH_VELR_E)*STHD(STH_FRQC_D)/
	1		STHD(STH_FRQV_D)+
	1		CL*(STHD(STH_FRQC_D)-STHD(STH_FRQV_D))/
	1		STHD(STH_FRQV_D)
	      END IF
	    END IF
	  END IF
	  STHJ(STH_SCN_J)=ONS(4)			!# OF SCANS/SUBSET
	  STHJ(STH_NIFR_J)=NIFR				!# OF IFRS
	  STHJ(STH_IFRP_J)=IFRP				!POINTER TO IFR TABLE
	  STHJ(STH_SCNL_J)=SCHHDL+6*NIFR*STHI(STH_PLN_I) !LENGTH SCAN
	  CALL NSCCLP(FCAOUT,STH(0),STHE(STH_PHI_E))	!GET PREC. ROT. ANGLE
	  STHE(STH_PHI_E)=STHE(STH_PHI_E)/PI2		!MAKE CIRCLES
	  J=WNFEOF(FCAOUT)				!POINTER TO SET HEADER
	  IF (.NOT.WNFWR(FCAOUT,STHHDL,STH(0),J))
	1			GOTO 10			!WRITE SET HEADER
	  IF (.NOT.WNDLNK(GFH_LINK_1,J,
	1		STH_SETN_1,FCAOUT)) GOTO 10	!LINK THE SET
	  IF (.NOT.WNDLNG(SGPH(3)+SGH_LINKG_1,J,
	1		SGH_GROUPN_1,FCAOUT,SGPH(4),
	1		SGNR(4))) THEN			!LINK SUB-GROUP
 31	    CONTINUE
	    CALL WNCTXT(F_TP,'!/Cannot link sub-group')
	    GOTO 900					!STOP
	  END IF
	  IF (.NOT.WNFRD(FCAOUT,STHHDL,STH(0),J))
	1			GOTO 10			!REREAD SET HEADER
	  STHJ(STH_SCNP_J)=WNFEOF(FCAOUT)		!POINTER TO DATA
	  IF (.NOT.WNFWR(FCAOUT,STHHDL,STH(0),J))
	1			GOTO 10			!REWRITE SET HEADER
C
C Read scans from temp. file and sort them
C
C The temp. file contains a line for each interferometer.
C
C Each line has a series of output integrations: 
C   J  loops over NS(2) subsets of NS(4) integrations
C   I5 loops over NS(4) integrations within the subset.
C
C The total number of integrations is NS(5)=NS(2)*NS(4)
C
C Buffer TMPBUF holds for each interferometer (I2) a number of TMPS
C integrations, which is at most the full file (NS(6) bytes) or the
C remaining data not yet read (NS(4)*NS(2)-TMPF integrations). 
C The number of the first integration is TMPF, the number of the next
C integration to read is TMPL.
C
C
	  J5=0						!SCAN COUNT IN SUBSET
	  J=I*ONS(4)					!OFFSET SUBSET IN LINE
	  DO I5=0,ONS(4)-1				!OUTPUT SCANS
C
C  Refresh buffer if needed
C
	    IF (J+I5.GE.TMPL) THEN			!SCAN NOT IN TMP BUF
	      TMPF=J+I5					!FIRST POINT IN TMP BUF
	      TMPS=MIN(MIN(MXDATX,ONS(6)/6)/NL1,
	1		ONS(2)*ONS(4)-TMPF)		!POINTS PER LINE
	      TMPL=TMPS+TMPF				!FIRST POINT NOT IN TMP
	      DO I2=0,NL1-1				!READ ALL LINES
	        IF (.NOT.WNFRD(FCAT,6*TMPS,TMPBUF(0,I2*TMPS),
	1		6*(TMPF+I2*ONS(5)) )) THEN
	          CALL WNCTXT(F_TP,'!/Error reading TMP file')
		  GOTO 900				!STOP
	        END IF
	      END DO
	    END IF
C
C  Fill in interferometers for this output scan
C
	    J3=0					!OUTPUT POINTER
	    MX=-1E30					!FIND MAX.
	    CALL WNGMVZ(SCHHDL,SCH(0))			!EMPTY SCAN HEADER
	    DO I2=0,NIFR-1				!OUTPUT A SCAN
	      DO I3=0,3					!ALL POLARISATIONS
	        IF (POLS(I3).GT.0) THEN			!THIS POLARIZATION
	          IF (IFRTS(3+I3,I2).NE.-1) THEN	!DATA SEEN
	            J4=IFRTS(3+I3,I2)*TMPS+J+I5-TMPF	!INPUT DATA POINTER
	            DO I4=0,2
	              ODBUF(I4,J3)=TMPBUF(I4,J4)
	            END DO
	            IF (ODBUF(0,J3).NE.0) THEN		!DATA PRESENT
		      ODBUF(0,J3)=NINT(ODBUF(0,J3)*FWGT) !MAKE < 256
		      IF (ODBUF(0,J3).LE.0) ODBUF(0,J3)=1 !VERY SMALL WEIGHT
	              MX=MAX(MX,ABS(FLOAT(ODBUF(1,J3))))
	              MX=MAX(MX,ABS(FLOAT(ODBUF(2,J3))))
	            END IF
	          ELSE					!NO DATA
	            DO I4=0,2
	              ODBUF(I4,J3)=0
	            END DO
	          END IF
	          J3=J3+1				!CNT OUTPUT POINT
	        END IF
	      END DO
	    END DO
	    SCHE(SCH_MAX_E)=MX				!SAVE MAX.
	    SCHE(SCH_HA_E)=STHE(STH_HAB_E)+J5*STHE(STH_HAI_E) !SET HA
C
C  Store AOTH corrections for this scan
C
	    DO I2=0,STHTEL-1
	      DO I4=0,1
	        SCHE(SCH_AOTHC_E+2*(I4+2*I2))=OBUF(I4,I2,J+I5)
	      END DO
	    END DO
C
C Write to disk
C
	    J4=WNFEOF(FCAOUT)				!DISK OUTPUT PTR
	    IF (.NOT.WNFWR(FCAOUT,SCHHDL,SCH(0),J4)) GOTO 10 !OUTPUT SCAN HD.
	    IF (.NOT.WNFWR(FCAOUT,6*J3,ODBUF(0,0),J4+SCHHDL)) THEN !WRITE SCAN
 10	      CONTINUE
	      CALL WNCTXT(F_TP,'!/Error writing output SCN file')
	      GOTO 900					!STOP
	    END IF
	    J5=J5+1					!COUNT SCAN
	  END DO					!END SCANS
 30	  CONTINUE
	END DO						!END SUBSET
C
C READY
C
	RETURN						!READY
C
C ERROR FINISH
C
 900	CONTINUE
	NSCLWD=.FALSE.
C
	RETURN
C
C
	END

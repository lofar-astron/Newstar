C+ WNMLGA.FOR
C  WNB 950330
C
C  Revisions:
C
	LOGICAL FUNCTION WNMLGA(MAR,TYPE,NUN,M,NCON,PREC)
C
C  Get least squares area
C
C  Result:
C
C	WNMLGA_L = WNMLGA( MAR_J:O, TYPE_J:I, NUN_J:I, M_J:I, NCON_J:I,
C				PREC_E:I)
C				Get an area (MAR) for least squares
C				solution with NUN unknowns.
C				Type is complex (LSQ_T_COMPLEX) or
C       			real (default or LSQ_T_REAL). Type can have
C       			LSQ_T_MULTIPLE (for multiple M known (measured)
C				values; LSQ_T_CONSTRAINT to indicate
C				NCON constraint equations; and/or
C				LSQ_T_PREC to indicate a precision PREC for
C				checking equation dependencies (default 1E-6).
C				MAR, and zero the equations.
C	WNMLFA_L = WNMLFA( MAR_J:I) Free least squares area MAR		
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'LSQ_O_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MAR				!AREA POINTER
	INTEGER TYPE				!AREA TYPE
	INTEGER NUN				!# OF UNKNOWNS
	INTEGER M				!# OF KNOWNS
	INTEGER NCON				!# OF CONSTRAINT EQUATIONS
	REAL PREC				!TEST PRECISION
C
C  Entry points:
C
	LOGICAL WNMLFA
C
C  Function references:
C
	LOGICAL WNGGVA			!GET VIRTUAL MEMORY ALIGNED
	LOGICAL WNGFVA			!FREE VIRTUAL MEMORY
C
C  Data declarations:
C
C-
C
C WNMLGA
C
	WNMLGA=.TRUE.				!ASSUME OK
	IF (IAND(TYPE,LSQ_T_COMPLEX).NE.0) THEN	!COMPLEX
	  J1=2*NUN
	ELSE
	  J1=NUN
	END IF
	IF (IAND(TYPE,LSQ_T_MULTIPLE).NE.0) THEN !MULTIPLE KNOWNS
	  J2=M
	ELSE
	  J2=1
	END IF
	IF (IAND(TYPE,LSQ_T_CONSTRAINT).NE.0) THEN !CONSTRAINTS WILL BE
						   !GIVEN
	  J3=NCON+J1
	ELSE
	  J3=J1
	END IF
	IF (IAND(TYPE,LSQ_T_PREC).NE.0) THEN	!PRECISION GIVEN
	  R0=PREC
	ELSE
	  R0=DPREC
	END IF
	J0=(LSQ__L+				!HEADER LENGTH: HEADER
	1   J3*LB_J+				!PIVOT TABLE
	1   ((J3*(J3+1))/2)*LB_D+		!NORMAL EQUATIONS
	1   J2*J3*LB_D+				!KNOWNS AREA
	1   LERR__N*J2*LB_D+			!ERROR AREA
	1   J3*LB_D+				!SOLUTION AREA
	1   1*LB_D)				!ALIGNMENT   
	WNMLGA=WNGGVA(J0,MAR)			!GET AREA
	IF (.NOT.WNMLGA) THEN
	  MAR=0
	  RETURN
	END IF
	MAR=(MAR-A_OB)/LB_J			!ARRAY OFFSET
C
C FILL DEFAULTS
C
	A_J(MAR+LSQ_SIZE_J)=J0			!SIZE AREA
	A_J(MAR+LSQ_BITS_J)=TYPE		!REAL/COMPLEX
	A_J(MAR+LSQ_DBL_J)=(MAR*LB_J)/LB_D	!A_D INDEX
	A_J(MAR+LSQ_NUN_J)=J1			!# UNKNOWNS
	A_J(MAR+LSQ_M_J)=J2			!# KNOWNS
	A_J(MAR+LSQ_N_J)=J3			!# UNKNOWNS + # CONSTRAINTS
	A_J(MAR+LSQ_NAR_J)=0			!SAVE AREA NON-LINEAR
	A_J(MAR+LSQ_PIV_J)=MAR+LSQ__L/LB_J 	!PIVOT AREA
	A_J(MAR+LSQ_NORM_J)=((A_J(MAR+LSQ_PIV_J)+J3)*LB_J+LB_D-1)/LB_D !NORMAL
							       !EQUATIONS 
	A_J(MAR+LSQ_KNOWN_J)=A_J(MAR+LSQ_NORM_J)+(J3*(J3+1))/2 !KNOWN AREA
	A_J(MAR+LSQ_ERROR_J)=A_J(MAR+LSQ_KNOWN_J)+J2*J3 !ERROR PART
	A_J(MAR+LSQ_SOL_J)=A_J(MAR+LSQ_ERROR_J)+LERR__N*J2 !SOLUTION AID AREA
C
C CLEAR AREA
C
	IF (IAND(TYPE,LSQ_T_NOINIT).EQ.0)
	1	CALL WNMLIA(MAR,LSQ_I_ALL+LSQ_I_PREC,R0) !INIT ALL
C
	RETURN
C
C WNMLFA
C
	ENTRY WNMLFA(MAR)
C
	IF (MAR.NE.0) THEN
	  IF (A_J(MAR+LSQ_NAR_J).NE.0) THEN	!SAVE AREA NON-LINEAR
	    J0=A_J(MAR+LSQ_SIZE_J) 		!AREA SIZE
	    J1=A_J(MAR+LSQ_NAR_J)*LB_J+A_OB	!AREA ADDRESS
	    WNMLFA=WNGFVA(J0,J1)
	    A_J(MAR+LSQ_NAR_J)=0		!SET FREE
	  END IF	    
	  J0=A_J(MAR+LSQ_SIZE_J) 		!AREA SIZE
	  MAR=MAR*LB_J+A_OB			!AREA ADDRESS
	  WNMLFA=WNGFVA(J0,MAR)			!FREE AREA
	  MAR=0					!READY
	ELSE
	  WNMLFA=.TRUE.
	END IF
C
	RETURN
C
C
	END

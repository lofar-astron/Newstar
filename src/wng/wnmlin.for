C+ WNMLIN.FOR
C  WNB 950330
C
C  Revisions:
C       WNB 950611	Return error  (LME), not variance; typo
C
	LOGICAL FUNCTION WNMLIN(MAR,MU)
C
C  Invert normal equations, get uncertainties in unknowns
C
C  Result:
C
C	WNMLIN_L = WNMLIN( MAR_J:O)
C				Invert normal equations. MAR gives
C				the matrix.
C	WNMLME_L = WNMLME( MAR_J:O, MU_E(0:N-1,0:M-1):O)
C				Invert normal equations. MAR gives
C				the matrix.
C				MU will return the uncertainties in the
C				unknowns.
C	WNMLCV_L = WNMLCV( MAR_J:O, MU_E(0:N-1,0:N-1):O)
C				Invert normal equations. MAR gives
C				the matrix.
C				MU will return the inverted matrix (covariant
C				matrix).
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'LSQ_O_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MAR				!AREA POINTER
	REAL MU(0:*)				!UNKNOWN ERROR/COVARIANT MATRIX
C
C  Entry points:
C
	LOGICAL WNMLCV,WNMLME
C
C  Function references:
C
	INTEGER WNMLGR				!GET ROW POINTER ARRAY
	INTEGER WNMLGK				!GET KNOWN COLUMN POINTER
	LOGICAL WNGGVA				!GET MEMORY
C
C  Data declarations:
C
	INTEGER NUN				!# OF UNKNOWNS
	INTEGER M				!# OF KNOWNS
	INTEGER N				!# TO SOLVE
	INTEGER NR				!RANK
	INTEGER PIVV				!PIVOT VECTOR POINTER
	INTEGER SOLV				!SOLUTION VECTOR POINTER
	LOGICAL CV,OUT				!INDICATE COVARIANCE
	INTEGER ALEN				!LOCAL AREA LENGTH
	INTEGER LAR				!LOCAL AREA POINTER
C-
C WNMLIN
C
	OUT=.FALSE.
	GOTO 10
C
C WNMLCV
C
	ENTRY WNMLCV(MAR,MU)
C
	CV=.TRUE.
	OUT=.TRUE.
	GOTO 10
C
C WNMLME
C
	ENTRY WNMLME(MAR,MU)
C
	CV=.FALSE.
	OUT=.TRUE.
	GOTO 10
C
C INTRO
C
 10	CONTINUE
	WNMLIN=.TRUE.				!ASSUME OK
	N=A_J(MAR+LSQ_N_J)			!# TO SOLVE
	M=A_J(MAR+LSQ_M_J)			!# KNOWNS
	NUN=A_J(MAR+LSQ_NUN_J)			!# UNKNOWNS
	NR=A_J(MAR+LSQ_R_J)			!RANK
	PIVV=A_J(MAR+LSQ_PIV_J)			!PIVOT TABLE
	SOLV=A_J(MAR+LSQ_SOL_J)			!SOLUTION AREA
C
C INVERT
C
	IF (IAND(A_J(MAR+LSQ_BITS_J),LSQ_U_INVERTED).EQ.0) THEN
	  ALEN=N*N*LB_D				!GET WORKSPACE
	  IF (.NOT.WNGGVA(ALEN,LAR)) THEN
	    WNMLIN=.FALSE.
	    GOTO 810
	  END IF
	  LAR=(LAR-A_OB)/LB_D			!A_D POINTER OUT
	  IF (N.NE.NUN) THEN			!LU NECESSARY
C
C LU DECOMPOSITION
C
C GET MATRIX
C
	    DO I=0,N-1				!FILL MATRIX
	      J0=WNMLGR(MAR,I)			!INPUT ROW
	      J1=LAR+N*I			!OUTPUT ROW
	      A_D(J1+I)=A_D(J0+I) 		!DIAGONAL
	      DO I1=I+1,N-1			!REST
		A_D(J1+I1)=A_D(J0+I1)
		A_D(LAR+I+N*I1)=A_D(J0+I1)
	      END DO
	    END DO
C
C GET SCALING
C
	    DO I=0,N-1				!COLUMN LOOP
	      D0=0
	      DO I1=0,N-1
		J1=LAR+N*I1
		IF (ABS(A_D(J1+I)).GT.D0) D0=ABS(A_D(J1+I))
	      END DO
	      IF (D0.EQ.0) THEN			!CANNOT SOLVE
		WNMLIN=.FALSE.
		GOTO 800
	      END IF
	      A_D(SOLV+I)=1./D0			!SAVE SCALING
	    END DO
C
C DO CROUT
C
	    DO I1=0,N-1				!ALL COLUMNS
	      J0=LAR+N*I1
	      DO I=0,I1-1
		DO I2=0,I-1
		  J1=LAR+N*I2
		  A_D(J0+I)=A_D(J0+I)-A_D(J1+I)*A_D(J0+I2)
		END DO
	      END DO
	      D0=0
	      DO I=I1,N-1			!CHECK PIVOT
		DO I2=0,I1-1
		  J1=LAR+N*I2
		  A_D(J0+I)=A_D(J0+I)-A_D(J1+I)*A_D(J0+I2)
		END DO
		IF (A_D(SOLV+I)*ABS(A_D(J0+I)).GE.D0) THEN !FIND BEST PIVOT
		  I4=I
		  D0=A_D(SOLV+I)*ABS(A_D(J0+I))
		END IF
	      END DO
	      IF (I1.NE.I4) THEN 		!INTERCHANGE ROWS
		DO I2=0,N-1
		  J1=LAR+N*I2
		  D0=A_D(J1+I4)
		  A_D(J1+I4)=A_D(J1+I1)
		  A_D(J1+I1)=D0
		END DO
		A_D(SOLV+I4)=A_D(SOLV+I1) 	!CHANGE SCALE FACTOR
	      END IF
	      A_J(PIVV+I1)=I4			!SAVE PIVOT
	      IF (I1.NE.N-1) THEN 		!CORRECT FOR PIVOT
		DO I=I1+1,N-1
		  A_D(J0+I)=A_D(J0+I)/A_D(J0+I1)
		END DO
	      END IF
	    END DO
C
C DO INVERT
C
	    DO I3=0,N-1				!ALL COLUMNS
	      DO I=0,N-1			!INVERSION TEST
		A_D(SOLV+I)=0
	      END DO
	      A_D(SOLV+I3)=1.
	      DO I=0,N-1			!FORWARD
		D0=A_D(SOLV+A_J(PIVV+I))
		A_D(SOLV+A_J(PIVV+I))=A_D(SOLV+I) !PIVOTS
		A_D(SOLV+I)=D0
		DO I1=0,I-1
		  J0=LAR+N*I1
		  A_D(SOLV+I)=A_D(SOLV+I)-A_D(J0+I)*A_D(SOLV+I1)
		END DO
	      END DO
	      DO I=N-1,0,-1			!BACKWARD
		J0=LAR+N*I
		DO I1=I+1,N-1
		  J1=LAR+N*I1
		  A_D(SOLV+I)=A_D(SOLV+I)-A_D(J1+I)*A_D(SOLV+I1)
		END DO
		A_D(SOLV+I)=A_D(SOLV+I)/A_D(J0+I)
	      END DO
	      J0=WNMLGR(MAR,I3)			!ROW RESULT
	      DO I=I3,N-1			!SAVE INVERTED
		A_D(J0+I)=A_D(SOLV+I)
	      END DO
	    END DO
	    GOTO 800
	  END IF
C
C INVERT CHOLESKY
C
	  DO I=0,NR-1
	    DO I1=0,NR-1			!ALL UNKNOWNS
	      IF (I.EQ.A_J(PIVV+I1)) THEN
		A_D(SOLV+I1)=1
	      ELSE
		A_D(SOLV+I1)=0
	      END IF
	      DO I2=0,I1-1
		I3=WNMLGR(MAR,I2) 		!ROW POINTER
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I1)*A_D(SOLV+I2)/A_D(I3+I2) !STEP 1
	      END DO
	    END DO
	    DO I1=NR-1,0,-1
	      I3=WNMLGR(MAR,I1)			!ROW POINTER
	      DO I2=I1+1,NR-1
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I2)*A_D(SOLV+I2) 	!SOLUTION
	      END DO
	      A_D(SOLV+I1)=A_D(SOLV+I1)/A_D(I3+I1)
	    END DO
C           
C MISSING RANK
C
	    DO I1=NR,NUN-1			!MAKE B2=-G1'*.X1'
	      A_D(SOLV+I1)=0
	      DO I2=0,NR-1
		I3=WNMLGR(MAR,I2) 		!ROW POINTER
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(SOLV+I2)*A_D(I3+I1)
	      END DO
	    END DO
C           
C SOLVE X2
C
	    DO I1=NR,NUN-1			!ALL UNKNOWNS
	      DO I2=NR,I1-1
		I3=WNMLGR(MAR,I2) 		!ROW POINTER
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I1)*A_D(SOLV+I2)/A_D(I3+I2) !STEP 1
	      END DO
	    END DO
	    DO I1=NUN-1,NR,-1
	      I3=WNMLGR(MAR,I1)			!ROW POINTER
	      DO I2=I1+1,NUN-1
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I2)*A_D(SOLV+I2) 	!SOLUTION
	      END DO
	      A_D(SOLV+I1)=A_D(SOLV+I1)/A_D(I3+I1)
	    END DO
C           
C FINAL X1
C
	    IF (NR.LT.N) THEN
	      DO I1=0,NR-1
		I3=WNMLGR(MAR,I1) 		!ROW POINTER
		DO I2=NR,NUN-1
		  A_D(SOLV+I1)=A_D(SOLV+I1)+
	1	      A_D(SOLV+I2)*A_D(I3+I2)
		END DO
	      END DO
	    END IF
C           
C SOLUTION
C
	    DO I1=0,NUN-1			!SAVE SOLUTION
	      A_D(LAR+A_J(PIVV+I1)+I*N)=A_D(SOLV+I1)
	    END DO
	  END DO
C           
C AND AGAIN
C
	  DO I=0,NUN-1
	    DO I1=0,NR-1			!GET CV
	      A_D(SOLV+I1)=A_D(LAR+I+I1*N)
	    END DO
	    DO I1=NR,NUN-1			!MAKE B2=-G1'*.X1'
	      A_D(SOLV+I1)=0
	      DO I2=0,NR-1
		I3=WNMLGR(MAR,I2) 		!ROW POINTER
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(SOLV+I2)*A_D(I3+I1)
	      END DO
	    END DO
C           
C SOLVE X2
C
	    DO I1=NR,NUN-1			!ALL UNKNOWNS
	      DO I2=NR,I1-1
		I3=WNMLGR(MAR,I2) 		!ROW POINTER
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I1)*A_D(SOLV+I2)/A_D(I3+I2) !STEP 1
	      END DO
	    END DO
	    DO I1=NUN-1,NR,-1
	      I3=WNMLGR(MAR,I1)			!ROW POINTER
	      DO I2=I1+1,NUN-1
		A_D(SOLV+I1)=A_D(SOLV+I1)-
	1	    A_D(I3+I2)*A_D(SOLV+I2) 	!SOLUTION
	      END DO
	      A_D(SOLV+I1)=A_D(SOLV+I1)/A_D(I3+I1)
	    END DO
C           
C FINAL X1
C
	    IF (NR.LT.N) THEN
	      DO I1=0,NR-1
		I3=WNMLGR(MAR,I1) 		!ROW POINTER
		DO I2=NR,NUN-1
		  A_D(SOLV+I1)=A_D(SOLV+I1)+
	1	      A_D(SOLV+I2)*A_D(I3+I2)
		END DO
	      END DO
	    END IF
C           
C SOLUTION
C
	    DO I1=0,NUN-1			!SAVE SOLUTION
	      A_D(LAR+I+A_J(PIVV+I1)*N)=A_D(SOLV+I1)
	    END DO
	  END DO
	  DO I=0,NUN-1				!SAVE SOLUTION
	    J0=WNMLGR(MAR,I)			!OUTPUT ROW
	    J1=LAR+I*NUN			!INPUT ROW
	    DO I1=I,NUN-1
	      A_D(J0+I1)=A_D(J1+I1)
	    END DO
	  END DO
	END IF
C
C READY
C
 800	CONTINUE
	IF (IAND(A_J(MAR+LSQ_BITS_J),LSQ_U_INVERTED).EQ.0) THEN
	  LAR=LAR*LB_D+A_OB			!FREE AREA
	  CALL WNGFVA(ALEN,LAR)
	END IF
 810	CONTINUE
	IF (WNMLIN) 
	1    A_J(MAR+LSQ_BITS_J)=IOR(A_J(MAR+LSQ_BITS_J),LSQ_U_INVERTED) !SET
C
C OUTPUT
C
	IF (OUT .AND. WNMLIN) THEN
	  DO I=0,NUN-1				!ALL COLUMNS
	    J0=WNMLGR(MAR,I)
	    IF (CV) THEN
	      DO I1=0,I-1			!RETURN SOLUTION
		J1=WNMLGR(MAR,I1)
		MU(I1+I*NUN)=A_D(J1+I)
	      END DO
	      DO I1=I,NUN-1
		MU(I1+I*NUN)=A_D(J0+I1)
	      END DO
	    ELSE
	      DO I1=0,M-1
		J1=A_J(MAR+LSQ_ERROR_J)+LERR__N*I1 !ERROR AREA
		MU(I+I1*NUN)=SQRT(ABS(A_D(J0+I)))*A_D(J1+LERR_CHI2_D)
	      END DO
	    END IF
	  END DO
	END IF
C
	RETURN
C
C
	END

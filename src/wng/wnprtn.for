C+ WNPRTN.FOR
C  WNB 910624
C
C  Revisions:
C
C  General routines WNP package
C
	SUBROUTINE WNP_NTR1(IN1,OUT1)
C
C  Result:
C
C	CALL WNP_NTR1( IN1_E(*):I, OUT1_E(*):O)
C				Do normalized transform of list IN1 starting
C				with N in list
C	CALL WNP_NTRG( IN1J_J(*):I, OUT1_E(*):O)
C				Do normalized transform of multiple list IN1
C				starting with N in list
C
C	CALL WNP_DNTR1( IN1_E(*):I, OUT1_E(*):O, ID1_J:I)
C				Do device transform of list IN1 starting
C				with N in list
C	CALL WNP_DNTRG( IN1J_J(*):I, OUT1_E(*):O, ID1_J:I)
C				Do device transform of multiple list IN1
C				starting with N in list
C
C	CALL WNP_MAKL( N_J:I, INJ_J(*):I, OUTJ_J(*):O)
C				Make a list of N points in OUTJ
C	CALL WNP_PLCLP( IN1_E(*):I, OUT1_E(*):O, WIN_E(0:3))
C				Clip lines in IN1 list using window WIN
C	CALL WNP_PMCLP( IN1_E(*):I, OUT1_E(*):O, WIN_E(0:3))
C				Clip points in IN1 list using window WIN
C	CALL WNP_SHCLP( IN1_E(*):I, OUT1_E(*):O, WIN_E(0:3))
C				Clip points in IN1 list using window WIN,
C				by setting DEL in OUT1
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WQG_DEF'		!GENERAL AREA
	INCLUDE 'WQD_O_DEF'		!DEVICE AREA
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER N			!NUMBER OF POINTS
	REAL IN1(*)			!INPUT LIST
	  INTEGER IN1J(*)
	  INTEGER INJ(*)
	REAL OUT1(*)			!OUTPUT LIST
	  INTEGER OUTJ(*)
	INTEGER ID1			!ID
	REAL WIN(0:3)			!CLIP WINDOW
C
C  Function references:
C
	INTEGER WNGGJ			!GET J VALUE
C
C  Data declarations:
C
	LOGICAL IDE			!SWITCH
	INTEGER K1
C-
C
C NORMALIZED TRANSFORM NTR1
C
	CALL WNP_NTR0(IN1(1),IN1(2),OUT1(1),OUT1(2)) !DO TRANSFORM
C
	RETURN
C
C DEVICE TRANSFORM DNTR1
C
	ENTRY WNP_DNTR1(IN1,OUT1,ID1)
C
	CALL WNP_DNTR0(IN1(1),IN1(2),OUT1(1),OUT1(2),ID1) !DO TRANSFORM
C
	RETURN
C
C NORMALIZED TRANSFORM NTRG
C
	ENTRY WNP_NTRG(IN1J,OUT1)
C
	J=1					!START MULTIPLE LIST
 50	CONTINUE
	J1=IN1J(J)				!# OF POINTS OF RUN
	CALL WNP_NTR0(IN1J(J),IN1J(J+1),OUT1(J),OUT1(J+1)) !DO TRANSFORM
	J=J+1+2*J1				!POINTER NEXT LIST
	IF (J1.GT.0) GOTO 50
C
	RETURN
C
C DEVICE TRANSFORM DNTRG
C
	ENTRY WNP_DNTRG(IN1J,OUT1,ID1)
C
	J=1					!START MULTIPLE LIST
 60	CONTINUE
	J1=IN1J(J)				!# OF POINTS OF RUN
	CALL WNP_DNTR0(IN1J(J),IN1J(J+1),OUT1(J),OUT1(J+1),ID1) !DO TRANSFORM
	J=J+1+2*J1				!POINTER NEXT LIST
	IF (J1.GT.0) GOTO 60
C
	RETURN
C
C MAKE LIST
C
	ENTRY WNP_MAKL(N,INJ,OUTJ)
C
	OUTJ(1)=N				!SET LENGTH LIST
	DO I=1,N				!MAKE A LIST
	  OUTJ(2*I)=INJ(2*I-1)
	  OUTJ(2*I+1)=INJ(2*I)
	END DO
	OUTJ(2*N+2)=0				!EOL
C
	RETURN
C
C CLIP POLYMARK LIST
C
	ENTRY WNP_PMCLP(IN1,OUT1,WIN)
C
	J0=2					!INPUT PTR
	J=2					!OUTPUT PTR
	J1=0					!OUTPUT CNT
	DO I=1,WNGGJ(IN1(1))			!ALL POINTS
	  R0=IN1(J0)				!X
	  R1=IN1(J0+1)				!Y
	  J0=J0+2				!INPUT PTR
	  IF (R0.LT.WIN(0) .OR. R1.LT.WIN(1) .OR. R0.GT.WIN(2) .OR.
	1			R1.GT.WIN(3)) THEN
	  ELSE
	    OUT1(J)=R0				!SET OUTPUT
	    OUT1(J+1)=R1
	    J=J+2				!OUTPUT PTR
	    J1=J1+1				!COUNT OUTPUT
	  END IF
	END DO
	CALL WNGMV(LB_J,J1,OUT1(1))		!OUTPUT CNT
C
	RETURN
C
C CLIP SHADING LIST
C
	ENTRY WNP_SHCLP(IN1,OUT1,WIN)
C
	J0=2					!INPUT PTR
	J=1					!OUTPUT PTR
	DO I=1,WNGGJ(IN1(1))			!ALL POINTS
	  R0=IN1(J0)				!X
	  R1=IN1(J0+1)				!Y
	  J0=J0+2				!INPUT PTR
	  IF (R0.LT.WIN(0) .OR. R1.LT.WIN(1) .OR. R0.GT.WIN(2) .OR.
	1			R1.GT.WIN(3)) THEN !CLIP
	    OUT1(J)=-1				!SET DELETED
	  END IF
	  J=J+1					!OUTPUT POINTER
	END DO
C
	RETURN
C
C CLIP POLYLINE
C
	ENTRY WNP_PLCLP(IN1,OUT1,WIN)
C
	J0=1					!INPUT PTR
	J1=1					!OUTPUT PTR
C
C ALL PIECES
C
	J2=J1					!PTR FOR OUT CNT
	CALL WNGMV(LB_J,0,OUT1(J2))		!SET EMPTY OUTPUT
	J1=J1+1					!OUT PTR
 30	K1=WNGGJ(IN1(J0))			!IN CNT
	J0=J0+1					!IN PTR
	IF (K1.LE.0) GOTO 20			!ALL READY
 10	IDE=.FALSE.				!START OF PIECE
	K1=K1-1					!IN CNT
	IF (K1.LT.1) THEN
	  J0=J0+2				!SKIP INPUT
	  GOTO 30				!NEXT PIECE
	END IF
	J=0					!OUTPUT CNT
	OUT1(J1)=IN1(J0)			!X1
	OUT1(J1+1)=IN1(J0+1)			!Y1
	J0=J0+2					!IN PTR
	IF (OUT1(J1).LT.WIN(0)) THEN		!X1<XL
	  IF (IN1(J0).LT.WIN(0)) GOTO 10	!FORGET
	  OUT1(J1+1)=OUT1(J1+1)+(WIN(0)-OUT1(J1))*(IN1(J0+1)-OUT1(J1+1))/
	1		(IN1(J0)-OUT1(J1))	!NEW Y1
	  OUT1(J1)=WIN(0)			!NEW X1
	END IF
	IF (OUT1(J1+1).LT.WIN(1)) THEN		!Y1<YL
	  IF (IN1(J0+1).LT.WIN(1)) GOTO 10	!FORGET
	  OUT1(J1)=OUT1(J1)+(WIN(1)-OUT1(J1+1))*(IN1(J0)-OUT1(J1))/
	1		(IN1(J0+1)-OUT1(J1+1))	!NEW X1
	  OUT1(J1+1)=WIN(1)			!NEW Y1
	END IF
	IF (OUT1(J1).GT.WIN(2)) THEN		!X1>XH
	  IF (IN1(J0).GT.WIN(2)) GOTO 10	!FORGET
	  OUT1(J1+1)=OUT1(J1+1)+(WIN(2)-OUT1(J1))*(IN1(J0+1)-OUT1(J1+1))/
	1		(IN1(J0)-OUT1(J1))	!NEW Y1
	  OUT1(J1)=WIN(2)			!NEW X1
	  IF (OUT1(J1+1).LT.WIN(1)) GOTO 10	!FORGET Y1<YL
	END IF
	IF (OUT1(J1+1).GT.WIN(3)) THEN		!Y1>YH
	  IF (IN1(J0+1).GT.WIN(3)) GOTO 10	!FORGET
	  OUT1(J1)=OUT1(J1)+(WIN(3)-OUT1(J1+1))*(IN1(J0)-OUT1(J1))/
	1		(IN1(J0+1)-OUT1(J1+1))	!NEW X1
	  OUT1(J1+1)=WIN(3)			!NEW Y1
	  IF (OUT1(J1).LT.WIN(0)) GOTO 10	!FORGET X1<XL
	  IF (OUT1(J1).GT.WIN(2)) GOTO 10	!FORGET X1>XH
	END IF
C
 40	J1=J1+2					!OUT PTR
	OUT1(J1)=IN1(J0)			!X2
	OUT1(J1+1)=IN1(J0+1)			!Y2
	IF (OUT1(J1).LT.WIN(0)) THEN		!X2<XL
	  IDE=.TRUE.				!FINISH PART
	  OUT1(J1+1)=OUT1(J1+1)+(WIN(0)-OUT1(J1))*(OUT1(J1-1)-OUT1(J1+1))/
	1		(OUT1(J1-2)-OUT1(J1))	!NEW Y2
	  OUT1(J1)=WIN(0)			!NEW X2
	END IF
	IF (OUT1(J1+1).LT.WIN(1)) THEN		!Y2<YL
	  IDE=.TRUE.
	  OUT1(J1)=OUT1(J1)+(WIN(1)-OUT1(J1+1))*(OUT1(J1-2)-OUT1(J1))/
	1		(OUT1(J1-1)-OUT1(J1+1))	!NEW X2
	  OUT1(J1+1)=WIN(1)			!NEW Y2
	END IF
	IF (OUT1(J1).GT.WIN(2)) THEN		!X2>XH
	  IDE=.TRUE.
	  OUT1(J1+1)=OUT1(J1+1)+(WIN(2)-OUT1(J1))*(OUT1(J1-1)-OUT1(J1+1))/
	1		(OUT1(J1-2)-OUT1(J1))	!NEW Y2
	  OUT1(J1)=WIN(2)			!NEW X2
	END IF
	IF (OUT1(J1+1).GT.WIN(3)) THEN		!Y2>YH
	  IDE=.TRUE.
	  OUT1(J1)=OUT1(J1)+(WIN(3)-OUT1(J1+1))*(OUT1(J1-2)-OUT1(J1))/
	1		(OUT1(J1-1)-OUT1(J1+1))	!NEW X2
	  OUT1(J1+1)=WIN(3)			!NEW Y2
	END IF
C
	J=J+1					!OUT CNT
	IF (.NOT.IDE) THEN			!NEW PIECE
		J0=J0+2				!SKIP INPUT
		K1=K1-1				!CNT INPUT
		IF (K1.GT.0) GOTO 40		!MORE INPUT
	END IF
	J=J+1					!CNT OUT
	CALL WNGMV(LB_J,J,OUT1(J2))		!SET OUT CNT
	J1=J1+2					!OUT PTR
	J=0					!OUT CNT
	J2=J1					!WHERE TO PUT
	CALL WNGMV(LB_J,0,OUT1(J2))
	J1=J1+1					!OUT PTR
	IF (K1.GT.0) GOTO 10			!CONTINUE SAME PIECE
	GOTO 30					!NEXT PIECE
 20	CONTINUE
	CALL WNGMV(LB_J,0,OUT1(J2))		!EOL
C
	RETURN
C
C
	END

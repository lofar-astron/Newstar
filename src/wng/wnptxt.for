C+ WNPTXT.FOR
C  WNB 911126
C
C  Revisions:
C	GvD	920501 Use J5 iso. JS
C
C  Plot text routine
C
	LOGICAL FUNCTION WQTEXT(POS,TEXT)
C
C  Result:
C
C	WQTEXT_L = WQTEXT( POS_E(2):I, TEXT_C*:I)
C					Plot TEXT at POS
C	WQTEXT_IX_L = WQTEXT_IX( POS_E(2):I, TEXT_C*:I), IX_J:I, HGT_E:I)
C					Plot TEXT at POS with IndeX and HeiGhT
C	WQTEXT_IY_L = WQTEXT_IY( POS_E(2):I, TEXT_C*:I), IX_J:I, HGT_E:I,
C				UP_E(2):I, EXPD_E:I, PATH_J:I, SPC_E:I)
C					As _IX but specify also UP, PATH and
C					SPaCing and EXPanD
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WQG_DEF'		!GENERAL AREA
	INCLUDE 'WQD_O_DEF'		!DEVICE AREA
	INCLUDE 'WQF_O_DEF'		!FONT OFFSETS
C
C  Parameters:
C
	INTEGER NMXSTR			!MAX. STRING DESCRIPTOR LENGTH
	  PARAMETER (NMXSTR=100)
C
C  Arguments:
C
	REAL POS(2)			!POSITION
	CHARACTER*(*) TEXT		!TEXT
	INTEGER IX			!INDEX
	REAL HGT			!HEIGHT
	REAL UP(2)			!DIRECTION
	REAL EXPD			!EXPANSION
	INTEGER PATH			!LEFT/RIGHT
	REAL SPC			!CHARACTER SPACING
C
C  Entry points:
C
	LOGICAL WQTEXT_IX,WQTEXT_IY
C
C  Function references:
C
	LOGICAL WNP_ALLOC		!ALLOCATE AREAS
	LOGICAL WQSTXI			!SET TEXT INDEX
	LOGICAL WQSTXH			!SET TEXT HEIGHT
	LOGICAL WQSTXU			!SET TEXT DIRECTION
	LOGICAL WQSTXX			!SET TEXT EXPANSION
	LOGICAL WQSTXP			!SET TEXT PATH
	LOGICAL WQSTXS			!SET TEXT SPACING
C
C  Data declarations:
C
	REAL POST(0:9)			!POSITION
	REAL HNTR(0:9)			!AFTER NORM. TRANSFORM
	REAL HTR(0:9)			!AFTER DEVICE TRANSFORM
	REAL TMAT(0:3)			!TRANSFORM MATRIX
	REAL SPOS(0:1)			!START POS.
	REAL RPOS(0:1)			!REAL POS.
	INTEGER OUTL(NMXSTR)		!POLYLINE LIST ONE CHAR.
	INTEGER DPOLIX(0:2)		!DUMMY POLYLINE INDEX
	  REAL DPOLIXF(0:2)
	  EQUIVALENCE (DPOLIX,DPOLIXF)
	REAL CLAR(0:3)			!CLIP VIEWPORT
	INTEGER VP(4)			!DRAW VALUES
	INTEGER K1,K2,K3,K4
	  DATA DPOLIXF/1.,0,0/
C-
	WQTEXT=.TRUE.					!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5						!WRONG STATE
 11	  CONTINUE
	  WQTEXT=.FALSE.
	  RETURN
	END IF
	GOTO 10
C
C WQTEXT_IX
C
	ENTRY WQTEXT_IX(POS,TEXT,IX,HGT)
C
	WQTEXT_IX=.TRUE.				!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5						!WRONG STATE
	  GOTO 11
	END IF
	IF (.NOT.WQSTXI(IX)) GOTO 11			!SET INDEX
	IF (.NOT.WQSTXH(HGT)) GOTO 11			!SET HEIGHT
	GOTO 10
C
C WQTEXT_IY
C
	ENTRY WQTEXT_IY(POS,TEXT,IX,HGT,UP,EXPD,PATH,SPC)
C
	WQTEXT_IY=.TRUE.				!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5						!WRONG STATE
	  GOTO 11
	END IF
	IF (.NOT.WQSTXI(IX)) GOTO 11			!SET INDEX
	IF (.NOT.WQSTXH(HGT)) GOTO 11			!SET HEIGHT
	IF (.NOT.WQSTXU(UP)) GOTO 11			!SET DIRECTION
	IF (.NOT.WQSTXX(EXPD)) GOTO 11			!SET EXPANSION
	IF (.NOT.WQSTXP(PATH)) GOTO 11			!SET PATH
	IF (.NOT.WQSTXS(SPC)) GOTO 11			!SET SPACING
	GOTO 10
C
C DRAW
C
 10	CONTINUE
	POST(0)=0					!SET ORIGINAL POS.
	POST(1)=0
	POST(2)=WQG_CTXHT*WQG_CTXCS(0)			!HEIGHT
	POST(3)=WQG_CTXHT*WQG_CTXCS(1)
	POST(4)=0					!WIDTH
	POST(5)=0
	POST(6)=WQG_CTXHT*WQG_CTXCS(1)*WQG_CTXXP 	!EXPANSION
	POST(7)=WQG_CTXHT*WQG_CTXCS(0)*WQG_CTXXP
	POST(8)=POS(1)					!START POS
	POST(9)=POS(2)
	CALL WNP_NTR0(5,POST,J5,HNTR)			!NORM. TRANSFORM
	J=15*NMXSTR+2					!POLYLINE LENGTH
	IF (.NOT.WNP_ALLOC(J)) THEN			!GET AREAS
	  E_C=100
	  GOTO 11
	END IF
C
C ON ALL ACTIVE DEVICES
C
	J=WQG_QOP					!START LIST
	DO WHILE (J.NE.0)
	  J0=(J-A_OB)/LB_J				!PTR
	  IF (A_J(J0+WQD_ACT_J).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),1).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),4).EQ.0) THEN !OUTPUT DEVICE
	    IF (IAND(1,WQG_CLIP).NE.0) THEN		!OVERALL CLIP
	      CALL WNP_DNTR0(2,WQG_NTR(0,2,WQG_CTR),
	1			J5,CLAR,J)		!VIEW
	    END IF
	    CALL WNP_DNTR0(5,HNTR,J5,HTR,J)		!DEVICE TRANSFORM
	    HTR(2)=HTR(2)-HTR(0)			!START VECTORS AT 0,0
	    HTR(3)=HTR(3)-HTR(1)
	    HTR(6)=HTR(6)-HTR(4)
	    HTR(7)=HTR(7)-HTR(5)
	    J1=WQG_CTXTIX				!TEXT INDEX
	    IF (J1.GT.A_J(J0+WQD_NTXIX_J)) J1=1		!DEFAULT
	    J1=MAX(1,J1)-1				!INDEX
	    J2=NINT(A_E(J0+WQD_TXIX_E+3*J1+0))		!FONT #
	    IF (J2.GT.WQG_NFONT) J2=1			!ASSUME 1
	    J2=MAX(1,J2)
	    J2=WQG_FONT(J2)				!FONT DEFINITION PTR
	    TMAT(1)=HTR(2)/A_E(J2+WQF_BHG_E) 		!MAKE TRANSFO MATRIX
	    TMAT(3)=HTR(3)/A_E(J2+WQF_BHG_E)
	    TMAT(0)=HTR(6)/A_E(J2+WQF_BHG_E)
	    TMAT(2)=-(HTR(7)/A_E(J2+WQF_BHG_E))
	    SPOS(0)=HTR(8)				!START POS.
	    SPOS(1)=HTR(9)
	    DPOLIXF(1)=0.				!SINGLE THICKNESS
	    IF (IAND(A_J(J2+WQF_TIL_J),1).NE.0) 	!THICK CHARACTERS
	1		DPOLIXF(1)=MIN(SQRT(TMAT(0)*TMAT(0)+
	2			TMAT(2)*TMAT(2)),
	3			SQRT(TMAT(1)*TMAT(1)+TMAT(3)*TMAT(3)))
	4						!HEIGHT SCALE
	    DPOLIXF(1)=DPOLIXF(1)/A_E(J0+WQD_NMPLS_E) 	!NOMINAL THICKNESS CORR.
	    SPOS(0)=SPOS(0)-TMAT(0)*A_E(J2+WQF_STR_E+0+2*WQG_CTXPA)-
	1		TMAT(1)*A_E(J2+WQF_STR_E+1+2*WQG_CTXPA) !LOWER LEFT
	    SPOS(1)=SPOS(1)-TMAT(2)*A_E(J2+WQF_STR_E+0+2*WQG_CTXPA)-
	1		TMAT(3)*A_E(J2+WQF_STR_E+1+2*WQG_CTXPA)
	    DO J3=1,LEN(TEXT)				!ALL CHARACTERS
	      K1=IAND(ICHAR(TEXT(J3:J3)),A_J(J2+WQF_BDL_J))-
	1		A_J(J2+WQF_LCH_J)		!#
	      IF (K1.LT.0 .OR. K1.GT.A_J(J2+WQF_HCH_J)) THEN
		K1=A_J(J2+WQF_RCH_J)-A_J(J2+WQF_LCH_J)	!REPLACE CHAR DESCRIPT.
	      END IF
	      K1=A_J(J2+WQF_FTP_J+K1) 			!PTR TO DESCRIPTION
	      K3=1					!POLYLINE # PTR
 20	      CONTINUE
	      K2=0					!POLYLINE CNT
	      K4=K3+1					!OUTPUT PTR
 30	      CONTINUE
	      IF (A_I(K1).EQ.0) THEN
		OUTL(K3)=K2
		K3=K3+2*K2+1
		OUTL(K3)=0				!EOL
		IF (IAND(1,WQG_CLIP).NE.0) THEN
		  CALL WNP_PLCLP(OUTL,A_B(WQG_OUT1-A_OB),CLAR) !CLIP WINDOW
		  CALL WNP_PLCLP(A_B(WQG_OUT1-A_OB),
	1			A_B(WQG_OUT2-A_OB),
	1			A_E(J0+WQD_NTR_E+2*4+0)) !CLIP DC VIEW
		ELSE
		  CALL WNP_PLCLP(OUTL,
	1			A_B(WQG_OUT2-A_OB),
	1			A_E(J0+WQD_NTR_E+2*4+0)) !CLIP DC VIEW
		END IF
		IF (A_J((WQG_OUT2-A_OB)/LB_J).NE.0) THEN
		  VP(1)=0				!INDEX
		  VP(2)=WQG_OUT2			!BUFFER
		  VP(3)=DPOLIX(0)			!LINE TYPE
		  VP(4)=DPOLIX(1)			!THICKNESS
		  CALL WNPDEX(4,J,VP)			!DRAW
		END IF
		R0=A_E(J2+WQF_WID_E)+A_E(J2+WQF_WID_E)*WQG_CTXSP !CHAR. SPACE
		R1=A_E(J2+WQF_HGT_E)+A_E(J2+WQF_HGT_E)*WQG_CTXSP
		IF (WQG_CTXPA.EQ.1) THEN
		  R0=-R0
		  R1=0
		ELSE IF (WQG_CTXPA.EQ.2) THEN
		  R0=0
		ELSE IF (WQG_CTXPA.EQ.3) THEN
		  R1=-R1
		  R0=0
		ELSE
		  R1=0
		END IF
		SPOS(0)=SPOS(0)+R0*TMAT(0)+R1*TMAT(1) 	!NEXT POS
		SPOS(1)=SPOS(1)+R0*TMAT(2)+R1*TMAT(3)
	      ELSE IF (A_I(K1).EQ.-1) THEN
	        OUTL(K3)=K2				!SAVE CNT PIECE
		K3=K3+2*K2+1				!NEXT CNT PTR
		K1=K1+1					!INPUT PTR
		GOTO 20
	      ELSE
	        R0=A_B(2*K1)				!X
		R1=A_B(2*K1+1)				!Y
		K1=K1+1					!CNT
		RPOS(0)=SPOS(0)+R0*TMAT(0)+R1*TMAT(1) 	!TRANS.
		RPOS(1)=SPOS(1)+R0*TMAT(2)+R1*TMAT(3)
		CALL WNGMV(2*LB_E,RPOS,OUTL(K4)) 	!SET
		K4=K4+2
		K2=K2+1					!COUNT POINT
		GOTO 30
	      END IF
	    END DO
	  END IF
	  J=A_J((J-A_OB)/LB_J)				!NEXT DEVICE
	END DO
C
	RETURN
C
C
	END

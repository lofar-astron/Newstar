C+ WNQXWI.FSC
C  HJV 921222
C
C  Revisions:
C	WNB 930324	Change PGVPORT (non-standard) to PGSVP
C	WNB 930325	Make FSC; not implemented for DECwindows yet
C	WNB 930329	Make correct gray scale
C	WNB 930401	Limit PGPLOT calls
C	WNB 930416	Change loop for SUN
C	WNB 930510	Use WNDDIS
C	CMV 931122	Flush in OPEN after changing black/white
C	CMV 940822	Put output state of close in WQG_XSTAT
C
	SUBROUTINE WNQXWI(TYP,ID,VP)
C
C  Do device dependent actions for X-windows
C
C  Result:
C
C	CALL WNQXWI( TYP_J:I, ID_J:I, VP_J(*):I)	X-windows
C				Do action specified by TYP, using the
C				area ID, and pointers/values in VP. TYP can be:
C					0:	open device
C						VP: -
C					1:	close device
C						VP: -
C					2:	(header) message
C						VP: 1: ptr msg; 2: length msg
C					3:	polyline
C						VP: 1: poly index; 2: ptr list
C					4:	polyline
C						VP: 2: ptr list; 3: line type
C						    4: line thickness
C					5:	clear screen
C						VP: -
C					6:	shading
C						VP: 1: type; 2: int. list
C						    3: ptr llhc, urhc total
C						    4: N int.
C						    5: dx,dy , box dx,dy, pos.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WQG_DEF'	!FOR WQG_XSTAT
	INCLUDE 'WQD_O_DEF'	!DEVICE AREA
C
C  Parameters:
C
	INTEGER LOPL		!MAX STRING LENGTH
	  PARAMETER (LOPL=200)
C
C  Arguments:
C
	INTEGER TYP		!TYPE TO DO
	INTEGER ID		!PTR TO AREA
	INTEGER VP(*)		!DATA LIST
C
C  Function references:
C
	REAL WNGGE		!GET E VALUE
	LOGICAL WNGGVM		!GET MEMORY
	INTEGER WNMRNJ		!RANDOM J
	INTEGER WNCALN		!LENGTH STRING
	LOGICAL WNDDIS		!GET DISPLAY
C
C  Data declarations:
C
	REAL RBUF(10)		!FOR GREXEC
	  DATA RBUF/10*0.0/
	REAL RBF1(4)		!FOR DOTTED LINE
	INTEGER NBUF
	INTEGER MNIND,MXIND	!ALLOWED COLOURS
	INTEGER BMP		!BITMAP POINTER
	INTEGER I2MN,I2MX	!POINTS ON LINE
	REAL DX,DY		!LINE LENGTH
	BYTE DEFP1(4)		!DEFAULT POLY INDEX
	  INTEGER DEFPL
	  EQUIVALENCE (DEFP1,DEFPL)
	  DATA DEFP1/1,1,1,0/
	INTEGER PB,PJ,PE	!POINTERS
	INTEGER XB(0:1,0:1)	!SHADING BOX
	REAL PX,PY		!SAVED X,Y
	REAL XYC(0:1)		!X, Y START
	CHARACTER*(LOPL) LOPC	!OPEN TEXT
	  BYTE LOPB(LOPL)
	  EQUIVALENCE (LOPC,LOPB)
	INTEGER PLW		!PLOT LINE TYPE
	  BYTE PLW1(4)
	  EQUIVALENCE (PLW,PLW1)
	INTEGER LPLW		!FOR LOOP (SUN NO BYTE)
	BYTE THL(0:31)
	  DATA THL/1,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
	1		21,22,23,24,25,26,27,28,29,30,31,32/
	BYTE IXTL(4)		!LINE TYPE INFO
	  DATA IXTL/0,1,2,3/
	INTEGER PAT(0:2,1:3)	!PATTERN: LENGTH, DOWN, UP
	  DATA PAT/8,4,4,4,0,4,8,6,2/ !DASH, DOT, LONG DASH
C-
C
C INIT
C
 10	CONTINUE
	PB=ID-A_OB				!BYTE POINTER
	PJ=(ID-A_OB)/LB_J			!J PTR
	PE=(ID-A_OB)/LB_E			!E PTR
C
C DISTRIBUTE
C
#ifndef wn_vx__
	IF (TYP.EQ.0) THEN			!OPEN
	  GOTO 1000
	ELSE IF (TYP.EQ.1) THEN			!CLOSE
	  GOTO 1100
	ELSE IF (TYP.EQ.2) THEN			!MESSAGE
	  GOTO 1200
	ELSE IF (TYP.EQ.3) THEN			!POLY LINE
	  PLW1(1)=IXTL(NINT(A_E(PE+WQD_PLIX_E+3*VP(1)))) !LINE TYPE
	  J=NINT(MIN(A_E(PE+WQD_MXPLS_E),A_E(PE+WQD_NMPLS_E)*
	1		A_E(PE+WQD_PLIX_E+3*VP(1)+1))) !THICKNESS
	  GOTO 1300
	ELSE IF (TYP.EQ.4) THEN			!POLY LINE
	  PLW1(1)=IXTL(NINT(WNGGE(VP(3))))	!LINE TYPE
	  J=NINT(MIN(A_E(PE+WQD_MXPLS_E),A_E(PE+WQD_NMPLS_E)*
	1		WNGGE(VP(4))))		!THICKNESS
	  GOTO 1300
	ELSE IF (TYP.EQ.5) THEN			!CLEAR SCREEN
	  CALL GREXEC(1,6,RBUF,NBUF,' ',1)	!GET SIZES
	  RBUF(1)=RBUF(2)
	  RBUF(2)=RBUF(4)
	  NBUF=2
	  CALL GREXEC(1,11,RBUF,NBUF,' ',1)	!START PICTURE
	  GOTO 900
	ELSE IF (TYP.EQ.6) THEN			!SHADING
	  GOTO 1600
	END IF
C
 900	CONTINUE
C
	RETURN					!UNKNOWN
C
C OPEN
C
 1000	CONTINUE
	JS=WNDDIS(.FALSE.,LOPC)			!GET DISPLAY
	RBUF(2)=1				!SET OPEN
	RBUF(3)=0				!CLEAR SCREEN
	NBUF=3
	IF (LOPC.EQ.' ') LOPC=':0.0'		!DEFAULT DEVICE
	CALL GREXEC(1,9,RBUF,NBUF,LOPC,WNCALN(LOPC)) !OPEN DEVICE
	IF (RBUF(2).EQ.0) CALL WNGEX		!CANNOT OPEN; STOP
	RBUF(1)=0				!SET 0 WHITE
	RBUF(2)=1
	RBUF(3)=1
	RBUF(4)=1
	NBUF=4
	CALL GREXEC(1,21,RBUF,NBUF,' ',1)
	RBUF(1)=1				!SET 1 BLACK
	RBUF(2)=0
	RBUF(3)=0
	RBUF(4)=0
	NBUF=4
	CALL GREXEC(1,21,RBUF,NBUF,' ',1)
	CALL GREXEC(1,6,RBUF,NBUF,' ',1)	!GET SIZES
	RBUF(1)=RBUF(2)
	RBUF(2)=RBUF(4)
	NBUF=2
	A_E(PE+WQD_XHI_E)=RBUF(1)		!SAVE EXTERNAL SIZE
	A_E(PE+WQD_YHI_E)=RBUF(2)
	R0=MIN(RBUF(1),RBUF(2))			!SET TRANSFORM
	A_E(PE+WQD_NTR_E+0)=R0
	A_E(PE+WQD_NTR_E+2)=R0
	A_E(PE+WQD_NTR_E+10)=RBUF(1)
	A_E(PE+WQD_NTR_E+11)=RBUF(2)
	CALL GREXEC(1,11,RBUF,NBUF,' ',1)	!START PICTURE
	CALL GREXEC(1,16,RBUF,NBUF,' ',1)	!FLUSH
	A_J(PJ+WQD_USE_J+0)=DEFPL		!POLYLINE INDEX
C
	RETURN
C
C CLOSE
C
 1100	CONTINUE
	RBUF(1)=0				!NO SCREEN CLEAR
	NBUF=1
	CALL GREXEC(1,14,RBUF,NBUF,' ',1)		!END PICTURE
	CALL GREXEC(1,10,RBUF,NBUF,WQG_XSTAT,I1) !CLOSE SCREEN
C
	RETURN
C
C MESSAGE
C
 1200	CONTINUE
	J0=MIN(VP(2),A_J(PJ+WQD_MGL_J))		!MESSAGE LENGTH
	CALL WNGMTS(J0,A_B(VP(1)-A_OB),LOPC(1:)) !MESSAGE
	CALL GREXEC(1,30,RBUF,NBUF,LOPC,J0)	!WRITE MESSAGE
	A_J(PJ+WQD_USE_J+0)=DEFPL		!POLYLINE INDEX
C
	RETURN
C
C POLYLINE
C
 1300	CONTINUE
	PLW1(2)=THL(J)
	PLW1(3)=THL(J)
	PLW1(4)=0
	IF (PLW.NE.A_J(PJ+WQD_USE_J+0)) THEN	!CHANGED
	  J2=PLW1(1)
	  IF ((J2.LT.0).OR.(J2.GT.3)) PLW1(1)=0
	  IF ((J.LT.1).OR.(J.GT.31)) THEN
	    PLW1(2)=1
	    PLW1(3)=1
	  END IF
	  A_J(PJ+WQD_USE_J+0)=PLW		!SAVE NEW
	END IF
C
C DRAW LINES
C
	J=(VP(2)-A_OB)/LB_J			!J/E INPUT PTR
 20	CONTINUE				!DO PIECE
	J2=1					!OUTPUT POINTER
	J1=A_J(J)				!# OF POINTS
	J=J+1					!INPUT POINTER
	IF (J1.GT.0) THEN			!MORE
	  RBUF(3)=A_E(J)			!START
	  RBUF(4)=A_E(J+1)			!Y
	  NBUF=4
	  J1=J1-1
	  J=J+2
	  DO WHILE (J1.GT.0)			!ALL SEGMENTS
	    RBUF(1)=RBUF(3)
	    RBUF(2)=RBUF(4)
	    RBUF(3)=A_E(J)
	    RBUF(4)=A_E(J+1)			!Y
	    J=J+2				!NEXT POINT
	    PX=RBUF(3)				!SAVE X,Y
	    PY=RBUF(4)
	    J1=J1-1				!COUNT
	    DO I=1,4				!START THICK LINES
	      RBUF(I)=RBUF(I)-(PLW1(2)/2)
	    END DO
	    LPLW=PLW1(2)			!THICKNESS
	    DO I1=1,LPLW			!# OF LINES
	      DO I=1,LPLW
	        IF (PLW1(1).LE.0) THEN		!FULL DRAWN
	          CALL GREXEC(1,12,RBUF,NBUF,' ',1) !DRAW PIECE
	 	ELSE
		  I2=IAND(WNMRNJ()/8,PAT(0,PLW1(1))-1) !PATTERN POSITION
		  DX=RBUF(3)-RBUF(1)		!INCREMENT
		  DY=RBUF(4)-RBUF(2)
		  R0=SQRT(DX**2+DY**2)
		  IF (R0.NE.0) THEN		!DRAW SOME
		    DX=DX/R0
		    DY=DY/R0
		    R0=R0+.01
		    R1=0
		    IF (PLW1(1).GT.0) THEN	!ALL DOT
		      IF (I2.EQ.0) THEN
			RBF1(1)=RBUF(1)		!DRAW DOT
			RBF1(2)=RBUF(2)
			RBF1(3)=RBUF(1)
			RBF1(4)=RBUF(2)
	           	CALL GREXEC(1,12,RBF1,NBUF,' ',1) !DRAW DOT
		      END IF
		      R1=R1+SQRT(((4-I2)*DX)**2+((4-I2)*DY)**2) !NEXT POINT
		      DO WHILE (R1.LT.R0)
			RBF1(1)=RBUF(1)+R1*DX
			RBF1(2)=RBUF(2)+R1*DY
			RBF1(3)=RBF1(1)
			RBF1(4)=RBF1(2)
	           	CALL GREXEC(1,12,RBF1,NBUF,' ',1) !DRAW DOT
		        R1=R1+SQRT(((4)*DX)**2+((4)*DY)**2) !NEXT POINT
		      END DO
		    END IF
		  END IF
		END IF
		RBUF(1)=RBUF(1)+1.
		RBUF(3)=RBUF(3)+1.
	      END DO
	      RBUF(1)=RBUF(1)-LPLW
	      RBUF(3)=RBUF(3)-LPLW
	      RBUF(2)=RBUF(2)+1.
	      RBUF(4)=RBUF(4)+1.
	    END DO
	    RBUF(3)=PX				!RESTORE END POINT
	    RBUF(4)=PY
	  END DO
	  J2=J2-1
 	  GOTO 20				!NEXT PIECE
	END IF
	CALL GREXEC(1,16,RBUF,NBUF,' ',1)	!SHOW PIECE
C
	RETURN
C
C SHADING
C
 1600	CONTINUE
	J=(VP(3)-A_OB)/LB_E			!TOTAL BOX POINTER
	J4=(VP(5)-A_OB)/LB_E			!SINGLE BOX POINTER
	XB(0,0)=NINT(MAX(0.,A_E(J+0)))		!BOX LIMITS
	XB(1,0)=NINT(MAX(0.,A_E(J+1)))
	XB(0,1)=NINT(MIN(A_E(PE+WQD_XHI_E),A_E(J+2)))
	XB(1,1)=NINT(MIN(A_E(PE+WQD_YHI_E),A_E(J+3)))
	CALL GREXEC(1,2,RBUF,NBUF,' ',1)	!GET COLOUR RANGE
	MNIND=NINT(RBUF(5))			!MIN. INDEX
	MXIND=NINT(RBUF(6))
	MNIND=MAX(17,MXIND-127)			!SELECT INDICES
	NBUF=4
	DO I=MNIND,MXIND			!SET SHADES
	  RBUF(1)=I
	  RBUF(2)=REAL(I-MNIND)/REAL(MXIND-MNIND)
	  RBUF(3)=RBUF(2)
	  RBUF(4)=RBUF(2)
	  NBUF=4
	  CALL GREXEC(1,21,RBUF,NBUF,' ',1)
	END DO
	IF (.NOT.WNGGVM(NINT(A_E(PE+WQD_XHI_E)*LB_E+4*LB_E),BMP))
	1		GOTO 900		!GET BITMAP LINE
	I3=(BMP-A_OB)/LB_E			!BUFFER POINTER
C
C ALL SQUARES
C
	J0=(VP(2)-A_OB)/LB_E			!INT POINTER
	DO I=0,VP(4)-1				!ALL SQUARES
	  IF (A_E(J0+I).GE.0.) THEN		!NOT DELETED
	    DO I1=0,1				!GET X,Y START
	      XYC(I1)=A_E(J4+4+I1)+I*A_E(J4+I1)
	    END DO
	    DO I1=NINT(XYC(1)),NINT(XYC(1)+A_E(J4+3))-1		!ALL LINES
	      IF (I1.GE.XB(1,0) .AND. I1.LT.XB(1,1)) THEN	!IN MAP
		I2MN=1E6
		I2MX=0
	        DO I2=NINT(XYC(0)),NINT(XYC(0)+A_E(J4+2))-1	!ALL POINTS
	          IF (I2.GE.XB(0,0) .AND. I2.LT.XB(0,1)) THEN	!IN MAP
		    R0=MIN(1.,A_E(J0+I))			!INT.
		    IF (VP(1).EQ.1) THEN			!REGULAR
		      R0=1.-((R0*20.)/20.)
		    ELSE IF (VP(1).EQ.2) THEN			!PATTERN
		      R0=1.-((R0*10.)/10.)
		    ELSE					!RANDOM
		      R0=1.-R0					!CONTIN.
		    END IF
		    A_E(I3+2+I2)=MNIND+(MXIND-MNIND)*R0		!NORM.
		    I2MN=MIN(I2,I2MN)
		    I2MX=MAX(I2,I2MX)
		  END IF
	        END DO
		IF (I2MN.LE.I2MX) THEN				!SOME POINTS
		  A_E(I3+I2MN-2)=I2MN				!X
		  A_E(I3+I2MN-1)=I1				!Y
		  NBUF=I2MX-I2MN+3
		  CALL GREXEC(1,26,A_E(I3+I2MN-2),NBUF,' ',1)
		END IF
	      END IF
	    END DO
	  END IF
	END DO
	CALL GREXEC(1,16,RBUF,NBUF,' ',1)			!SHOW PIECE
	CALL WNGFVM(NINT(A_E(PE+WQD_XHI_E)*LB_E+4*LB_E),BMP)
#endif
C
C READY
C
 910	CONTINUE
C
	RETURN
C
C
	END

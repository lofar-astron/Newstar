C+ WNTINC.FOR
C  WNB 930501
C
C  Revisions:
C
	SUBROUTINE WNTINC(IFIL)
C
C  Main routine to convert .DSC file into .DEF etc files.
C
C  Result:
C
C	CALL WNTINC( IFIL_C*:I)		Convert .DSC file with name IFIL
C					to .DEF, .INC etc. IFIL should have
C					no extension, but may have directory.
C					The file name part will be assumed
C					to be lc.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WNT_O_DEF'
	INCLUDE 'WNT_DEF'
C
C  Parameters:
C
	INTEGER NLVAR			!# OF INIT LOCAL VARIABLES
	  PARAMETER (NLVAR=T__N)
C
C  Arguments:
C
	CHARACTER*(*) IFIL		!FILE TO DO
C
C  Function references:
C
	INTEGER WNCALN,WNCAL0		!STRING LENGTH
	LOGICAL WNCATD			!TEST DIGIT
	LOGICAL WNCATN			!TEST NAME LIKE
	LOGICAL WNCASC			!TEST CHARACTER GIVEN
	CHARACTER*1 WNCALO		!MAKE LC
	LOGICAL WNTIRL			!READ A LINE
	INTEGER WNTIBP,WNTIBW		!PUT LINE IN BUFFER
	INTEGER WNTIBR			!READ LINE FROM BUFFER
	LOGICAL WNTIAP			!ANALYSE % LINE
	LOGICAL WNTIAN			!ANALYSE . LINE
	LOGICAL WNTIAF			!ANALYSE FORMAT LINE
	LOGICAL WNTIVS			!SET LOCAL VARIABLE
C
C  Data declarations:
C
	INTEGER DINC			!INCLUDE DEPTH
	INTEGER PLUN(MXDINC)		!OPEN LUNS
	CHARACTER*(MXSLIN) ISTR,IDAT,ICOM !SINGLE LINE DATA/COMMENT
	  BYTE BICOM(0:MXSLIN-1)
	  EQUIVALENCE (BICOM,ICOM)
	CHARACTER*(MXTLIN) TLIN		!TOTAL DATA LINE
	INTEGER LLIN			!LENGTH FILLED OF TLIN
	LOGICAL CONTL			!CONTINUATION LINE
	INTEGER CLIN			!CURRENT LINE
	INTEGER CFLIN			!CURRENT FORMAT LINE
	INTEGER IENTRY(0:WNTBHDL/LB_J-1) !CURRENT INPUT LINE DESCRIPTOR
	INTEGER LENTRY(0:WNTBHDL/LB_J-1) !INPUT LINE DESCRIPTOR
	INTEGER FENTRY(0:WNTFHDL/LB_J-1) !CURRENT DATA FORMAT ENTRY
	INTEGER EENTRY(0:WNTEHDL/LB_J-1) !CURRENT EDIT ENTRY
	CHARACTER*(MXLNAM) NAM		!NAME FIELD
	CHARACTER*8 LVNAM(NLVAR)	!INITIAL LOCAL VARIABLES
	  DATA LVNAM/'LB_B','LB_C','LB_L','LB_I','LB_J','LB_K',
	1		'LB_E','LB_D','LB_X','LB_Y','LB_A','LB_S',
	1		'T__N'/
	INTEGER LVVAL(NLVAR)
	  DATA LVVAL/LB_B,LB_C,LB_L,LB_I,LB_J,LB_K,
	1		LB_E,LB_D,LB_X,LB_Y,LB_A,LB_S,
	1		T__N/
C-
C
C PRELIMINARIES
C
	CALL WNCFHD(F_P,1,'!40CConvert .DSC tables to usable files') !HEADING
	UNID=0					!UNIQUE NAME ID
	LSTON=.TRUE.				!LIST IN LOG
	PRTON=.TRUE.				!PRINT COMMENTS
	ALGON=.FALSE.				!NO ALIGN
	CATP=0					!CURRENT AREA TYPE
	CALN=-1					!PREVIOUS AREA LINE
	CBTP=0					!CURRENT BLOCK TYPE
	COFF=0					!CURRENT OFFSET
	CALEN=0					!CURRENT ALIGN LENGTH
	DEFSN=.FALSE.				!NO .DEFINE SEEN
	BEGSN=.FALSE.				!NO .BEGIN SEEN
	PARSN=.FALSE.				!NO .PARAMETER SEEN
	CINSN=.FALSE.				!NO COMMON INIT SEEN
	DEP=0					!DEPTH OF BLOCKS
	DINC=0					!INCLUDE DEPTH
	CLIN=-1					!NO LINE READ
	CFLIN=-1				!NO FORMAT LINE READ
C
C SET PARAMETERS
C
	CALL WNCTXS(PARM(P_DAT),'!%DN')		!INIT DATE
	CALL WNGSGU(PARM(P_USE))		!INIT USER
	PARM(P_VER)='1'				!INIT VERSION
	PARM(P_SYS)='1'				!INIT SYSTEM
	PARM(P_NAM)=' '				!NAME OF FILE
C
C SET DATA SAVE AREAS
C
	CALL WNGMVZ(WNTBHDL,IBDES)		!CLEAR INPUT LINE BUFFER
	IBDES_J(WNTB_ELEN_J)=WNTIHDL
	CALL WNGMVZ(WNTIHDL,IENTRY)		!MAKE SURE EMPTY ENTRY
	CALL WNGMVZ(WNTBHDL,CBDES)		!CLEAR COMMENT LINE BUFFER
	CBDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,VBDES)		!CLEAR VALUE BUFFER
	VBDES_J(WNTB_ELEN_J)=WNTVHDL
	CALL WNGMVZ(WNTBHDL,RBDES)		!CLEAR %REVISION BUFFER
	RBDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,CMDES)		!CLEAR %COMMENT BUFFER
	CMDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,FMDES)		!CLEAR %FORTRAN BUFFER
	FMDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,CCDES)		!CLEAR %CC BUFFER
	CCDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,FEDES)		!CLEAR %FORTRAN END BUFFER
	FEDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,CEDES)		!CLEAR %CC END BUFFER
	CEDES_J(WNTB_ELEN_J)=MXSLIN
	CALL WNGMVZ(WNTBHDL,XFDES)		!CLEAR DATA FORMAT BUFFER
	XFDES_J(WNTB_ELEN_J)=WNTFHDL
	I2=WNTIBP(XFDES,FENTRY)			!MAKE SURE NO ZERO PTR
	CALL WNGMVZ(WNTBHDL,DFDES)		!CLEAR DATA INIT BUFFER
	DFDES_J(WNTB_ELEN_J)=WNTDHDL
	CALL WNGMVZ(WNTBHDL,EFDES)		!CLEAR DATA EDIT BUFFER
	EFDES_J(WNTB_ELEN_J)=WNTEHDL
	I2=WNTIBP(EFDES,EENTRY)			!MAKE SURE NO ZERO PTR
C
C SET INITIAL LOCAL VARIABLES
C
	DO I=1,NLVAR				!SET LOCAL VARIABLES
	  IF (.NOT.WNTIVS(LVVAL(I),LVNAM(I),.FALSE.)) THEN
	    CALL WNCTXT(F_TP,'Fatal -- Cannot intialise local variables')
	    GOTO 990
	  END IF
	END DO
C
C GET FILENAME
C
	I0=WNCAL0(IFIL)				!END OF NAME
	I1=I0
	DO WHILE (I1.GT.0)
	  IF (.NOT.WNCATD(IFIL,I1) .AND.
	1		.NOT.WNCATN(IFIL,I1)) GOTO 10 !FIND BEGIN OF NAME
	  I1=I1-1
	END DO
 10	CONTINUE
	I1=I1+1					!SKIP SEPARATOR
	DO I=I1,I0				!ACT ON NAME
	  IFIL(I:I)=WNCALO(IFIL(I:I))		!MAKE LC
	END DO
	IF (I1.GT.I0) GOTO 900			!NO NAME GIVEN
	IFIL=IFIL(1:WNCALN(IFIL))//'.dsc'	!MAKE FULL FILE NAME
	PARM(P_NAM)=IFIL(I1:I0)			!SET NAME
	CALL WNCALC(PARM(P_NAM))		!MAKE LC
	CALL WNCFSN(F_P,PARM(P_NAM)(:WNCALN(PARM(P_NAM)))//'.lis') !LOG NAME
	CALL WNCAUC(PARM(P_NAM))		!MAKE UC
	CALL WNCFHD(F_P,1,'!40CConvert !AS$.DSC table to usable files',
	1		PARM(P_NAM))
	OINFIL=PARM(P_NAM)			!ORIGINAL INPUT FILE
	CALL WNCALC(OINFIL)			!MAKE LC
	INFIL=IFIL				!FILE TO USE
C
C OPEN FILE
C
 20	CONTINUE
	IF (DINC.GE.MXDINC) THEN
	  CALL WNCTXT(F_TP,'Fatal -- Too many (!UJ) include files',
	1		MXDINC)
	  GOTO 990
	END IF
	CALL WNGLUN(PLUN(DINC+1))		!GET LUN TO USE
	IF (PLUN(DINC+1).LE.0) GOTO 910		!CANNOT OPEN
	OPEN (UNIT=PLUN(DINC+1),FILE=INFIL,STATUS='OLD',ERR=910) !OPEN INPUT
	DINC=DINC+1				!INCREMENT DEPTH
C
C SCAN FILE
C
C READ LINE
C
 300	CONTINUE
	IF (CLIN.GE.0) THEN			!AT LEAST ONE LINE
	  IF (IENTRY(WNTI_FTYP_J).GT.0) THEN	!A FORMAT BELONGS
	    FENTRY(WNTF_ENT_J)=CFLIN		!POINT TO START COMMENTS
	    IENTRY(WNTI_PFOR_J)=WNTIBP(XFDES,FENTRY) !SAVE FORMAT NUMBER
	    CLIN=WNTIBW(IBDES,IENTRY,CLIN)	!REWRITE CURRENT LINE
	  END IF
	END IF
 310	CONTINUE
	TLIN=' '				!START WITH EMPTY LINE
	LLIN=0
	IF (IENTRY(WNTI_FTYP_J).GE.0) CFLIN=CLIN+1 !NEXT START COMMENTS
	CALL WNGMVZ(WNTIHDL,IENTRY)		!CLEAR INPUT ENTRY
	CALL WNGMVZ(WNTFHDL,FENTRY)		!EMPTY FORMAT ENTRY
 100	CONTINUE
	IF (.NOT.WNTIRL(PLUN(DINC),ISTR,IDAT,ICOM,CONTL)) THEN !EOF/ERROR
	  IF(.NOT.CONTL) GOTO 930		!ERROR
	  CLOSE (UNIT=PLUN(DINC),ERR=930)
	  IF (CLIN.GE.0 .AND. IENTRY(WNTI_FTYP_J).EQ.FT_CON) THEN
	    CALL WNCTXT(F_TP,
	1	'Fatal -- Missing continuation line at file end')
	    GOTO 990
	  END IF
	  DINC=DINC-1				!LOWER DEPTH
	  IF (DINC.LE.0) GOTO 200		!END OF INPUT
	  GOTO 100				!READ MORE
	END IF
	IF (LSTON) THEN				!LIST ON
	  CALL WNCTXT(F_P,'!#* !4$ZJ:!16C!AS',
	1		DINC,IBDES_J(WNTB_CNT_J)+1,ISTR) !SHOW LINE
	END IF
	I0=WNCAL0(IDAT)				!LENGTH DATA
	I1=WNCAL0(ICOM)				!LENGTH COMMENT
	IF (I0+LLIN.GT.MXTLIN) THEN		!TOO LONG A LINE
	  CALL WNCTXT(F_TP,'Fatal -- Line too long')
	  GOTO 990
	END IF
	IF (I1.GT.0) IENTRY(WNTI_PCOM_J)=WNTIBP(CBDES,BICOM) !SAVE COMMENT
	IF (I0.GT.0) THEN			!ADD TO TOTAL LINE
	  TLIN=TLIN(1:LLIN)//IDAT(1:I0)
	  LLIN=LLIN+I0				!NEW LENGTH
	END IF
	IENTRY(WNTI_LCOM_J)=I1			!SET COMMENT LENGTH
	IF (CONTL) THEN				!SET DATA TYPE
	  IENTRY(WNTI_FTYP_J)=FT_CON
	ELSE
	  IENTRY(WNTI_FTYP_J)=0			!SET NO FORMAT
	END IF
	CLIN=WNTIBP(IBDES,IENTRY)		!SAVE LINE ENTRY
	IF (CONTL) GOTO 100			!CONTINUATION LINE
C
C ANALYSE LINE
C
 400	CONTINUE
	J=1					!DATA LINE POINTER
	CALL WNCASB(TLIN(1:LLIN),J)		!SKIP BLANKS
C
C COMMENT ONLY
C
	IF (J.GT.LLIN) THEN			!EMPTY DATA
	  IF (ISTR(1:1).NE.'!' .AND. ISTR.NE.' '
	1		.AND. CLIN.GT.0) THEN	!ASSUME CONT. COMMENT
	    I=WNTIBR(IBDES,LENTRY,CLIN-1)	!PREVIOUS LINE
	    IF (LENTRY(WNTI_FTYP_J).NE.FT_CON) THEN !NOT CONTINUATION ALREADY
	      I1=LENTRY(WNTI_FTYP_J)		!PREVIOUS TYPE
	      LENTRY(WNTI_FTYP_J)=FT_CON	!SET CONT.
	      I=WNTIBW(IBDES,LENTRY,I)		!REWRITE PREVIOUS LINE ENTRY
	      IENTRY(WNTI_FTYP_J)=I1		!NEW DATA LENGTH
	    END IF
	  ELSE
	    FENTRY(WNTF_BTYP_J)=CBTP		!SET CURRENT BLOCK TYPE
	    IENTRY(WNTI_FTYP_J)=FT_DAT		!SET DATA FORMAT
	    FENTRY(WNTF_REFP_J)=CLIN		!SET LINE REF.
	  END IF
	  GOTO 310				!NEXT LINE
	END IF
C
C % NAME
C
	IF (WNCASC(TLIN(1:LLIN),J,'%')) THEN	!% TYPE
	  IF (.NOT.WNTIAP(TLIN(1:LLIN),J,NAM,CFLIN)) GOTO 920 !ANALYSE IT
	  IF (NAM.EQ.P__TXT(P_INS) .OR.
	1		NAM.EQ.P__TXT(P_INC)) GOTO 20 !NEXT FILE
	  GOTO 300				!NEXT LINE
	END IF
C
C . NAME
C
	IF (WNCASC(TLIN(1:LLIN),J,'.')) THEN	!. TYPE
	  IF (.NOT.WNTIAN(TLIN(1:LLIN),J,NAM,CLIN,
	1		IENTRY,FENTRY)) GOTO 921 !ANALYSE IT
	  GOTO 300				!NEXT LINE
	END IF
C
C FORMAT LINE
C
	IF (DEP.GT.0 .OR. CBTP.EQ.BT_PAR) THEN	!COULD BE DATA
	  IF (.NOT.WNTIAF(TLIN(1:LLIN),J,NAM,CLIN,
	1		IENTRY,FENTRY,CFLIN)) GOTO 922 !ANALYSE FORMAT LINE
	  GOTO 300				!NEXT LINE
	END IF
	CALL WNCTXT(F_TP,'Fatal -- Unknown input line type')
	GOTO 990
C
C END OF INPUT
C
 200	CONTINUE
	IF (IBDES_J(WNTB_CNT_J).LE.0) THEN	!NO INPUT
	  CALL WNCTXT(F_TP,'Fatal -- No input lines')
	  GOTO 990
	END IF
C
C READY
C
	CALL WNTIOS				!OUTPUT FILES
	CALL WNTIOL				!OUTPUT LOG
	GOTO 800
C
C ERRORS
C
C NO NAME
C
 900	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- No or unknown file name given')
	GOTO 990
C
C NO OPEN
C
 910	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- Cannot open file !AS',
	1		INFIL)
	GOTO 990
C
C % FORMAT
C
 920	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- Illegal % name (!AS) or format',
	1		NAM)
	GOTO 990
C
C . FORMAT
C
 921	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- Illegal . name (!AS) or format',
	1		NAM)
	GOTO 990
C
C FORMAT FORMAT
C
 922	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- Illegal format line (!AS)',
	1		NAM)
	GOTO 990
C
C I/O ERROR
C
 930	CONTINUE
	CALL WNCTXT(F_TP,'Fatal -- I/O error on file !AS',
	1		INFIL)
	GOTO 990
C
 990	CONTINUE
	E_C=0
C
	RETURN
C
C FINISH
C
 800	CONTINUE
	E_C=1
C
	RETURN
C
C
	END

C+ WNTIVG.FOR
C  WNB 930501
C
C  Revisions:
C
	LOGICAL FUNCTION WNTIVG(STR,PT,VT,VAL,NAM)
C
C  Get value from a field
C
C  Result:
C
C	WNTIVG_L = WNTIVG( STR_C*:I, PT_J:IO, VT_L:O, VAL_J:O, NAM_C*:O)
C				Get a value from STR, using the local/global
C				name table, and simple expressions.
C				VAL, NAM returns the values. VT .true. if
C				proper integer expression, else
C				character expression
C				WNTIVG .false. if error in expression.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WNT_O_DEF'
	INCLUDE 'WNT_DEF'
C
C  Parameters:
C
	INTEGER MXNOP			!MAX. # OF OPERATORS/STACK VALUES
	  PARAMETER (MXNOP=64)
C
C  Arguments:
C
	CHARACTER*(*) STR		!INPUT STRING
	INTEGER PT			!PTR INTO STRING
	LOGICAL VT			!TYPE OF RESULT (TRUE IF INTEGER)
	INTEGER VAL			!RETURNED VALE
	CHARACTER*(*) NAM		!RETURNED VALUE AS STRING
C
C  Function references:
C
	LOGICAL WNCAFN			!GET NAME
	LOGICAL WNCAFS			!GET FIELD
	LOGICAL WNCASC,WNCATC		!SKIP/TEST CHARACTER
	LOGICAL WNCATM			!TEST MULTIPLE CHARACTERS
	LOGICAL WNCATN			!TEST NAME CHARACTER
	LOGICAL WNCACU			!GET INTEGER
	LOGICAL WNTIV0,WNTIV1		!MANIPULATE STACK
C
C  Data declarations:
C
	INTEGER LBC			!LEFT ( COUNT
	INTEGER NSTK,NOP		!# OF STACK VALUES, OPERATORS
	INTEGER STK(0:MXNOP),OP(0:MXNOP) !VALUE, OPERATOR STACK
	LOGICAL LDIV			!END / SEEN
	CHARACTER*(WNTV_NAM_N) LNAM	!NAME
	BYTE VALB(0:WNTVHDL-1)		!VALUE
	  INTEGER VALJ(0:WNTVHDL/LB_J-1)
	  EQUIVALENCE (VALB,VALJ)
C-
C
C INIT
C
	WNTIVG=.FALSE.				!ASSUME ERROR
	CALL WNCASB(STR,PT)			!START AT BEGIN
	J=PT					!SAVE POINTER
	VT=.TRUE.				!ASSUME VALUE
	NSTK=0					!NO STACK
	NOP=0					!NO OPERATORS
	OP(0)=0					!NOT ( START
	LBC=0					!( COUNT
C
C EVALUATE EXPRESSION
C
C TERM
C
 10	CONTINUE
	CALL WNCASB(STR,J)			!SKIP BLANK
	IF (WNCATM(STR,J,'(+-')) THEN		!START WITH UNARY
	  IF (WNCATC(STR,J,'(')) LBC=LBC+1	!COUNT (
	  CALL WNTIV9(STR,J,OP,NOP)		!SET
	  GOTO 10				!NEXT TERM
	END IF
	IF (WNCATN(STR,J)) THEN			!IS NAME OR STRING
	  J1=J					!SAVE PTR IF UNKNOWN NAME
	  IF (.NOT.WNCAFN(STR,J,NAM)) GOTO 820	!SET FIELD
	  DO I=0,VBDES_J(WNTB_CNT_J)-1		!CHECK NAMES
	    CALL WNGMTS(WNTV_NAM_N,
	1		A_B(VBDES_J(WNTB_BPTR_J)+I*WNTVHDL+WNTV_NAM_1),
	1		LNAM)			!READ NAME
	    IF (LNAM.EQ.NAM) THEN		!FOUND NAME
	      CALL WNGMV(WNTVHDL,
	1		A_B(VBDES_J(WNTB_BPTR_J)+I*WNTVHDL),VALB) !GET VALUE
	      IF (VALJ(WNTV_TYP_J).GT.0) THEN	!HAS VALUE
		STK(NSTK)=VALJ(WNTV_VAL_J)	!SET VALUE
		NSTK=NSTK+1
		GOTO 20				!FIND OPERATOR
	      ELSE IF (VALJ(WNTV_TYP_J).EQ.0) THEN !NO VALUE, ERROR
		GOTO 900
	      ELSE				!STRING VALUE
		CALL WNGMTS(WNTV_STR_N,VALB(WNTV_STR_1),NAM) !RETURN VALUE
		GOTO 821			!READY
	      END IF
	    END IF
	  END DO
	  J=J1					!RESTORE POINTER
	  GOTO 820				!READY
	ELSE
	  IF (WNCACU(STR,J,10,D0,D1)) THEN	!INTEGER VALUE
	    STK(NSTK)=NINT(MOD(D0,2D0**L_J))	!SET VALUE
	    NSTK=NSTK+1
	  ELSE					!TRY FIELD
	    IF (.NOT.WNCAFS(STR,J,NAM)) GOTO 900 !GET A FIELD
	    IF (NOP.EQ.0) THEN			!STRING VALUE OK
	      VT=.FALSE.			!INDICATE STRING
	      VAL=0				!NO VALUE
	      GOTO 810				!READY
	    END IF
	    GOTO 900				!ERROR
	  END IF
	END IF
C
C OPERATOR
C
 20	CONTINUE
	LDIV=.FALSE.				!COULDE BE REAL /
	J1=J					!CHECK POINTER
	CALL WNCASB(STR,J)			!SKIP BLANK
	IF (J.GT.J1) LDIV=.TRUE.		!NOT REAL /
	IF (.NOT.WNTIV1(OP,NOP,STK,NSTK,OP_SP,OP_SM)) GOTO 900 !DO UNARY +-
	IF (WNCATC(STR,J,')') .AND. LBC.LE.0) GOTO 21
	IF (WNCASC(STR,J,')')) THEN		!END SUB-TERM
	  LBC=LBC-1				!COUNT (
	  IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_PL,OP_DV)) GOTO 900 !DO BINARY
	  IF (NOP.GT.0 .AND. OP(NOP-1).EQ.OP_LB) THEN
	    NOP=NOP-1				!REMOVE (
	    IF (WNCATC(STR,PT,'(')) GOTO 800	!READY
	  ELSE
	    GOTO 900				!MISSING (
	  END IF
	  GOTO 20				!NEXT OPERATOR
	END IF
 21	CONTINUE
	IF (WNCATC(STR,J,'*')) THEN		!*
	  IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_MU,OP_DV)) GOTO 900 !DO BINARY
	  CALL WNTIV8(STR,J,OP,NOP)		!SET BINARY
	ELSE IF (WNCATC(STR,J,'/')) THEN	!/
	  IF (LBC.LE.0) THEN			!CHECK IF NOT /
	    IF (.NOT.LDIV) THEN
	      J1=J
	      JS=WNCASC(STR,J,'/')
	      J2=J
	      CALL WNCASB(STR,J)
	      IF (J.GT.LEN(STR) .OR. J.GT.J2) LDIV=.TRUE. !NOT REAL /
	      J=J1				!RESTORE POINTER
	    END IF
	  ELSE
	    LDIV=.FALSE.			!REAL /
	  END IF
	  IF (LDIV) THEN			!NOT REAL /
	    IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_PL,OP_DV)) GOTO 900 !DO BINARY
	    GOTO 800				!READY
	  ELSE
	    IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_MU,OP_DV)) GOTO 900 !DO BINARY
	    CALL WNTIV8(STR,J,OP,NOP)		!SET BINARY
	  END IF
	ELSE IF (WNCATM(STR,J,'+-')) THEN	!-+
	  IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_PL,OP_DV)) GOTO 900 !DO BINARY
	  CALL WNTIV8(STR,J,OP,NOP)		!SET BINARY
	ELSE					!END
	  IF (.NOT.WNTIV0(OP,NOP,STK,NSTK,OP_PL,OP_DV)) GOTO 900 !DO BINARY
	  GOTO 800				!READY
	END IF
	GOTO 10					!NEXT TERM
C
C ERROR
C
 900	CONTINUE
	NAM=' '					!NO NAME
	VAL=0					!NO VALUE
	VT=.FALSE.				!NO VALUE
C
	RETURN
C
C READY
C
 820	CONTINUE
	IF (.NOT.WNCAFS(STR,J,NAM)) GOTO 900	!GET A FIELD
 821	CONTINUE
	IF (NOP.NE.0 .OR. NSTK.NE.0) GOTO 900	!STRING VALUE NOT ALLOWED
	VT=.FALSE.				!INDICATE STRING
	VAL=0					!NO VALUE
	GOTO 810				!READY
C
 800	CONTINUE
	IF (NOP.EQ.0 .AND. NSTK.EQ.1) THEN
	  VAL=STK(0)				!VALUE
	  CALL WNCTXS(NAM,'!SJ',VAL)
	ELSE
	  GOTO 900
	END IF

 810	CONTINUE
	PT=J					!RESET POINTER
	WNTIVG=.TRUE.				!OK
C
	RETURN
C
C
	END

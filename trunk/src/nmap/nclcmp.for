C+ NCLCMP.FOR
C  WNB 920117
C
C  Revisions:
C	HjV 920520	HP does not allow extended source lines
C	WNB 921202	Free buffers; cater for J2000
C	WNB 930928	Add instrument
C
	SUBROUTINE NCLCMP(MPHP,APHP)
C
C  Get clean component list
C
C  Result:
C	CALL NCLCMP( MPHP_J:I, APHP_J:I)
C				Do a Clark type clean, using the UV cover
C				to obtain a source list. MPHP and APHP are the
C				map and beam header pointers.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'MPH_O_DEF'	!MAP HEADER
	INCLUDE 'MDH_O_DEF'	!MODEL HEADER
	INCLUDE 'NCL_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MPHP		!MAP HEADER POINTER
	INTEGER APHP		!BEAM HEADER POINTER
C
C  Function references:
C
	LOGICAL WNGGVM		!GET VIRTUAL MEMORY
	LOGICAL WNFRD		!READ DISK
	LOGICAL NMOSLG		!GET SOURCE SPACE
C
C  Data declarations:
C
	INTEGER BMSIZ,MPSIZ	!PATCH BUFFER SIZES
	INTEGER BMPAD,MPPAD	!PATCH BUFFER ADDRESSES
	REAL SUMGL		!GRATING LOBE SUM
	INTEGER MDHJ(0:MDHHDL/4-1) !MODEL HEADER
	  REAL MDHE(0:MDHHDL/4-1)
	  DOUBLE PRECISION MDHD(0:MDHHDL/8-1)
	  EQUIVALENCE (MDHJ,MDHE,MDHD)
	BYTE MPH(0:MPHHDL-1)	!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1)
	  INTEGER MPHJ(0:MPHHDL/4-1)
	  REAL MPHE(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	BYTE APH(0:MPHHDL-1)	!BEAM HEADER
	INTEGER RG(0:1)		!SOURCE RANGE
	  DATA RG/1,1000000/
C-
C
C INIT
C
	IF (.NOT.WNFRD(FCAMAP,MPHHDL,MPH,MPHP)) THEN !READ MAP HEADER
	  CALL WNCTXT(F_TP,'Error reading map header')
	  CALL WNGEX				!STOP
	END IF
	MINLIM=MAX(ABS(MPHE(MPH_MAX_E)),ABS(MPHE(MPH_MIN_E))) !SET MAP MAX
	IF (APHP.NE.0) THEN			!BEAM PRESENT
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,APH,APHP)) THEN !READ BEAM HEADER
	    CALL WNCTXT(F_TP,'Error reading beam header')
	    CALL WNGEX				!STOP
	  END IF
	ELSE					!NO BEAM
	  CALL WNGMV(MPHHDL,MPH,APH)		!MAKE SURE DATA PRESENT
	END IF
C
C GET HISTOGRAMS AND PATCH DATA
C
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'Histogramming')
	CALL NCLHID(MPHP,APHP)			!GET BEAM PATCH, SHOW HISTO
	CALL WNCTXT(F_P,'!^')
C
C INIT SOURCE LIST
C
	CALL NMOHMF(7,MDHJ)			!GET HEADER 7
	CALL NMOHZD(MDHJ)			!CLEAR SOURCES
	MDHD(MDH_RA_D)=MPHD(MPH_RA_D)		!SET MAP RA
	MDHD(MDH_DEC_D)=MPHD(MPH_DEC_D)		!SET MAP DEC
	MDHD(MDH_FRQ_D)=MPHD(MPH_FRQ_D)		!SET MAP FREQ.
	IF (MPHI(MPH_EPT_I).EQ.1) THEN		!1950/2000 COORDINATES
	  MDHJ(MDH_TYP_J)=2			!EPOCH TYPE
	  MDHE(MDH_EPOCH_E)=MPHE(MPH_EPO_E)	!EPOCH
	ELSE					!APPARENT
	  MDHJ(MDH_TYP_J)=1			!EPOCH TYPE
	  MDHE(MDH_EPOCH_E)=0.			!EPOCH
	END IF
	MDHJ(MDH_BITS_J)=MPHJ(MPH_INST_J)	!SET INSTRUMENT
	IF (.NOT.NMOSLG(SRCLIM,MDHJ)) THEN	!GET AREA
	  CALL WNCTXT(F_TP,'No space for clean source list')
	  CALL WNGEX				!STOP
	END IF
C
C GET PATCH BUFFER
C
	BMSIZ=LB_E*(2*BEMPAT+1)*(BEMPAT+1)	!BEAM BUFFER SIZE
	MPSIZ=(LB_E+2*LB_I)*MAPPAT		!MAP BUFFER SIZE
	JS=WNGGVM(BMSIZ,BMPAD)			!GET BEAM PATCH BUF
	IF (JS) JS=WNGGVM(MPSIZ,MPPAD)		!GET MAP POINT BUFFER
	IF (.NOT.JS) THEN
	  CALL WNCTXT(F_TP,'Cannot obtain beam and/or map patch buffers')
	  CALL WNGEX				!STOP
	END IF
	CALL WNCTXT(F_TP,'!/Beam patch of !UJ points, '//
	1		'!UJ mappoints down to !E10.3 W.U. (!E7.2%)!/',
	1		2*BEMPAT+1,MAPPAT,MAPLIM,100.*MAPLIM/MINLIM)
C
C READ DATA
C
	CALL NCLCRD(FCAMAP,APH,A_B(BMPAD-A_OB),FCAMAP,MPHJ(MPH_MDP_J),
	1		MPH,A_B(MPPAD-A_OB),A_B(MPPAD-A_OB)) !BEAM, MAP PATCH
C
C DO CLEAN
C
	CALL WNCCSX(F_TP,'Cleaning')
	J=MDHJ(MDH_NSRC_J)+1			!START SOURCE
	SUMGL=0					!START GRATING RESPONSE
	DO WHILE (CURMAX.GT.MAPLIM .AND.
	1		MDHJ(MDH_NSRC_J).LT.SRCLIM .AND.
	1		CURMAX.GE.SUMGL)
	  CALL NCLCCL(A_B(BMPAD-A_OB),A_B(MPPAD-A_OB),A_B(MPPAD-A_OB),
	1		J,MDHJ,MPH,SUMGL)	!CLEAN CYCLE
	END DO
C
C FINISH SOURCE LIST
C
	CALL NMOHMT(MDHJ,7)			!SET HEADER 7
	CALL NMORDM(7,-1)			!ADD SOURCES TO GENERAL LIST
	CALL NMOAMG				!MERGE COMPONENTS
	CALL NMOPTT(F_TP,RG)			!SHOW TOTAL FLUX
	IF (FCAAP.EQ.0) THEN			!NO MODEL FILE GIVEN
	  CALL NMODAX(J)			!LET USER ACT
	ELSE
	  CALL NMOWRI(FCAAP,-1)			!WRITE SOURCE MODEL
	END IF
C
C READY
C
	CALL NCLHIX(MPHP,APHP)			!DELETE BEAM HISTO
	CALL WNGFVM(BMSIZ,BMPAD)		!RELEASE PATCH BUFFERS
	CALL WNGFVM(MPSIZ,MPPAD)
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'End')
	CALL WNCTXT(F_TP,' ')
C
	RETURN
C
C
	END

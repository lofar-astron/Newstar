C+ NCLUV.FOR
C  WNB 920103
C
C  Revisions:
C	WNB 920131	Error if no residual map asked
C	HjV 920520	HP does not allow extended source lines
C	WNB 921202	Cater for J2000
C	WNB 921222	Correct retore if no residual
C	WNB 930407	Correct noise for some restored maps
C	WNB 930928	Add instrument
C	JPH 940302	Comments
C
	SUBROUTINE NCLUV(MPHP,APHP)
C
C  Do cleaning using UV cover
C
C  Result:
C	CALL NCLUV( MPHP_J:I, APHP_J:I)
C				Do a Clark type clean, using the UV cover
C				to subtract the sources. MPHP and APHP are the
C				map and beam header pointers.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'MPH_O_DEF'	!MAP HEADER
	INCLUDE 'MDH_O_DEF'	!MODEL HEADER
	INCLUDE 'NCL_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MPHP		!MAP HEADER POINTER
	INTEGER APHP		!BEAM HEADER POINTER
C
C  Function references:
C
	LOGICAL WNGGVM		!GET VIRTUAL MEMORY
	LOGICAL WNFOP		!OPEN FILE
	LOGICAL WNFRD		!READ DISK
	LOGICAL WNFWR		!WRITE DISK
	CHARACTER*20 WNFFNM	!FILE NAME
	LOGICAL NMOSLG		!GET SOURCE SPACE
C
C  Data declarations:
C
	INTEGER RMPP		!RESIDUAL MAP POINTER
	INTEGER RSNAM(0:7)	!RESIDUAL SET NAME
	INTEGER BMSIZ,MPSIZ	!PATCH BUFFER SIZES
	INTEGER BMPAD,MPPAD	!PATCH BUFFER ADDRESSES
	INTEGER FCAUVT		!BEAM COVER FILE
	INTEGER FCATMP		!TEMP. FILE
	INTEGER FCARSD		!RESIDUAL FILE
	INTEGER FCAIN		!INPUT FILE SWITCH
	INTEGER DPTIN		!INPUT POINTER SWITCH
	REAL SUMGL		!GRATING LOBE SUM
	INTEGER MDHJ(0:MDHHDL/4-1) !MODEL HEADER
	  REAL MDHE(0:MDHHDL/4-1)
	  DOUBLE PRECISION MDHD(0:MDHHDL/8-1)
	  EQUIVALENCE (MDHJ,MDHE,MDHD)
	BYTE MPH(0:MPHHDL-1)	!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1)
	  INTEGER MPHJ(0:MPHHDL/4-1)
	  REAL MPHE(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	BYTE RMPH(0:MPHHDL-1)	!RESIDUAL MAP HEADER
	  INTEGER RMPHJ(0:MPHHDL/4-1)
	  REAL RMPHE(0:MPHHDL/4-1)
	  EQUIVALENCE (RMPH,RMPHJ,RMPHE)
	BYTE APH(0:MPHHDL-1)	!BEAM HEADER
	INTEGER RG(0:1)		!SOURCE RANGE
	  DATA RG/1,1000000/
C-
C
C INIT
C
	IF (.NOT.WNFRD(FCAMAP,MPHHDL,MPH,MPHP)) THEN !READ MAP HEADER
	  CALL WNCTXT(F_TP,'Error reading map header')
	  CALL WNGEX				!STOP
	END IF
	MINLIM=MAX(ABS(MPHE(MPH_MAX_E)),ABS(MPHE(MPH_MIN_E))) !SET MAP MAX
	IF (APHP.NE.0) THEN			!BEAM PRESENT
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,APH,APHP)) THEN !READ BEAM HEADER
	    CALL WNCTXT(F_TP,'Error reading beam header')
	    CALL WNGEX				!STOP
	  END IF
	ELSE					!NO BEAM
	  CALL WNGMV(MPHHDL,MPH,APH)		!MAKE SURE DATA PRESENT
	END IF
	FCARSD=FCAMAP				!ASSUME RESIDUAL IN MAP
	IF (.NOT.RONMDL) THEN			!NOT RESTORE ONLY
	  IF (.NOT.RESMDL) THEN			!RESIDUAL NOT ASKED
	    FCARSD=0				!NO RESIDUAL OPEN
	    IF (.NOT.WNFOP(FCARSD,WNFFNM('NCL','TMP'),'WT')) THEN
	      CALL WNCTXT(F_TP,'Cannot open temporary residual file')
	      CALL WNGEX			!STOP
	    END IF
	  END IF
	  CALL NCLCWR(FCARSD,MPH,RMPP,RSNAM)	!START RESIDUAL MAP
	  IF (.NOT.WNFRD(FCARSD,MPHHDL,RMPH,RMPP)) THEN !READ RESIDUAL HEADER
	    CALL WNCTXT(F_TP,'Error reading residual map header')
	    CALL WNGEX				!STOP
	  END IF
	END IF
	FCAIN=FCAMAP				!FIRST INPUT FROM MAP
	DPTIN=MPHJ(MPH_MDP_J)
C
C GET TEMPORARY FILE FOR TRANSPOSE
C
	IF (.NOT.WNFOP(FCATMP,WNFFNM('NCL','TMP'),'WT')) THEN
	  CALL WNCTXT(F_TP,'Cannot open temporary transpose file')
	  CALL WNGEX				!STOP
	END IF
C
	IF (RONMDL) GOTO 20			!RESTORE ONLY
C
C GET HISTOGRAMS AND PATCH DATA. NCLHID sets the COMMON variables
C  BEMPAT= beam patch size
C  MAPPAT= map patch size
C  MAPLIM= map data limit in patch
C
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'Histogramming')
	CALL NCLHID(MPHP,APHP)			!GET BEAM PATCH, SHOW HISTO
	CALL WNCTXT(F_P,'!^')
C
C GET BEAM COVER
C
	IF (.NOT.WNFOP(FCAUVT,WNFFNM('NCL','TMP'),'WT')) THEN
	  CALL WNCTXT(F_TP,'Cannot obtain UV cover file')
	  CALL WNGEX				!STOP
	END IF
	CALL WNCCSX(F_TP,'Beaming')
	CALL NCLUVT(FCATMP,FCAUVT,APH)		!transform beam back to UV COVER
C
C INIT SOURCE LIST
C
	CALL NMOHMF(7,MDHJ)			!GET HEADER 7
	CALL NMOHZD(MDHJ)			!CLEAR SOURCES
	MDHD(MDH_RA_D)=MPHD(MPH_RA_D)		!SET MAP RA
	MDHD(MDH_DEC_D)=MPHD(MPH_DEC_D)		!SET MAP DEC
	MDHD(MDH_FRQ_D)=MPHD(MPH_FRQ_D)		!SET MAP FREQ.
	IF (MPHI(MPH_EPT_I).EQ.1) THEN		!1950/2000 COORDINATES
	  MDHJ(MDH_TYP_J)=2			!EPOCH TYPE
	  MDHE(MDH_EPOCH_E)=MPHE(MPH_EPO_E)	!EPOCH
	ELSE					!APPARENT
	  MDHJ(MDH_TYP_J)=1			!EPOCH TYPE
	  MDHE(MDH_EPOCH_E)=0.			!EPOCH
	END IF
	MDHJ(MDH_BITS_J)=MPHJ(MPH_INST_J)	!SET INSTRUMENT
	IF (.NOT.NMOSLG(SRCLIM,MDHJ)) THEN	!GET AREA
	  CALL WNCTXT(F_TP,'No space for clean source list')
	  CALL WNGEX				!STOP
	END IF
C
C GET PATCH BUFFER using patch sizes defined bu NCLHID above
C The map points will be formatted as (l,m,flux)
C
 10	CONTINUE
	BMSIZ=LB_E*(2*BEMPAT+1)*(BEMPAT+1)	!BEAM BUFFER SIZE
	MPSIZ=(LB_E+2*LB_I)*MAPPAT		!MAP BUFFER SIZE
	JS=WNGGVM(BMSIZ,BMPAD)			!GET BEAM PATCH BUF
	IF (JS) JS=WNGGVM(MPSIZ,MPPAD)		!GET MAP POINT BUFFER
	IF (.NOT.JS) THEN
	  CALL WNCTXT(F_TP,'Cannot obtain beam and/or map patch buffers')
	  CALL WNGEX				!STOP
	END IF
	CALL WNCTXT(F_TP,'!/Beam patch of !UJ points, '//
	1		'!UJ mappoints down to !E10.3 W.U. (!E7.2%)!/',
	1		2*BEMPAT+1,MAPPAT,MAPLIM,100.*MAPLIM/MINLIM)
C
C READ DATA - The map pints are cast in the form (l,m,flux), the beam is left
C  in the standard array format with the Prussian-hat peak added
C The floowing COMMON variables are set:
C  MAPPAT	nr of pints in map patch
C  CURMAX	max. abs. value in patch
C  CURPMX	linear posn of maximum in patch
C
	CALL NCLCRD(FCAMAP,APH,A_B(BMPAD-A_OB),FCAIN,DPTIN,
	1		MPH,A_B(MPPAD-A_OB),A_B(MPPAD-A_OB)) !BEAM, MAP PATCH
C
C DO CLEAN
C
	CALL WNCCSX(F_TP,'Cleaning')
	J=MDHJ(MDH_NSRC_J)+1			!START SOURCE
	SUMGL=0					!START GRATING RESPONSE
	DO WHILE (CURMAX.GT.MAPLIM .AND.
	1		MDHJ(MDH_NSRC_J).LT.SRCLIM .AND.
	1		CURMAX.GE.SUMGL)
	  CALL NCLCCL(A_B(BMPAD-A_OB),A_B(MPPAD-A_OB),A_B(MPPAD-A_OB),
	1		J,MDHJ,MPH,SUMGL)	!CLEAN 1 point (1 minor cycle)
	END DO
C
C SHOW SOURCES
C
	CALL NMOHMT(MDHJ,7)			!SET HEADER 7
	CALL NMOAM2(7,J,MDHJ(MDH_NSRC_J))	!MERGE SOURCES
	CALL NMOPTI(F_TP,RG,7)			!SHOW TOTAL TILL NOW
C
C RELEASE PATCH BUFFERS
C
	CALL WNGFVM(BMSIZ,BMPAD)
	CALL WNGFVM(MPSIZ,MPPAD)
C
C CLEAN MAJOR CYCLE
C
	CALL NCLUCL(J,MDHJ(MDH_NSRC_J),FCATMP,FCAUVT,FCARSD,FCAIN,
	1		MDHJ,DPTIN,RMPP,RMPH,APH)
	FCAIN=FCARSD				!INPUT FROM RESIDUAL
	DPTIN=RMPHJ(MPH_MDP_J)
C
C RECYCLE
C
	CALL WNMHS7(MPHAD,I1,I2,MPHMXI,R0)	!GET HISTO DATA
	IF (MPHMXI.GT.CLLIM*MINLIM .AND. MDHJ(MDH_NSRC_J).LT.SRCLIM) THEN
	  CALL NCLHIE(RMPP,APHP)		!GET PATCH DATA
	  GOTO 10				!MORE TO DO
	END IF
C
C FINISH ALL
C
	CALL WNFCL(FCAUVT)			!CLOSE AND DELETE BEAM COVER
	CALL WNMHS3(MPHAD,1,F_P)		!SHOW RESIDUAL HISTO
	IF (RESMDL) THEN			!RESIDUAL WANTED
	  CALL WNCTXT(F_P,'!^')
	  CALL NMAPMH(F_TP,RMPH,RSNAM,NODMAP)	!SHOW RESIDUAL HEADER
	END IF
C
C FINISH SOURCE LIST
C
	CALL NMORDM(7,-1)			!ADD SOURCES TO GENERAL LIST
	CALL NMOAMG				!MERGE COMPONENTS
	CALL NMOPTT(F_TP,RG)			!SHOW TOTAL FLUX
	IF (FCAAP.EQ.0) THEN			!NO MODEL FILE GIVEN
	  CALL NMODAX(J)			!LET USER ACT
	ELSE
	  CALL NMOWRI(FCAAP,-1)			!WRITE SOURCE MODEL
	END IF
C
C RESTORE MAP
C
 20	CONTINUE
	IF (RSTMDL) THEN			!RESTORE MAP
	  CALL NMOHMF(-1,MDHJ)			!SOURCES
	  R0=RMPHE(MPH_NOS_E)			!KEEP RESIDUAL NOISE
	  CALL NCLCWR(FCAMAP,MPH,RMPP,RSNAM)	!START RESTORED MAP
	  IF (.NOT.WNFRD(FCAMAP,MPHHDL,RMPH,RMPP)) THEN !READ RESTORED HEADER
	    CALL WNCTXT(F_TP,'Error reading restored map header')
	    CALL WNGEX				!STOP
	  END IF
	  CALL WNCCSX(F_TP,'Restoring')
	  IF (.NOT.RONMDL) RMPHE(MPH_NOS_E)=R0 !SET PROPER NOISE
	  CALL NCLUCL(1,MDHJ(MDH_NSRC_J),FCATMP,0,FCAMAP,FCAIN,
	1		MDHJ,DPTIN,RMPP,RMPH,APH)
	  CALL WNCTXT(F_P,'!^')
	  CALL NMAPMH(F_TP,RMPH,RSNAM,NODMAP)	!SHOW RESIDUAL HEADER
	END IF
C
C READY
C
	IF (.NOT.RONMDL) THEN			!NOT RESTORE ONLY
	  CALL NCLHIX(MPHP,APHP)		!DELETE BEAM HISTO
	END IF
	IF (.NOT. RONMDL .AND. .NOT.RESMDL) THEN !NO RESIDUAL SAVE
	  CALL WNFCL(FCARSD)			!DELETE RESIDUAL
	END IF
	CALL WNFCL(FCATMP)			!CLOSE AND DELETE TEMP. FILE
	CALL WNCTXT(F_TP,' ')
	CALL WNCCSX(F_TP,'End')
	CALL WNCTXT(F_TP,' ')
C
	RETURN
C
C
	END

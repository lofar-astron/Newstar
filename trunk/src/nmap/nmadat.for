C+ NMADAT.FOR
C  WNB 910219
C
C  Revisions:
C	WNB 910822	Add FIDDLE
C	WNB 910826	Retain values
C	WNB 910911	Add NSUM
C	WNB 910912	Add other sums
C	WNB 910913	Change loops
C	WNB 911104	Add mosaic combine
C	WNB 920128	Prompt error node
C	WNB 920423	Natural taper default for BASHA
C	HjV 920520	HP does not allow extended source lines
C	WNB 920811	Add USE_NOISE
C	WNB 920812	Add loops for Fiddle sums
C	WNB 920817	Add circular weights
C	WNB 920818	Add Fits scale
C	WNB 921104	Full HA scale; J2000
C	WNB 921119	Add WRLFITS, CUBIC
C	WNB 921123	Nicer HA-range question
C	WNB 921201	Larger default memory use
C	WNB 921201	Prepare for Data clean: add NMADAC
C	WNB 921208	Data clean subtract
C	WNB 921216	Change clip for data clean
C	HjV 930423	Change name of some keywords
C	HjV 930525	Change MAPS_SETS into WMP_SETS 
C	WNB 930602	Add WGT_LIMIT
C	WNB/HjV 930621	Change of keywords was wrong for CVX
C	WNB 930711	Typo AREF
C	WNB 930824	New interferometer selection
C	WNB 930826	New HA selection; new Stokes calculation; beam factor
C	WNB 930929	Add Fiddle LOAD option
C	WNB 930930	Use Fiddle codes
C	CMV 931210	Add 'WMP/SCN_LOOPS' argument to WNDXLP
C	CMV 931220	Pass FCA of input file to WNDXLP and WNDSTA/Q
C	CMV 940110	Pass FCA for FIDDLE options (Close later)
C	CMV 940214	Default HA range -90,90 for WSRT, -180,180 for AT
C	CMV 940214	If NULL at FIELD_SIZE, ask GRID_SIZE
C	JPH 940221	Comments - NEW_VERSION: SCN_NODE --> WMP_NODE
C	CMV 940225      Enable default model file (use NMODAW)
C	CMV 940415	Open SCN file first with 'R' to prevent creation
C			of new file when non-existing one is specified
C	CMV 940418	Give warning if pointing centra differ to much
C	CMV 940422	Correct error in WNFOP for NVS (called for SCN)
C	CMV 940425	Define DWARF symbol PCDEC 
C       CMV 940517      Define DWARF symbol SD
C       HjV 940518	Add OLD_DATTYP
C	CMV 940530	Add creation of Job Summary Log
C       HjV 940714	Add RFITS, re-orden labels
C	CMV 940808	Add call to WNFMLI to list tape definitions
C	JPH 940923	Add WNDPOH calls for input data-set selection
C	JPH 940929	Add FIELD_CENTRE
C	JPH 941013	Comments. - Remove dead code, e.g. for wildcards on
C			 keywords that donot allow them
C			LCL --> CLEAN
C			HA_RESOLUTION in UT seconds i.s.o. ST
C       HjV 941027	Open file for answering WMP_SET_2
C       WNB 950817	Set POLTJ for pol. int. and cleaning
C	JPH 950911	Bug fix in FIELD_SHIFT: FIELD_CENTRE prompt conditional
C			 on NULL_VALUE status i.s.o FIELD_SHIFT=0,0
C	CMV 951127	Interface for CSUM and RSUM fiddle options
C	CMV 951204	Add RMVAL and (real) weights for RSUM
C       WNB 951212	Correct REF_COORD backtrack error (194)
C	CMV 960126	RA of REF_COORD always positive (193)
C	JPH 960402	HOLOG --> OLDHOLOG; synonym NEWHOLOG for WMP
C	CMV 030123	Corrected BYTE test for g77
C	CMV 061023	Added buffer size for large maps and too wide field
C
C
	SUBROUTINE NMADAT
C
C  Get NMAP program parameters
C
C  Result:
C
C	CALL NMADAT	will ask and set all program parameters
C	CALL NMADAC ( CMFCA_J:I, CMHP_J:I)
C			will ask and set all program
C			parameters for DATA type clean. CMHP points to
C			map header in CMFCA.
C
C  PIN references:
C
C	OPTION
C	FIDDLE_OPTION
C	SUM_OPTION
C	LOAD_OPTION
C	MEMORY_USE
C	MAP_FACTORS
C	SUM_FACTORS
C	CSUM_FACTORS
C	ROTATION_MEASURE
C	MAP_LEVEL
C	WMP_NODE
C	WMP_NODE_1
C	WMP_NODE_2
C	OUTPUT_UNIT
C	FILENAME
C	INPUT_FILE
C	WMP_SETS
C	WMP_SET_1
C	WMP_SET_2
C	OUTPUT_LABEL
C	CUBIC
C	USE_NOISE
C	WGT_LIMIT
C	LOOPS
C	QMAPS
C	QDATAS
C	SCN_NODE
C	SCN_SETS
C	USER_COMMENT
C	SELECT_IFRS
C	APPLY
C	DE_APPLY
C	MAP_POLAR
C	MAP_COORD
C	REF_COORD
C	UV_COORDINATES
C	HA_RESOLUTION
C	BAS_RESOLTUTION
C	IFR_RESOLUTION
C	USER_DATA
C	FT_SIZE
C	OUT_SIZE
C	OUT_CENTRE
C	LM_CENTRE
C	RADEC_CENTRE
C	FIELD_SIZE
C	GRID_SIZE
C	UNIFORM
C	TAPER
C	TAPER_VALUE
C	CWEIGHT_TYPE
C	CWEIGHT_VALUE
C	CONVOLVE
C	DECONVOLVE
C	UV_AREA
C	CLIPPING
C	CLIP_AREA
C	CLIP_LEVELS
C	FIELD_SHIFT
C	DATA_TYPE
C	FITS_SCALE
C	OUTPUT
C	OUTPUT_WMP_NODE
C	SUBTRACT
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'CBITS_DEF'
	INCLUDE 'STH_O_DEF'		!SET HEADER
	INCLUDE 'MPH_O_DEF'		!MAP HEADER
	INCLUDE 'NMA_DEF'
C
C  Parameters:
C
	INTEGER MXNPCD			!# OF POLARISATION CODES
	  PARAMETER (MXNPCD=18)		!KNOWN POL. CODES
	INTEGER I_ML,XX_PI,XY_PI,YX_PI,YY_PI,
	1		I_MI,Q_MI,U_MI,V_MI,I_MLI !SPECIAL CODES
	  PARAMETER (I_ML=I_M+LINE_P,XX_PI=XX_P+IMAG_P,
	1		XY_PI=XY_P+IMAG_P,YX_PI=YX_P+IMAG_P,
	1		YY_PI=YY_P+IMAG_P,I_MI=I_M+IMAG_P,
	1		Q_MI=Q_M+IMAG_P,U_MI=U_M+IMAG_P,
	1		V_MI=V_M+IMAG_P,I_MLI=I_M+IMAG_P+LINE_P)
C
C  Arguments:
C
	INTEGER CMFCA			!CLEAN MAP FILE
	INTEGER CMHP			!POINTER TO MAP HEADER
C
C  Function references:
C
	DOUBLE PRECISION WNGDPF,WNGDNF	!NORMALISE ANGLE
	DOUBLE PRECISION WNGDPD,WNGDND	!NORMALISE ANGLE
	REAL WNGEDF,WNGEFR		!CONVERT ANGLE
	DOUBLE PRECISION WNGDDF,WNGDFD
	LOGICAL WNDPAR			!GET DWARF PARAMETER
	LOGICAL WNDNOD			!GET NODE NAME
	LOGICAL WNDNOC			!CHANGE TO NODE TO 'UPDATE'
	LOGICAL WNDXLP,WNDXL1		!GET LOOP PARAMETERS
	LOGICAL WNFOP			!OPEN FILE
	LOGICAL WNFRD			!READ FILE
	LOGICAL WNFMOU			!MOUNT TAPE
	CHARACTER*80 WNFTVL		!GET TAPE VOLUME
	INTEGER WNMEJC			!CEIL(X)
	LOGICAL WNDSTQ			!GET SETS TO DO
        CHARACTER*32 WNTTSG             !GET SET NAME
	LOGICAL NSCIF1			!INTERFEROMETER SELECTION
	LOGICAL NSCSTG			!READ A SET
	LOGICAL NSCHAS			!SELECT HA
	LOGICAL NMOBMR			!GET BEAM DATA
C
C  Data declarations:
C
	INTEGER FCAIN			!INPUT FCA
	INTEGER SETNAM(0:7)		!SET NAME
	INTEGER STHP			!STH POINTER
	INTEGER CIFR			!CHECK IFRS
	LOGICAL CLEAN			! IN CLEAN
	CHARACTER*80 TXT		! prompt buffer
	CHARACTER*80 VOLHD		!TAPE VOLUME HEADER
	CHARACTER*80 C1,CEP
	CHARACTER*8 C2(8)
	CHARACTER*24 SUBOPT		!SUB-OPTION
	  CHARACTER*3 SUBOP3
	  EQUIVALENCE (SUBOPT,SUBOP3)
	REAL*8 FRA,FDEC			!First apparent RA,DEC
	INTEGER FINST			!First instrument
	CHARACTER*25 PCDEC		!Define DWARF symbol
	INTEGER NSRC(0:2)		!# OF SOURCES IN MODEL
	CHARACTER*4 PCD(MXNPCD)		!KNOWN POL. CODES
	  DATA PCD/'XX','XY','YX','YY','I','Q','U','V','L',
	1		'XXI','XYI','YXI','YYI','II','QI','UI','VI','LI'/
	REAL PCDT(MXNPCD)		!TABLE TO SET (IMAG, N, XX,XY,YX,YY)
	  DATA PCDT(1) /XX_P/		!XX
	  DATA PCDT(2) /XY_P/		!XY
	  DATA PCDT(3) /YX_P/		!YX
	  DATA PCDT(4) /YY_P/		!YY
	  DATA PCDT(5) /I_M/		!I
	  DATA PCDT(6) /Q_M/		!Q
	  DATA PCDT(7) /U_M/		!U
	  DATA PCDT(8) /V_M/		!V
	  DATA PCDT(9) /I_ML/		!L
	  DATA PCDT(10) /XX_PI/		!XXI
	  DATA PCDT(11) /XY_PI/		!XYI
	  DATA PCDT(12) /YX_PI/		!YXI
	  DATA PCDT(13) /YY_PI/		!YYI
	  DATA PCDT(14) /I_MI/		!II
	  DATA PCDT(15) /Q_MI/		!QI
	  DATA PCDT(16) /U_MI/		!UI
	  DATA PCDT(17) /V_MI/		!VI
	  DATA PCDT(18) /I_MLI/		!LI
	BYTE MPH(0:MPHHDL-1)			!MAP HEADER
	  INTEGER*2 MPHI(0:MPHHDL/2-1)
	  INTEGER MPHJ(0:MPHHDL/4-1)
	  REAL MPHE(0:MPHHDL/4-1)
	  DOUBLE PRECISION MPHD(0:MPHHDL/8-1)
	  EQUIVALENCE (MPH,MPHI,MPHJ,MPHE,MPHD)
	BYTE STH(0:STH__L-1)			!SET HEADER
	  INTEGER STHJ(0:STH__L/LB_J-1)
	  REAL*8 STHD(0:STH__L/LB_D-1)
	  EQUIVALENCE (STH,STHJ,STHD)
	BYTE BB1
C-
C
C MAPDAT
C
	CLEAN=.FALSE.				! NOT DAC
	GOTO 300
C
C MAPDAC
C
	ENTRY NMADAC(CMFCA,CMHP)
C
	CLEAN=.TRUE.				! DAC
	OPTION='CLEAN'				!OPTION TO DO
	IF (.NOT.WNFRD(CMFCA,MPHHDL,MPH,CMHP)) THEN !READ CLEAN MAP HEADER
	  CALL WNCTXT(F_TP,'Error reading clean map header')
	  CALL WNGEX				!STOP
	END IF
	GOTO 300
C
C SET DEFAULTS
C
 300	CONTINUE
	IF (OPT.EQ.'FID') GOTO 60		!ALREADY IN FIDDLE
	MEMSIZ=200000
	NODOUT=' '
	FILIN(1)='""'
	FILIN(2)='*'
	DO I=1,MXNFIL
	  SETS(0,0,I)=0
	  NODIN(I)=' '
	END DO
	IUNIT='D'
	OUNIT='D'
	OLABEL=-1
	MAPCRD(0)=-1000
	HA(0,1)=-179.99/360.
	HA(1,1)=+179.99/360.
	CIFR=3
	FTSIZ(0)=-1
	FIELD(0)=-100
	SUB=.FALSE.
!!	POLC(0)='XX'
	CEP='B1950'
C
C GET OPTION
C
 100	CONTINUE
	IF (CLEAN) THEN				!NMADAC call from NCLEAN
	  OPTION='CLEAN'			! no need to prompt
	ELSE
	  IF (.NOT.WNDPAR('OPTION',OPTION,LEN(OPTION),J0,'QUIT')) THEN
	    OPTION='QUIT'			!ASSUME END
	  ELSE IF (J0.LE.0) THEN
	    OPTION='QUIT'			!ASSUME END
	  END IF
	END IF
	IF (OPT.EQ.'QUI') RETURN		!READY
C
C GET MEMORY SIZE AND BEAM FACTORS
C
	IF (.NOT.WNDPAR('MEMORY_USE',MEMSIZ,LB_J,J0,
	1		A_B(-A_OB),MEMSIZ,1)) THEN
	  MEMSIZ=200000				!ASSUME VALUE
	ELSE IF (J0.LE.0) THEN
	  MEMSIZ=200000				!ASSUME VALUE
	END IF
	MEMSIZ=4*MEMSIZ				!Allow large fields-wnb061023
 50	CONTINUE
	IF (.NOT.NMOBMR()) GOTO 50		!MUST SPECIFY
C
C CONVERT VAX TO LOCAL
C
 60	CONTINUE
	IF (OPT.EQ.'CVX') THEN
 61	  CONTINUE
	  IF (.NOT.WNDNOD('WMP_NODE',NODOUT,'WMP',
	1		'R',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 61				!REPEAT
	  ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	    GOTO 100				!RETRY OPTION
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	    GOTO 61				!MUST SPECIFY
	  END IF
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'U')) THEN !OPEN OUTPUT MAP FILE
	    GOTO 61				!RETRY
	  END IF
C
C CONVERT TO NEWEST VERSION
C
	ELSE IF (OPT.EQ.'NVS') THEN
 70	  CONTINUE
	  IF (.NOT.WNDNOD('WMP_NODE',NODOUT,'WMP',
	1		'R',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 70				!REPEAT
	  ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	    GOTO 100				!RETRY OPTION
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	    GOTO 70				!MUST SPECIFY
	  END IF
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'U')) THEN !OPEN OUTPUT MAP FILE
	    GOTO 70				!RETRY
	  END IF
C
C FROM OLD FORMAT
C
	ELSE IF (OPT.EQ.'FRO') THEN
 80	  CONTINUE
	  IF (.NOT.WNDPAR('INPUT_FILE',FILIN(1),LEN(FILIN(1)),J0,
	1			FILIN(1))) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 80				!RETRY
	  END IF
	  IF (J0.EQ.0) GOTO 100			!RETRY OPTION
	  IF (J0.LT.0) GOTO 80			!MUST SPECIFY
	  IF (.NOT.WNFOP(FCATAP,FILIN(1),'R')) THEN !NO SUCH FILE
	    CALL WNCTXT(F_TP,'Cannot find file !AS',FILIN(1))
	    GOTO 80				!RETRY
	  END IF
	  CALL WNFCL(FCATAP)			!CLOSE FILE
	  IF (.NOT.WNDPAR('OLD_DATTYP',DATTYP,LB_J,J0,'0')) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 80				!RETRY
	  END IF
	  IF (J0.EQ.0) GOTO 100			!RETRY OPTION
	  IF (J0.LT.0) GOTO 80			!MUST SPECIFY
 81	  CONTINUE
	  IF (.NOT.WNDNOD('OUTPUT_WMP_NODE',NODOUT,'WMP',
	1		'U',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 80	!RETRY FILE
	    GOTO 81				!REPEAT
	  END IF
	  IF (J0.EQ.0) GOTO 80			!RETRY INPUT
	  IF (J0.LT.0) GOTO 81			!MUST SPECIFY
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'U')) THEN !OPEN MAP FILE
	    GOTO 81				!RETRY
	  END IF
C
C TO OLD FORMAT
C
	ELSE IF (OPT.EQ.'TO_') THEN
 90	  CONTINUE
	  IF (.NOT.WNDPAR('FILENAME',FILIN(1),LEN(FILIN(1)),J0,
	1			FILIN(1))) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 90				!RETRY
	  END IF
	  IF (J0.EQ.0) GOTO 100			!RETRY OPTION
	  IF (J0.LT.0) GOTO 90			!MUST SPECIFY
 91	  CONTINUE
	  IF (.NOT.WNDNOD('INPUT_WMP_NODE',NODOUT,'WMP',
	1		'R',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 90	!RETRY FILE
	    GOTO 91				!REPEAT
	  END IF
	  IF (J0.EQ.0) GOTO 90			!RETRY INPUT
	  IF (J0.LT.0) GOTO 91			!MUST SPECIFY
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'R')) THEN !OPEN MAP FILE
	    GOTO 81				!RETRY
	  END IF
	  IF (.NOT.WNDSTQ('WMP_SETS',MXNSET,SETS(0,0,1),FCAOUT)) THEN !MAPS TO DO
	    GOTO 90				!RETRY FILE
	  END IF
C
C READ FITS
C
	ELSE IF (OPT.EQ.'RFI') THEN
 110	  CONTINUE
          IF (.NOT.WNDPAR('INPUT_UNIT',IUNIT,LEN(IUNIT),J0,IUNIT)) THEN !GET UNIT
            IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100  !RETRY OPTION
            GOTO 110                            !REPEAT
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN	!LIST TAPEUNITS AND RETRY
	    CALL WNFMLI()
	    GOTO 110
          ELSE IF (J0.EQ.0) THEN
            GOTO 100                            !RETRY OPTION
          ELSE IF (J0.LT.0) THEN
            GOTO 110                            !MUST SPECIFY
          END IF
          IF (IUNIT.EQ.'D') THEN                 !DISK INPUT
 111	    CONTINUE
            IF (.NOT.WNDPAR('INPUT_FILE',FILIN(1),LEN(FILIN(1)),
	1	 	J0,FILIN(1))) THEN
              IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 110 !RETRY UNIT
              GOTO 111                          !REPEAT
            ELSE IF (J0.EQ.0) THEN
              GOTO 110                          !RETRY UNIT
            ELSE IF (J0.LT.0) THEN
              GOTO 111                          !MUST SPECIFY
            END IF
          ELSE                                  !TAPE INPUT
            IF (.NOT.WNFMOU(FCATAP,IUNIT,'R')) THEN !MOUNT TAPE
              CALL WNCTXT(F_TP,'Cannot mount tape on unit !AS (!XJ)',
	1	    	IUNIT,E_C)
              GOTO 110                          !RETRY UNIT
            END IF
            VOLHD=WNFTVL(FCATAP)                !GET VOLUME HEADER
            IF (VOLHD(1:4).EQ.'VOL1') THEN
              CALL WNCTXT(F_TP,'!/Volume !AS mounted on unit !AS!/',
	1	    	VOLHD(5:10),IUNIT)
            ELSE
              CALL WNCTXT(F_TP,'!/Unlabeled tape mounted on unit !AS!/',
	1	    	IUNIT)
            END IF
          END IF
 112	  CONTINUE
          IF (IUNIT.EQ.'D') ILAB(1)=1		!Correct default for disk label
          IF (.NOT.WNDPAR('INPUT_LABELS',ILAB,MXNLAB*LB_J,
	1      			NLAB,'*')) THEN
            IF (E_C.EQ.DWC_ENDOFLOOP) THEN      !RETRY OPTION
              ILAB(1)=0				!NOT SPECIFIED
            ELSE
              GOTO 112                          !RETRY
            END IF
          END IF
 113	  CONTINUE
	  IF (.NOT.WNDNOD('OUTPUT_WMP_NODE',NODOUT,'WMP',
	1      			'U',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 80	!RETRY FILE
	    GOTO 113				!REPEAT
	  ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	    GOTO 100				!RETRY OUTPUT
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	    GOTO 113				!MUST SPECIFY
	  END IF
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'U')) THEN !OPEN MAP FILE
	    GOTO 113				!RETRY
	  END IF
C
C MAKE FITS
C
	ELSE IF (OPT.EQ.'W16' .OR. OPT.EQ.'W32' .OR. OPT.EQ.'WRL') THEN
 120	  CONTINUE
	  IF (.NOT.WNDNOD('INPUT_WMP_NODE',NODOUT,'WMP',
	1		'R',NODOUT,FILOUT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100	!RETRY OPTION
	    GOTO 120				!REPEAT
	  END IF
	  IF (J0.EQ.0) GOTO 100			!RETRY OPTION
	  IF (J0.LT.0) GOTO 120			!MUST SPECIFY
	  IF (.NOT.WNFOP(FCAOUT,FILOUT,'R')) THEN !OPEN MAP FILE
	    GOTO 120				!RETRY
	  END IF
	  IF (.NOT.WNDSTQ('WMP_SETS',MXNSET,SETS(0,0,1),FCAOUT)) THEN !MAPS TO DO
	    GOTO 120				!RETRY FILE
	  END IF
	  IF (.NOT.WNDPAR('CUBIC',BB1,LB_B,J0,'NO')) GOTO 120
	  IF (J0.EQ.0) GOTO 120			!RETRY INPUTS
	  IF (J0.LT.0) BB1=.FALSE.		!ASSUME NO
	  IF (BB1) THEN
	    POLT(0,0)=1
	  ELSE
	    POLT(0,0)=0				!INDICATE NOT WANTED
	  END IF
 122	  CONTINUE
	  IF (.NOT.WNDPAR('OUTPUT_UNIT',OUNIT,LEN(OUNIT),J0,OUNIT)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 120	!RETRY FILE
	    GOTO 122				!REPEAT
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN	!LIST TAPEUNITS AND RETRY
	    CALL WNFMLI()
	    GOTO 122
	  END IF
	  IF (J0.EQ.0) GOTO 120			!RETRY
	  IF (J0.LT.0) OUNIT='D'		!ASSUME DISK
 124	  CONTINUE
	  IF (.NOT.WNDPAR('FITS_SCALE',SUBOPT,
	1		LEN(SUBOPT),J0,'JY')) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 120	!RETRY FILE
	    GOTO 124				!RETRY
	  END IF
	  IF (J0.LT.0) GOTO 124			!MUST SPECIFY
	  IF (J0.LE.0) SUBOPT='JY'
	  IF (SUBOPT.EQ.'JY') THEN
	    CWGVAL=200.				!SCALE
	  ELSE
	    CWGVAL=1.
	  END IF
 126	  CONTINUE
	  IF (OUNIT.EQ.'D') THEN
	    IF (.NOT.WNDPAR('FILENAME',FILIN(1),LEN(FILIN(1)),J0,
	1			FILIN(1))) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 120	!RETRY FILE
	      GOTO 126				!RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 120		!RETRY FILE
	    IF (J0.LT.0) GOTO 126		!MUST SPECIFY
	  ELSE
	    IF (.NOT.WNFMOU(FCATAP,OUNIT,'W')) THEN
	      CALL WNCTXT(F_TP,'Cannot mount tape')
	      GOTO 126
	    END IF
	    VOLHD=WNFTVL(FCATAP)		!GET VOLUME HEADER
	    IF (VOLHD(1:4).EQ.'VOL1') THEN
	      CALL WNCTXT(F_TP,'!/Volume !AS mounted on unit !AS!/',
	1			VOLHD(5:10),OUNIT)
	    ELSE
	      CALL WNCTXT(F_TP,'!/Unlabeled tape mounted on unit !AS!/',
	1			OUNIT)
	    END IF
	  END IF
 128	  CONTINUE
	  IF (OLABEL.LT.0) THEN
	    JS=WNDPAR('OUTPUT_LABEL',OLABEL,LB_J,J0,'*')
	  ELSE
	    JS=WNDPAR('OUTPUT_LABEL',OLABEL,LB_J,J0,
	1		A_B(-A_OB),OLABEL,1)
	  END IF
	  IF (.NOT.JS) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 120	!RETRY FILE
	    GOTO 128				!RETRY
	  END IF
	  IF (J0.EQ.0) GOTO 120			!RETRY FILE
	  IF (J0.LT.0) OLABEL=-1		!SET AT END
C
C FIDDLE
C
	ELSE IF (OPT.EQ.'FID') THEN
 200	  CONTINUE
	  IF (.NOT.WNDPAR('FIDDLE_OPTION',SUBOPT,
	1		LEN(SUBOPT),J0,'QUIT')) THEN
	    SUBOPT='QUIT'			!ASSUME END
	  ELSE IF (J0.LE.0) THEN
	    SUBOPT='QUIT'			!ASSUME END
	  END IF
	  IF (SUBOP3.EQ.'ADD') THEN		!SET CODES
	    DATTYP=FID_ADD
	  ELSE IF (SUBOP3.EQ.'AVE') THEN
	    DATTYP=FID_AVE
	  ELSE IF (SUBOP3.EQ.'POL') THEN
	    DATTYP=FID_POL
	  ELSE IF (SUBOP3.EQ.'ANG') THEN
	    DATTYP=FID_ANG
	  ELSE IF (SUBOP3.EQ.'CSU') THEN
	    DATTYP=FID_CSU
	  ELSE IF (SUBOP3.EQ.'RSU') THEN
	    DATTYP=FID_RSU
	  ELSE IF (SUBOP3.EQ.'SUM') THEN
	    IF (.NOT.WNDPAR('SUM_OPTION',SUBOPT,
	1		LEN(SUBOPT),J0,'QUIT')) THEN
	      SUBOPT='QUIT'			!ASSUME END
	    ELSE IF (J0.LE.0) THEN
	      SUBOPT='QUIT'			!ASSUME END
	    END IF
	    IF (SUBOP3.EQ.'SUM') THEN
	      DATTYP=FID_SUM
	    ELSE IF (SUBOP3.EQ.'NSU') THEN
	      DATTYP=FID_NSU
	    ELSE IF (SUBOP3.EQ.'BSU') THEN
	      DATTYP=FID_BSU
	    ELSE IF (SUBOP3.EQ.'BNS') THEN
	      DATTYP=FID_BNS
	    ELSE IF (SUBOP3.EQ.'FSU') THEN
	      DATTYP=FID_FSU
	    ELSE IF (SUBOP3.EQ.'NSS') THEN
	      DATTYP=FID_NSS
	    ELSE
	      DATTYP=FID_DUM
	      RETURN
	    END IF
	  ELSE IF (SUBOP3.EQ.'LOA') THEN
	    IF (.NOT.WNDPAR('LOAD_OPTION',SUBOPT,
	1		LEN(SUBOPT),J0,'QUIT')) THEN
	      SUBOPT='QUIT'			!ASSUME END
	    ELSE IF (J0.LE.0) THEN
	      SUBOPT='QUIT'			!ASSUME END
	    END IF
	    IF (SUBOP3.EQ.'OLD') THEN
	      DATTYP=FID_RHO
	    ELSE IF (SUBOP3.EQ.'WMP') THEN
	      DATTYP=FID_WMP
	    ELSE IF (SUBOP3.EQ.'NEW') THEN
	      DATTYP=FID_WMP
	      CALL WNCTXT(F_T,
	1 '!/ NOTE: The following prompts will be in error:!/' //
	1 '!4C For WMP_NODE_2 give the name of an OUTPUT .WMP file!/' //
	1 '!6C in which the map will be stored.!/' //
	1 '!4C For OUTPUT_FILE, give the name plus extension of the!/' //
	1 '!6C binary input file. !/!/' )
	    ELSE IF (SUBOP3.EQ.'UNL') THEN
	      DATTYP=FID_UNL
	    ELSE
	      DATTYP=FID_DUM
	      RETURN
	    END IF
	  ELSE IF (SUBOP3.EQ.'EXT') THEN
	    DATTYP=FID_EXT
	  ELSE IF (SUBOP3.EQ.'COP') THEN
	    DATTYP=FID_COP
	  ELSE IF (SUBOP3.EQ.'BEA') THEN
	    DATTYP=FID_BEA
	  ELSE IF (SUBOP3.EQ.'DEB') THEN
	    DATTYP=FID_DEB
	  ELSE IF (SUBOP3.EQ.'FAC') THEN
	    DATTYP=FID_FAC
	  ELSE IF (SUBOP3.EQ.'MOS') THEN
	    DATTYP=FID_MOS
	  ELSE
	    DATTYP=FID_DUM			!INDICATE END
	    RETURN				!READY
	  END IF
 201	  CONTINUE
	  IF (DATTYP.LT.FID_RHO .OR. 
	1	DATTYP.GE.FID_UNL) THEN		! NOT LOAD
	    IF (.NOT.WNDNOD('WMP_NODE_1',NODIN(1),'WMP',
	1	'R',NODIN(1),FILIN(1))) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 200! RETRY OUTPUT
	      GOTO 201				! REPEAT
	    ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	      GOTO 200				! RETRY OUTPUT
	    ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	      GOTO 201				! MUST SPECIFY
	    END IF
	    IF (.NOT.WNFOP(FCAOUT,FILIN(1),'R'))
	1	 GOTO 201 			! OPEN OUTPUT FILE
	  END IF
	  IF (DATTYP.GE.FID_SUM .AND.
	1	DATTYP.LT.FID_EXT) THEN		! LOOPS
	    IF (.NOT.WNDXLP('WMP_LOOPS',FCAOUT))
	1	 GOTO 201			! GET LOOPS, RETRY FILE
	  END IF
	  IF (DATTYP.LT.FID_RHO .OR. 
	1	DATTYP.GE.FID_UNL) THEN 	! NOT LOAD
	    IF (.NOT.WNDSTQ('WMP_SET_1',MXNSET,
	1	SETS(0,0,1),FCAOUT)) THEN 	! MAPS TO USE
	      CALL WNFCL(FCAOUT)
	      GOTO 201				! RETRY FILE
	    END IF
	    CALL WNFCL(FCAOUT)
	    IF (SETS(0,0,1).LE.0) GOTO 201	! NONE SPECIFIED
	  END IF
 202	  CONTINUE
	  IF (DATTYP.LT.FID_SUM .OR.
	1	(DATTYP.GE.FID_EXT .AND. DATTYP.LT.FID_BEA) .OR.
	1	(DATTYP.GE.FID_MOS .AND. DATTYP.LT.FID_UNL))
	1			THEN		! SECOND FILE
	    IF (DATTYP.GE.FID_RHO .AND. 
	1	FILIN(2).EQ.'*') THEN 		! ONLY OUTPUT
	      JS=WNDNOD('WMP_NODE_2',' ','WMP',
	1		'U',NODIN(2),FILIN(2))
	    ELSE IF (FILIN(2).EQ.'*') THEN
	      JS=WNDNOD('WMP_NODE_2','*','WMP',
	1		'U',NODIN(2),FILIN(2))
	    ELSE
	      JS=WNDNOD('WMP_NODE_2',NODIN(2),
	1		'WMP','U',NODIN(2),FILIN(2))
	    END IF
	    IF (.NOT.JS) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 200! RETRY OUTPUT
	      GOTO 202				! REPEAT
	    ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	      GOTO 200				! RETRY OUTPUT
	    ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	      IF (DATTYP.GE.FID_RHO) GOTO 200	! LOAD
	      FILIN(2)='*'			! INDICATE SAME
	      NODIN(2)=NODIN(1)
	    END IF
	    IF (FILIN(2).NE.'*') THEN
	      IF (.NOT.WNFOP(FCAOUT,FILIN(2),'U')) GOTO 202 !OPEN OUTPUT FILE
	      CALL WNFCL(FCAOUT)
	    END IF
	  END IF
	  IF (DATTYP.LT.FID_SUM) THEN
	    IF (FILIN(2).NE.'*') THEN
	      IF (.NOT.WNFOP(FCAOUT,FILIN(2),'U')) GOTO 202 !OPEN OUTPUT FILE
	    ELSE
	      IF (.NOT.WNFOP(FCAOUT,FILIN(1),'U')) GOTO 202 !OPEN OUTPUT FILE
	    END IF
	    IF (.NOT.WNDSTQ('WMP_SET_2',MXNSET,SETS(0,0,2),FCAOUT)) THEN !MAPS TO USE
	      GOTO 201				!RETRY FILE
	    END IF
	    CALL WNFCL(FCAOUT)
	    IF (SETS(0,0,2).LE.0) GOTO 202	!NONE SPECIFIED
	  END IF
 203	  CONTINUE
	  JS=.TRUE.				!ASSUME
	  J0=1
	  IF (DATTYP.EQ.FID_ADD) THEN
	    JS=WNDPAR('MAP_FACTORS',POLT(0,0),2*LB_E,J0,'1.,-1.')
	  ELSE IF (DATTYP.EQ.FID_AVE) THEN
	    JS=WNDPAR('MAP_FACTORS',POLT(0,0),2*LB_E,J0,'1.,1.')
	  ELSE IF (DATTYP.EQ.FID_FAC) THEN
	    JS=WNDPAR('MAP_FACTORS',POLT(0,0),2*LB_E,J0,'1.,0.')
	  ELSE IF (DATTYP.EQ.FID_POL .OR. DATTYP.EQ.FID_ANG) THEN
	    JS=WNDPAR('MAP_LEVEL',POLT(0,0),LB_E,J0,'1.')
	  ELSE IF (DATTYP.EQ.FID_FSU) THEN
	    JS=WNDPAR('SUM_FACTORS',POLT(-2,0),8*LB_E,J0,'1.')
	  ELSE IF (DATTYP.EQ.FID_CSU) THEN
	    JS=WNDPAR('CSUM_FACTORS',POLT(-2,0),16*LB_E,J0,'1.')
	  ELSE IF (DATTYP.EQ.FID_RSU) THEN
	    JS=WNDPAR('SUM_FACTORS',POLT(-2,0),8*LB_E,J0,'1.')
	    JS=WNDPAR('ROTATION_MEASURE',
	1		RMVAL,MXRMVAL*LB_E,NLAB,'0.')
	  END IF
	  IF (.NOT.JS) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 200
	    GOTO 203
	  END IF
	  IF (J0.EQ.0) GOTO 200
	  IF (J0.LT.0) GOTO 203
	  IF (DATTYP.EQ.FID_FSU.OR.DATTYP.EQ.FID_RSU) THEN !FILL FACTORS
	    DO I=J0,7
	      POLT(-2+I,0)=POLT(-2+MOD(I,J0),0)
	    END DO
	  END IF
	  IF (DATTYP.EQ.FID_CSU) THEN			!FILL FACTORS
	    DO I=J0,15
	      POLT(-2+I,0)=POLT(-2+MOD(I,J0),0)
	    END DO
	  END IF
	  IF (DATTYP.GE.FID_MOS .AND. DATTYP.LT.FID_RHO) THEN !MOSAIC COMBINE
	    IF (.NOT.WNDPAR('USE_NOISE',BB1,LB_B,J0,'NO')) GOTO 200
	    IF (J0.EQ.0) GOTO 200			!RETRY OUTPUTS
	    IF (J0.LT.0) BB1=.FALSE.			!ASSUME NO
	    IF (BB1) THEN
	      POLT(0,0)=1
	    ELSE
	      POLT(0,0)=0				!INDICATE NOT WANTED
	    END IF
	    IF (.NOT.WNDPAR('WGT_LIMIT',POLT(1,0),LB_E,J0,'0.1')) GOTO 200
	    IF (J0.EQ.0) GOTO 200			!RETRY OUTPUTS
	    IF (J0.LT.0) POLT(1,0)=0.05			!DEFAULT WEIGHT LIMIT
	    IF (FTSIZ(0).EQ.-1) THEN			!MAKE DEFAULTS
	      DO I=0,1
		OUTSIZ(I)=1024				!SIZE
		FTSIZ(I)=0				!CENTRE
	      END DO
	    END IF
	    IF (.NOT.WNDPAR('OUT_SIZE',OUTSIZ,2*LB_J,J0,A_B(-A_OB),
	1			OUTSIZ,2)) GOTO 200	!OUTPUT SIZE
	    IF (J0.LT.2) GOTO 200
	    DO I=0,1
	      OUTSIZ(I)=MAX(16,2*((OUTSIZ(I)+1)/2))	!MAKE EVEN
	    END DO
	    IF (.NOT.WNDPAR('OUT_CENTRE',FTSIZ,2*LB_J,J0,A_B(-A_OB),
	1			FTSIZ,2)) GOTO 200	!OUTPUT CENTRE
	    DATTYP=FID_MOS					!ASSUME PIXELS
	    IF (J0.EQ.-1) THEN				!TRY LM
	      IF (.NOT.WNDPAR('LM_CENTRE',CNTDVL,2*LB_D,J0,'*'))
	1			GOTO 200		!OUTPUT CENTRE
	      DATTYP=FID_LMM				!ASSUME LM
	      IF (J0.EQ.-1) THEN			!TRY RADEC
	        IF (.NOT.WNDPAR('RADEC_CENTRE',CNTDVL,2*LB_D,J0,'*'))
	1			GOTO 200		!OUTPUT CENTRE
	        DATTYP=FID_RAM				!ASSUME RADEC
		CNTDVL(0)=CNTDVL(0)/360.		!MAKE CIRCLES
	        CNTDVL(1)=CNTDVL(1)/360.
	      END IF
	    END IF
	    IF (J0.LT.2) GOTO 200
	  END IF
C
C MAKE MAP - 'CLE'an is the option for entry point NMADAC,
C  which also set CLEAN true
C
	ELSE IF (OPT.EQ.'MAK' .OR. OPT.EQ.'CLE') THEN
C
C LOOPS
C
 800	  CONTINUE
	  CALL WNCTXT(F_T,
	1'!/!4C\You may select up to !UJ input data sets!/
	1   !8C\(node, sectors, HA range, interferometers)!/',
	1	MXNFIL)
	  IF (CLEAN) THEN				!NO LOOP
	    IF (.NOT.WNDXL1()) GOTO 100		!INIT NO LOOP
	  ELSE
	    CALL WNDPOH(
	1'Loop specifications for all data sets: nr of cycles, index increment
	1 per cycle',' ',' ')
	    IF (.NOT.WNDXLP('SCN_LOOPS',0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 100 !RETRY OPTION
	      GOTO 800				!REPEAT
	    END IF
	  END IF
C
C INPUT SPECIFICATIONS
C
 810	  CONTINUE
	  NFILE=0
 210	  CONTINUE
	  CALL WNCTXT(F_T,' ')
	  CALL WNCTXS(TXT,
	1	'Node for data set #!UJ (null if no more)',NFILE+1)
	  CALL WNDPOH(TXT,' ',' ')
	  IF (.NOT.WNDNOD('SCN_NODE',NODIN(NFILE+1),'SCN',
	1	'R',NODIN(NFILE+1),
	1	FILIN(NFILE+1))) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 800	!RETRY LOOPS
	    GOTO 210				!REPEAT
	  ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	    GOTO 220				!NO MORE INPUT
	  ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	    GOTO 210				!MUST SPECIFY
	  END IF
C
C	Change mode to 'U': we might want to subtract a model
C
	  IF (.NOT.WNDNOC(' ',' ','SCN','U',' ',FILIN(NFILE+1))) THEN
	     IF (.NOT.WNFOP(FCAIN,FILIN(NFILE+1),'R')) GOTO 210 !OPEN INPUT
	  ELSE
	     IF (.NOT.WNFOP(FCAIN,FILIN(NFILE+1),'U')) GOTO 210 !OPEN INPUT
	  END IF
C
	  CALL WNCTXS(TXT,'Sector sets for data set #!UJ',NFILE+1)
	  CALL WNDPOH(TXT,' ',' ')
	  IF (.NOT.WNDSTQ('SCN_SETS',MXNSET,SETS(0,0,NFILE+1),FCAIN)) THEN
 213	    CONTINUE
	    CALL WNFCL(FCAIN)			!CLOSE FOR NOW
	    GOTO 210				!RETRY FILE
	  END IF
	  IF (NFILE.EQ.0) THEN
	    IF (.NOT.NSCSTG(FCAIN,SETS,STH,STHP,SETNAM)) GOTO 213 !FIND A SET
            CALL WNDSTR(FCAIN,SETS)             !RESET SET SEARCH
	    FRA=STHD(STH_RA_D)			!First set of first file
	    FDEC=STHD(STH_DEC_D)
	    FINST=STHJ(STH_INST_J)
            CALL WNCTXS(PCDEC,'!DAF9.4',FDEC)   !WRITE IN STRING
            CALL WNDPAG('PCDEC',PCDEC)          !DEFINE SYMBOL
            CALL WNCTXS(PCDEC,'!D6.4',SIN(FDEC*DPI2)) !WRITE SIN(DEC) IN STRING
            CALL WNDPAG('SD',PCDEC)             !DEFINE SYMBOL
	  END IF
C
C Some elementary consistency checks (only first loop)
C
	  DO WHILE (NSCSTG(FCAIN,SETS(0,0,NFILE+1),STH,STHP,SETNAM)) !ALL SETS
	     IF (ABS(STHD(STH_RA_D) -FRA) .GT.2./360. .OR.
	1	 ABS(STHD(STH_DEC_D)-FDEC).GT.2./360. ) THEN	!Diff. pos.
	       CALL WNCTXT(F_TP,'WARNING: Pointing of !AS is '//
	1	 '(!4$DPF4.0,!4$DAF4.0), not (!4$DPF4.0,!4$DAF4.0)',
	1	 WNTTSG(SETNAM,0),
	1	 STHD(STH_RA_D),STHD(STH_DEC_D),FRA,FDEC)
	     END IF
	     IF (STHJ(STH_INST_J).NE.FINST) THEN	!Diff. inst.
	        CALL WNCTXT(F_TP,'WARNING: Different instrument '//
	1		'on set !AS',WNTTSG(SETNAM,0))
	     END IF
	  END DO
	  CALL WNDSTR(FCAIN,SETS)		!RESET SET SEARCH
C
	  CALL WNFCL(FCAIN)			!CLOSE FOR NOW
C
C	Get HA range, for WSRT limit default to -90,90
C
	  DO I=0,1
	    HA(I,NFILE+1)=HA(I,MAX(1,NFILE))	!DEFAULT
	  END DO
	  IF (STHJ(STH_INST_J).EQ.0) THEN
	    HA(0,NFILE+1)=MAX(HA(0,NFILE+1),-90./360.)
	    HA(1,NFILE+1)=MIN(HA(1,NFILE+1), 90./360.)
	  END IF
	  CALL WNCTXS(TXT,'Hour-angle range for data set #!UJ',NFILE+1)
	  CALL WNDPOH(TXT,' ',' ')
	  IF (.NOT.NSCHAS(0,HA(0,NFILE+1))) GOTO 210
C
	  CALL WNCTXS(TXT,'Interferometers for data set #!UJ',NFILE+1)
	  CALL WNDPOH(TXT,' ',' ')
	  IF (NFILE.LE.0) THEN
	    IF (.NOT.NSCIF1(CIFR,SIFRS(0,0,1),STHJ)) GOTO 210 !GET IFRS SELECTED
	  ELSE
	    DO I=0,STHTEL-1			!COPY PREVIOUS
	      DO I1=0,STHTEL-1
	        SIFRS(I1,I,NFILE+1)=SIFRS(I1,I,NFILE)
	      END DO
	    END DO
	    IF (.NOT.NSCIF1(0,SIFRS(0,0,NFILE+1),STHJ)) GOTO 210 !GET IFRS
	  END IF
	  CIFR=0				!NEXT ROUND
C
	  NFILE=NFILE+1				!NEXT FILE
	  IF (NFILE.LT.MXNFIL) GOTO 210		!MAYBE MORE
C
C GET SOME INPUT STATISTICS
C
 220	  CONTINUE
	  IF (NFILE.LE.0) THEN			!NO DATA
	    CALL WNCTXT(F_TP,'!/No data specified!/')
	    GOTO 800				!RESTART
	  END IF
	  CALL NMASST				!GET INPUT DATA
	  IF (CNTJVL(2).LE.0) THEN		!NO SETS FOUND
	    NFILE=0
	    GOTO 220
	  END IF
 222	  CONTINUE
	  IF (CLEAN) THEN
	    CNTCVL(1)='Data-cleaned'
	  ELSE
	    IF (.NOT.WNDPAR('USER_COMMENT',CNTCVL(1),24,J0,'""')) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 210	!RETRY FILE
	      GOTO 222				!RETRY
	    END IF
	    IF (J0.LE.0) CNTCVL(1)=' '		!NO COMMENT
	  END IF
C
C MAP SPECIFICATIONS
C
 820	  CONTINUE
	  IF (.NOT.CLEAN) CALL WNCTXT(F_TP,'!/Map properties:')
C
C Type of UV COORDINATES:
C  Standard geometric: UVCDT=0
C  BASHA: UVCDT=1
C  IFRHA: UVCDT=2
C
 224	  CONTINUE
	  IF (CLEAN) THEN
	    C1='UV'
	  ELSE
	    IF (.NOT.WNDPAR('UV_COORDINATES',C1,LEN(C1),J0,'UV')) THEN !UV TYPE
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 810	!RETRY INPUTS
	      GOTO 224				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 810		! RETRY INPUTS
	  END IF
	  IF (C1(1:1).EQ.'B') THEN
	    UVCDT=1				! BASHA
	  ELSE IF (C1(1:1).EQ.'I') THEN
	    UVCDT=2				! IFRHA
	  ELSE
	    UVCDT=0				! STANDARD
	  END IF
C
C Scales for BASHA/IFRHA
C
 226	  CONTINUE
	  IF (UVCDT.NE.0) THEN			! BASHA, IFRHA?
	    IF (.NOT.WNDPAR('HA_RESOLUTION',R0,
	1	LB_E,J0)) THEN  		! HA RESOLUTION in UT sec
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY OUTPUTS
	      GOTO 226
	    END IF
	    IF (J0.EQ.0) GOTO 820
	    R0=WNGEFR(WNGEDF(R0*1.0027379))	! convert to ST RADIANS
	  END IF
	  IF (UVCDT.EQ.1) THEN			! BASHA?
	    IF (.NOT.WNDPAR('BAS_RESOLUTION',R1,LB_E,
	1		J0,'18.')) THEN		! BASEL. RESOL.
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY OUTPUTS
	      GOTO 226
	    END IF
	    IF (J0.EQ.0) GOTO 820
	  ELSE IF (UVCDT.EQ.2) THEN		! IFRHA?
	    IF (.NOT.WNDPAR('IFR_RESOLUTION',R1,LB_E,
	1			J0,'1.')) THEN	! IFR RESOLUTION
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY OUTPUTS
	      GOTO 226
	    END IF
	    IF (J0.EQ.0) GOTO 820
	    R1=1./R1				! CONVERT STEP IN RESOLUTION
	  END IF
C
C MAP SIZE AND FIELD
C
	  IF (CLEAN) THEN
	    FTSIZ(0)=MPHJ(MPH_FSR_J)
	    FTSIZ(1)=MPHJ(MPH_FSD_J)
	  ELSE
	    IF (FTSIZ(0).LT.0) THEN		! NEED DEFAULTS
	      IF (UVCDT.EQ.0) THEN		! NORMAL
	        FTSIZ(0)=512			! DEFAULT
	        FTSIZ(1)=MAX(2**(
	1		NINT(LOG(ABS(SIN(REAL(MAPCRD(1))*PI2))*
	1		FTSIZ(0))/LOG(2.))),16)
	      ELSE
	        FTSIZ(1)=2*WNMEJC(UV1MAX(1)/R0)+1! HA MAX
	        IF (UVCDT.EQ.1) THEN
	          FTSIZ(0)=2*
	1		WNMEJC(UV1MAX(0)/R1)+1 	! BASEL MAX
	        ELSE
	          FTSIZ(0)=2*
	1		WNMEJC(UV2MAX(0)/R1)+1  ! IFR MAX
	        END IF
	      END IF
	    END IF ! not LCL
 228	    CONTINUE
	    IF (.NOT.WNDPAR('FT_SIZE',FTSIZ,2*LB_J,J0,
	1		A_B(-A_OB),FTSIZ,2)) THEN! FFT SIZE
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY ALL
	      GOTO 228				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 820		! RETRY ALL
	  END IF
	  DODFT=.FALSE.
	  IF (.NOT.CLEAN .AND.
	1	FTSIZ(0).LE.DFTSIZ .AND. 
	1	FTSIZ(1).LE.DFTSIZ) DODFT=.TRUE.
C
C Output size
C
	  IF (DODFT) THEN			! DFT?
	    OUTSIZ(0)=FTSIZ(0)
	    OUTSIZ(1)=FTSIZ(1)
	    GOTO 232
	  END IF
	  IF (CLEAN) THEN				! data clean?
	    OUTSIZ(0)=MPHJ(MPH_NRA_J)		!  yes, use input map sizes
	    OUTSIZ(1)=MPHJ(MPH_NDEC_J)
	    FIELD(0)=MPHD(MPH_SRA_D)*PI2*FTSIZ(0)
	    FIELD(1)=MPHD(MPH_SDEC_D)*PI2*FTSIZ(1)
	  ELSE					! autonomous make 
	    DO I=0,1
	      FTSIZ(I)=MAX(FTSIZ(I),32)
	      IF (UVCDT.NE.0)			! BASHA/IFRHA
	1	OUTSIZ(I)=FTSIZ(I)
	      FTSIZ(I)=2**(WNMEJC(LOG(FLOAT(FTSIZ(I)))
	1		/LOG(2.)-.001))		! power of 2
	      IF (UVCDT.EQ.0) OUTSIZ(I)=	! FFT: min. 32, max. 1024
	1		MIN(1024,MAX(FTSIZ(I),32))
	    END DO
 230	    CONTINUE
	    IF (.NOT.WNDPAR('OUT_SIZE',OUTSIZ,
	1	2*LB_J,J0,A_B(-A_OB),OUTSIZ,2)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY ALL
	      GOTO 230				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 820		! RETRY ALL
	    DO I=0,1				! PROPER OUTPUT SIZE
	      OUTSIZ(I)=
	1	MIN(FTSIZ(I),2*((OUTSIZ(I)+1)/2))
	    END DO
C
C Field size
C
 232	    CONTINUE
	    IF (UVCDT.EQ.0) THEN		! NORMAL?
	      IF (FIELD(0).EQ.-100) THEN	! NEED DEFAULTS
	        FIELD(0)=WNMEJC
	1		(100.*(FTSIZ(0)/2.5)*10.*
	1		(1400./FRQMAX)/3600.)/100.
	        FIELD(1)=FIELD(0)
	1		*FTSIZ(1)/FTSIZ(0) 	! /ABS(SIN(PI2*SFHDEC))
	      ELSE
	        DO I=0,1
	          FIELD(I)=FIELD(I)*DEG
	        END DO
	      END IF
	      DO I=0,1				! MAKE ROUND NUMBERS
	        IF (FIELD(I).GE.10.) THEN
		  FIELD(I)=ANINT(FIELD(I)/2.)*2.
	        ELSE IF (FIELD(I).GE.5.) THEN
		  FIELD(I)=ANINT(FIELD(I)/1.)*1.
	        ELSE IF (FIELD(I).GE.1.) THEN
		  FIELD(I)=ANINT(FIELD(I)/.2)*.2
	        ELSE IF (FIELD(I).GE..5) THEN
		  FIELD(I)=ANINT(FIELD(I)/.1)*.1
	        ELSE IF (FIELD(I).GE..1) THEN
		  FIELD(I)=ANINT(FIELD(I)/.02)*.02
	        ELSE IF (FIELD(I).GE..05) THEN
		  FIELD(I)=ANINT(FIELD(I)/.01)*.01
	        END IF
	      END DO
	      IF (.NOT.WNDPAR('FIELD_SIZE',FIELD,2*LB_E,
	1		J0,A_B(-A_OB),FIELD,2)) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820 !RETRY ALL
	        GOTO 232			! RETRY
	      END IF
C
C NULL answer: ask GRID_SIZE
C
	      IF (E_C.EQ.DWC_NULLVALUE) THEN
	         DO I=0,1			! GRID=FIELD/NPIXEL
	            FIELD(I)=FIELD(I)
	1		/FTSIZ(I)*3600.
	         END DO
	         IF (.NOT.WNDPAR('GRID_SIZE',FIELD,2*LB_E,
	1		J0,A_B(-A_OB),FIELD,2)) THEN
	           IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820! RETRY ALL
	           GOTO 232			! RETRY
	         END IF
	         DO I=0,1			! FIELD=GRID*NPIXEL
	            FIELD(I)=FIELD(I)*FTSIZ(I)/3600.
	         END DO
	      END IF
C
	      IF (J0.EQ.0) GOTO 820		! RETRY ALL
	      DO I=0,1
	        FIELD(I)=FIELD(I)/DEG		! MAKE RADIANS
	      END DO
	    ELSE				! BASHA/IFRHA
	      FIELD(1)=1./(R0*FRQMIN/(CL*1E-6))
	      IF (UVCDT.EQ.1) THEN		! BASHA
	        FIELD(0)=1./(R1*FRQMIN/(CL*1E-6))
	      ELSE				! IFRHA
	        FIELD(0)=1./(R1*FRQMIN/(CL*1E-6))
	      END IF
	    END IF
	  END IF ! not CLEAN
C
C QMAPS DETAILS 
C
 830	  CONTINUE
	  IF (.NOT.WNDPAR('QMAPS',BB1,LB_B,J0)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 820	! RETRY OUTPUTS
	    GOTO 830				! REPEAT
	  END IF
	  IF (J0.EQ.0) GOTO 820			! RETRY OUTPUTS
C
C Clean defaults
C
	  IF (CLEAN) THEN
	    UWGT=0
	    TAPTYP=MPHI(MPH_CD_I+0)
	    CVLTYP=MPHI(MPH_CD_I+1)
	    IF (CVLTYP.EQ.1) THEN
	        CVLWID(0)=3.98
	    ELSE IF (CVLTYP.EQ.2) THEN
	      CVLWID(0)=1.0
	    ELSE IF (CVLTYP.EQ.3) THEN
	      CVLWID(0)=4
	    ELSE IF (CVLTYP.EQ.4) THEN
	      CVLWID(0)=6
	    ELSE
	      CVLWID(0)=6
	    END IF
	    DECVL=MPHI(MPH_CD_I+2).EQ.1
	  END IF
	  IF (BB1) THEN ! QMAPS=yes, either NMAP or CLEAN
C
C UWGT: Method of determining UV coverage
C
 234	    CONTINUE
	    IF (UVCDT.EQ.0) THEN		! standard UV plane?
	      IF (.NOT.WNDPAR('UNIFORM',C1, 	! type of UV coverage
	1		LEN(C1),J0,'STANDARD')) THEN 
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! back to QMAPS
	        GOTO 234			! error, RETRY
	      END IF
	    ELSE				! BASHA/IFRHA?
	      IF (.NOT.WNDPAR('UNIFORM',C1,
	1		LEN(C1),J0,'NATURAL')) THEN ! type of UV coverage
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! back to QMAPS
	        GOTO 234			! error, RETRY
	      END IF
	    END IF
C
	    IF (J0.EQ.0) GOTO 830		! RETRY ALL
	    IF (C1(1:1).EQ.'N') THEN		! NATURAL
	      UWGT=0
	    ELSE IF (C1(1:1).EQ.'F') THEN	! FULL
	      UWGT=2
	    ELSE				! STANDARD
	      UWGT=1
	    END IF
C
C TAPTYP: Type of UV taper and width
C
 236	    CONTINUE
	    IF (.NOT.CLEAN) THEN
	      IF (UVCDT.EQ.0) THEN		! standard UV plane?
	        IF (.NOT.WNDPAR('TAPER',C1,LEN(C1),
	1		J0,'GAUSS')) THEN	! yes, default is Gaussian
	          IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! back to QMAPS
	          GOTO 236			! error, RETRY
	        END IF
	      ELSE				! BASHA/IFRHA
C
CC It is pointless to taper BASHA/IFRHA plots and it is unlikely that such plots
CC  are made in batch mode, so I suppress this prompt. JPH 941013
CC
CC	        IF (.NOT.WNDPAR('TAPER',C1,LEN(C1),
CC	1		J0,'NATURAL')) THEN 	! BASHA/IFRHA, default is none
CC	          IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830 !RETRY ALL
CC	          GOTO 236			! RETRY
CC	        END IF
	        C1='NATURAL'
	      END IF
	      IF (C1(1:1).EQ.'G') THEN		! GAUSS
	        TAPTYP=1				! TAPER TYPE
	      ELSE IF (C1(1:1).EQ.'L') THEN	! LINEAR
	        TAPTYP=2
	      ELSE IF (C1(1:1).EQ.'N') THEN	! NATURAL
	        TAPTYP=3
	      ELSE IF (C1(1:1).EQ.'O') THEN	! OVERR
	        TAPTYP=4
	      ELSE IF (C1(1:1).EQ.'R') THEN	! RGAUSS
	        TAPTYP=5
	      ELSE
	        GOTO 236
	      END IF
	    END IF ! not LCL
C
C TAPVAL: Taper width
C
 240	    CONTINUE
	    IF (TAPTYP.EQ.1 .OR. TAPTYP.EQ.5) THEN! gaussian taper
	      IF (.NOT.WNDPAR('TAPER_VALUE',TAPVAL,
	1		LB_E,J0,'2548.')) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! back to QMAPS
	        GOTO 240
	      END IF
	    ELSE IF (TAPTYP.EQ.2) THEN		! triangular taper
	      IF (.NOT.WNDPAR('TAPER_VALUE',TAPVAL,
	1		LB_E,J0,'4000.')) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! back to QMAPS
	        GOTO 240
	      END IF
	    ELSE				! natural or 1/R
	      TAPVAL=0
	      J0=1
	    END IF
	    IF (J0.EQ.0) GOTO 240
C
C CWGTYP, CWGVAL: Circular weight function and width
C
 242	    CONTINUE
	    IF (.NOT.WNDPAR('CWEIGHT_TYPE',C1,LEN(C1),J0,
	1		'NATURAL')) THEN	! TYPE
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! RETRY ALL
	      GOTO 242				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 830
	    IF (C1(1:1).EQ.'N') THEN		! NONE
	      CWGTYP=0				! CWEIGHT TYPE
	    ELSE IF (C1(1:1).EQ.'G') THEN	! GAUSS
	      CWGTYP=1
	    ELSE IF (C1(1:1).EQ.'L') THEN	!LINEAR
	      CWGTYP=2
	    ELSE
	      GOTO 242
	    END IF
C
 244	    CONTINUE
	    C1=' '
	    IF (CWGTYP.EQ.1 .OR. CWGTYP.EQ.5) THEN
	      C1='2548.'
	    ELSE IF (CWGTYP.EQ.2) THEN
	      C1='4000.'
	    ELSE
	      CWGVAL=0
	      J0=1
	    ENDIF
	    IF (C1.NE.' ') THEN
	      IF (.NOT.WNDPAR('CWEIGHT_VALUE',
	1		CWGVAL,LB_E,J0,C1)) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! RETRY ALL
	        GOTO 244
	      END IF	    
	      IF (J0.EQ.0) GOTO 244
	    ENDIF
C
C UV convolution function: Type and width
C
 246	    CONTINUE
	    IF (.NOT.DODFT) THEN		! NO CONVOLUTION FOR DFT
	      IF (.NOT.CLEAN) THEN
	        IF (UVCDT.EQ.0) THEN
		  C1='EXPSINC'
		ELSE
		  C1='BOX'
		ENDIF
	        IF (.NOT.WNDPAR('CONVOLVE',C1,
	1		LEN(C1),J0,C1)) THEN
	          IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830 ! RETRY ALL
	          GOTO 246			! RETRY
	        END IF
	        IF (C1(1:1).EQ.'G') THEN	! GAUSS
	          CVLTYP=1
	        ELSE IF (C1(1:1).EQ.'B') THEN	! BOX
	          CVLTYP=2
	        ELSE IF (C1(1:2).EQ.'P4') THEN	! PROLATE 4*4
	          CVLTYP=3
	        ELSE IF (C1(1:1).EQ.'E') THEN	! EXP*SINC
	          CVLTYP=4
	        ELSE IF (C1(1:2).EQ.'P6') THEN	! PROLATE 6*6
	          CVLTYP=5
	        ELSE
	          GOTO 246
	        END IF
	      END IF
	      IF (CVLTYP.EQ.1) THEN		! GAUSS
	        CVLWID(0)=3.98
	      ELSE IF (CVLTYP.EQ.2) THEN	! BOX
	        CVLWID(0)=1.0
	      ELSE IF (CVLTYP.EQ.3) THEN	! P4*4
	        CVLWID(0)=4
	      ELSE IF (CVLTYP.EQ.4) THEN	! EXPSINC
	        CVLWID(0)=6
	      ELSE				! P6*6
	        CVLWID(0)=6
	      END IF
	      CVLWID(0)=CVLWID(0)/2.		! SET HALF WIDTH
	      CVLWID(1)=CVLWID(0)
C
C Correction of map for convolution taper
C
 248	      CONTINUE
	      IF (.NOT.CLEAN) THEN
	        IF (.NOT.WNDPAR('DECONVOLVE',
	1		BB1,LB_B,J0)) THEN
	          IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! RETRY ALL
	          GOTO 248
	        END IF
	        IF (J0.EQ.0) GOTO 830
	        DECVL=BB1
	      END IF ! not CLEAN
	    ENDIF ! not DODFT
	  ELSE
C
C BASHA/IFRHA defaults
C
	    IF (UVCDT.NE.0) THEN		! BASHA/IFRHA?
	      UWGT=0				! NATURAL
	      TAPTYP=3				! NATURAL
	      TAPVAL=0
	      CVLTYP=2				! BOX
	      CVLWID(0)=1.
C
C 'Make' defaults
C
	    ELSE				! standard UV plane?
	      UWGT=1				! STANDARD
	      IF (.NOT.CLEAN) THEN
	        TAPTYP=1			! GAUSS
	        CVLTYP=4			! EXPSINC
	        CVLWID(0)=6.
	      END IF
	      TAPVAL=2548.
	    END IF
	    CWGTYP=0				! NO CIRC. WEIGHT
	    CVLWID(0)=CVLWID(0)/2.		! SET HALF WIDTH
	    CVLWID(1)=CVLWID(0)
	    IF (.NOT.CLEAN) THEN
	      DECVL=.TRUE.			! DECONVOLVE
	    END IF
C
	  ENDIF ! QMAPS

C
C QDATAS CORRECTIONS
C
 840	  CONTINUE
CC	  IF (.NOT.CLEAN) CALL WNCTXT(F_TP,'!/Data manipulations:')
 850	  CONTINUE
	  IF (CLEAN) THEN
	    BB1=.FALSE.				! NO DATA MANIPULATIONS
	  ELSE
	    IF (.NOT.WNDPAR('QDATAS',BB1,LB_B,J0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 830! RETRY OUTPUTS
	      GOTO 850				! REPEAT
	    END IF
	    IF (J0.EQ.0) GOTO 820		! RETRY OUTPUTS
	  END IF
	  IF (CLEAN) THEN				! CLEAN DEFAULTS
	    UVDTP=0
	    DATTYP=MPHI(MPH_CD_I+5)
	    CLIP=MPHI(MPH_CD_I+3).EQ.1
	    LSHIFT=0
	    SHIFT(0)=0
	    SHIFT(1)=0
	  END IF
	  IF (BB1) THEN			! CLEAN or QDATAS=no?
	  ELSE
C
C Defaults for CLEAN
C
	    UVRAD(0)=0				! UV AREA
	    UVRAD(1)=10000
	    CLPRAD(0)=0
	    CLPRAD(1)=10000
	    CLPLEV(0)=100000
	    CLPLEV(1)=100000
C
C Defaults for .NOT.CLEAN, i.e. for QDATAS=no
C
	    IF (.NOT.CLEAN) THEN
	      CALL NSCSAD(CAP,CDAP)		! GET CORRECTIONS TO APPLY
	      UVDTP=0				! STANDARD
	      CLIP=.FALSE.			! NO CLIP
	      SHIFT(0)=0			! NO FIELDSHIFT
	      SHIFT(1)=0
	      LSHIFT=0
	      DATTYP=1				! NORMAL MAP
	      GOTO 860				! skip rest of QDATAS section
	    END IF
	  END IF
C
C QDATAS prompts for CLEAN or QDATAS-yes
C
	  CALL NSCSAD(CAP,CDAP)			! GET CORRECTIONS TO APPLY
 250	  CONTINUE
	  IF (.NOT.CLEAN) THEN
	    IF (.NOT.WNDPAR('USER_DATA',C1,LEN(C1),
	1	J0,'STANDARD')) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY ALL
	      GOTO 250				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 850		! RETRY ALL
	    IF (C1(1:1).EQ.'M') THEN		! MODEL
	      UVDTP=1
	    ELSE				! STANDARD
	      UVDTP=0
	    END IF
	  END IF
 252	  CONTINUE
	  IF (.NOT.WNDPAR('UV_AREA',UVRAD,
	1	2*LB_E,J0)) THEN
	    IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850	! RETRY DATA PARAMETERS
	    GOTO 252				! RETRY
	  END IF
	  IF (J0.EQ.0) GOTO 850			! RETRY DATA
C
C Clipping
C
 254	  CONTINUE
	  IF (.NOT.CLEAN) THEN
	    IF (.NOT.WNDPAR('CLIPPING',BB1,LB_B,
	1	J0,'NO')) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY DATA
	      GOTO 254				! RETRY
	    END IF
	    CLIP=BB1
	    IF (J0.EQ.0) GOTO 850		! RETRY UV AREA
	    IF (J0.LT.0) CLIP=.FALSE.		! NO
	  END IF
 256	  CONTINUE
	  IF (CLIP) THEN
	    IF (.NOT.WNDPAR('CLIP_AREA',CLPRAD,
	1	2*LB_E,J0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY ALL
	      GOTO 256				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 850		! RETRY ALL
	    IF (.NOT.WNDPAR('CLIP_LEVELS',CLPLEV,
	1	2*LB_E,J0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY DATA
	      GOTO 256				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 850		! RETRY ALL
	  END IF
 258	  CONTINUE
C
C Shift
C
	  IF (.NOT.CLEAN) THEN
	    IF (.NOT.WNDPAR('FIELD_SHIFT',SHIFT,
	1	2*LB_E,J0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY ALL
	      GOTO 258				! RETRY
	    END IF
	    IF (E_C.NE.DWC_NULLVALUE) THEN
	      LSHIFT=1
	    ELSE
 259	      CONTINUE
	      CENTRE(0)=MAPCRD(0)*360D0
	      IF (CENTRE(0).LT.0) 
	1		CENTRE(0)=CENTRE(0)+360D0
	      D0=CENTRE(0)
	      CENTRE(1)=MAPCRD(1)*360D0
	      D1=CENTRE(1)
	      IF (.NOT.WNDPAR('FIELD_CENTRE',CENTRE,
	1		2*LB_D,J0,A_B(-A_OB),CENTRE,2)) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY ALL
	        GOTO 259			! RETRY
	      END IF
	      IF (CENTRE(0).NE.D0 .OR. 
	1		CENTRE(1).NE.D1) THEN	! input given?
	        CENTRE(0)=CENTRE(0)/360D0
	        CENTRE(1)=CENTRE(1)/360D0
	        LSHIFT=-1
	      ENDIF
	    ENDIF
	  END IF
 260	  CONTINUE
	  IF (.NOT.CLEAN) THEN
	    IF (.NOT.WNDPAR('DATA_TYPE',C1,
	1	LEN(C1),J0,)) THEN		! complex, C, S, A or P
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 850! RETRY ALL
	      GOTO 260				! RETRY
	    END IF
	    IF (J0.EQ.0) GOTO 850		! RETRY ALL
	    DATTYP=1				! ASSUME NORMAL
	    IF (C1(1:1).EQ.'N') THEN		! NORMAL MAP
	      DATTYP=1
	    ELSE IF (C1(1:1).EQ.'C') THEN	! COSINE
	      DATTYP=2
	    ELSE IF (C1(1:1).EQ.'S') THEN	! SINE
	      DATTYP=3
	    ELSE IF (C1(1:1).EQ.'A') THEN	! AMPLITUDE
	      DATTYP=4
	    ELSE IF (C1(1:1).EQ.'P') THEN	! PHASE
	      DATTYP=5
	    END IF
	  ENDIF ! end of QDATAS section

C
C SOURCE SUBTRACTION
C
 860	  CONTINUE
	  IF (CLEAN) THEN
	    SUB=.TRUE.				! clean: ALWAYS SUBTRACT
	  ELSE
	    IF (UVDTP.NE.1) THEN		! SUBTRACT?
	      IF (.NOT.WNDPAR('SUBTRACT',BB1,LB_B,J0,
	1		A_B(-A_OB),SUB,1)) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 840! RETRY DATA
	        GOTO 860			! RETRY
	      END IF
	      SUB=BB1				! SET SUBTRACTION
	      IF (J0.EQ.0) GOTO 840		! RETRY DATA
	    END IF
	  END IF
	  IF (SUB .OR. UVDTP.EQ.1) THEN		! SOURCES WANTED
	    CALL NMODAW(NSRC(0),STH)		! GET SOURCES
	    CALL NSCSAD(CAP,CDAP)		! GET CORRECTIONS AGAIN
	    IF (NSRC(0).LE.0 .AND. .NOT.CLEAN) THEN
	      CALL WNCTXT(F_TP,'No sources specified')
	      GOTO 860				! RETRY
	    END IF
	    CALL NMOMUI				! GET MODEL USAGE
	  END IF
C
C OUTPUT FILES
C
 870	  CONTINUE
	  IF (.NOT.CLEAN) CALL WNCTXT(F_TP,'!/!4C\Output files:')
C
C POLARISATIONS
C
 262	  CONTINUE
	  IF (CLEAN) THEN
	    CALL WNGMTS(MPH_POL_N,MPH(MPH_POL_1),
	1	POLC(0)) 			! clean: SET POL. TO DO
	    NPOL=1		
	    POLTJ(-1,1)=1			!CLEAN
	  ELSE
	    IF (.NOT.WNDPAR('MAP_POLAR',POLC,
	1	4*LEN(POLC(0)),J0)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 840! RETRY DATA
	      GOTO 262				! ERROR, retry
	    END IF
	    IF (J0.EQ.0) GOTO 840		! RETRY ALL
	    NPOL=J0				! # OF POLARISATIONS
	    POLTJ(-1,1)=0			!NOT CLEAN
	  END IF
	  DO I=0,3				! CLEAR POL. TABLE
	    POLT(I,0)=0
	  END DO
	  DO I=0,NPOL-1				! SET CODES
	    DO I1=1,MXNPCD			! FIND CORRECT ONE
	      IF (POLC(I).EQ.PCD(I1)) THEN	! FOUND
		POLTJ(I,0)=PCDT(I1)
	        GOTO 264			! READY
	      END IF
	    END DO
 264	    CONTINUE
	  END DO
	  IF (NPOL.EQ.1 .AND. POLTJ(0,0).EQ.I_M+IMAG_P+LINE_P) THEN
	    POLTJ(-1,0)=1			!SET POL. INT.
	  ELSE IF (NPOL.EQ.1 .AND. POLTJ(0,0).EQ.Q_M+IMAG_P) THEN
	    POLTJ(-1,0)=2			!SET POL. INT.
	  ELSE
	    POLTJ(-1,0)=0			!SET NOT POL. INT.
	  END IF
C
C Map COORDINATE system
C
 266	  CONTINUE
	  IF (CLEAN) THEN				! clean defaults
	    IF (MPHI(MPH_EPT_I).EQ.1) THEN
	      CEP='REF'
	    ELSE
	      CEP='AREF'
	    END IF
	  ELSE
	    IF (.NOT.WNDPAR('MAP_COORD',CEP,
	1	LEN(CEP),J0,CEP)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 870! RETRY DATA
	      GOTO 266				! ERROR, retry
	    END IF
	    IF (J0.EQ.0) GOTO 870		! RETRY ALL
	  END IF
	  IF (CEP(1:1).EQ.'B') THEN		! B1950/J2000
	    MAPCTP=+2
	  ELSE IF (CEP(1:3).EQ.'APP') THEN	! APPARENT
	    MAPCTP=+1
	  ELSE IF (CEP(1:3).EQ.'REF') THEN	! 1950/2000 REFERENCE
	    MAPCTP=-2
	  ELSE IF (CEP(1:3).EQ.'ARE') THEN	! APPARENT REFERENCE
	    MAPCTP=-1
	  ELSE
	    GOTO 266				! MUST FILL
	  END IF
 268	  CONTINUE
	  IF (MAPCTP.LT.0) THEN			! GET REFERENCE COORD.
	    IF (CLEAN) THEN
	      MAPCRD(0)=MPHD(MPH_RA_D)		! MAP COORDINATES
	      MAPCRD(1)=MPHD(MPH_DEC_D)
	    ELSE
	      IF (MAPCRD(0).EQ.-1000) THEN	! no value yet?
	        JS=WNDPAR('REF_COORD',MAPCRD(0),
	1		2*LB_D,J0)
	      ELSE				! use previous as default
	        MAPCRD(0)=WNGDPD(WNGDFD(MAPCRD(0)))	! MAKE DEGREES
	        MAPCRD(1)=WNGDND(WNGDFD(MAPCRD(1)))	! MAKE DEGREES
	        JS=WNDPAR('REF_COORD',MAPCRD(0),2*LB_D,J0,
	1		A_B(-A_OB),MAPCRD(0),2)
	      END IF
	      If (MAPCRD(0).NE.-1000) THEN
		MAPCRD(0)=WNGDPF(WNGDDF(MAPCRD(0))) ! MAKE circles
		MAPCRD(1)=WNGDNF(WNGDDF(MAPCRD(1)))
	      END IF
	      IF (.NOT.JS) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 870 !RETRY ALL
	        GOTO 268				!RETRY
	      END IF
	      IF (J0.EQ.0) GOTO 870		! RETRY ALL
	    END IF
	  END IF
C
C OUTPUT types: Map, AP, cover, real, imag, ampl, phase
C
 270	  CONTINUE
	  IF (CLEAN) THEN
	    J0=1				! ONLY MAP OUT
	    C2(1)='MAP'
	  ELSE
	    IF (FCAOUT.NE.0) CALL WNFCL(FCAOUT)	! MAKE SURE NEW ONE
	    IF (DODFT) GOTO 880			! DFT
	    IF (UVCDT.EQ.0) THEN		! make
	      IF (.NOT.WNDPAR('OUTPUT',C2,
	1		8*LEN(C2(1)),J0,
	1		'MAP,AP')) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 870 !RETRY ALL
	        GOTO 270				!RETRY
	      END IF
	      IF (J0.EQ.0) GOTO 870		! RETRY ALL
	    ELSE				! BASHA/IFRHA
	      CALL WNDPOH(' ',
	1		'COVER,REAL,IMAG,AMPL,PHASE',' ')
	      IF (.NOT.WNDPAR('OUTPUT',C2,
	1		8*LEN(C2(1)),J0,
	1		'AMPL,PHASE')) THEN
	        IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 870! RETRY ALL
	        GOTO 270			! RETRY
	      END IF
	      IF (J0.EQ.0) GOTO 870		! RETRY ALL
	    END IF
	  END IF
	  DO I=1,NOPT				! SET NO OUTPUTS
	    OUTOPT(I)=.FALSE.
	  END DO
	  MAKMAP=.FALSE.			! NO MAP MAKING
	  MAKAP=.FALSE.
	  DO I=1,J0				! SET OUTPUTS
	    IF (C2(I)(1:1).EQ.'M') THEN		! MAP
	      OUTOPT(1)=.TRUE.
	      MAKMAP=.TRUE.
	    ELSE IF (C2(I)(1:2).EQ.'AP') THEN	! AP
	      OUTOPT(2)=.TRUE.
	      MAKAP=.TRUE.
	    ELSE IF (C2(I)(1:1).EQ.'C') THEN	! COVER
	      OUTOPT(3)=.TRUE.
	      MAKAP=.TRUE.
	    ELSE IF (C2(I)(1:1).EQ.'R') THEN	! REAL PLANE
	      OUTOPT(4)=.TRUE.
	      MAKMAP=.TRUE.
	    ELSE IF (C2(I)(1:1).EQ.'I') THEN	! IMAG. PLANE
	      OUTOPT(5)=.TRUE.
	      MAKMAP=.TRUE.
	    ELSE IF (C2(I)(1:2).EQ.'AM') THEN	! AMPL. PLANE
	      OUTOPT(6)=.TRUE.
	      MAKMAP=.TRUE.
	    ELSE IF (C2(I)(1:1).EQ.'P') THEN	! PHASE PLANE
	      OUTOPT(7)=.TRUE.
	      MAKMAP=.TRUE.
	    END IF
	  END DO
 272	  CONTINUE
	  IF (CLEAN) THEN
	    FCAOUT=CMFCA			! DEFAULT OUTPUT FCA
	  ELSE
	    IF (.NOT.WNDNOD('OUTPUT_WMP_NODE',
	1	NODOUT,'WMP','U',NODOUT,FILOUT)) THEN
	      IF (E_C.EQ.DWC_ENDOFLOOP) GOTO 870! RETRY OUTPUT
	      GOTO 272				! REPEAT
	    ELSE IF (E_C.EQ.DWC_NULLVALUE) THEN
	      GOTO 870				! RETRY OUTPUT
	    ELSE IF (E_C.EQ.DWC_WILDCARD) THEN
	      GOTO 272				! MUST SPECIFY
	    END IF
	    IF (.NOT.WNFOP(FCAOUT,FILOUT,'U')) GOTO 272
C
	    IF (MAKMAP) CALL NMAJSL()		! CREATE JOB SUMMARY LOG
	  END IF
C
C READY
C
 880	  CONTINUE
C
	END IF					! END MAKE/CLEAN
 900	CONTINUE
	RETURN					! READY
C
C
	END

C+ NGCEXP.FOR
C  WNB 920819
C
C  Revisions:
C	WNB 930630	Add operator ^, and functions 78-85
C	AXC 010709      Linux port - init data
C
	LOGICAL FUNCTION NGCEXP(INSTR,OUTSTR,COD,PLT,NPLT)
C
C  Analyze expression
C
C  Result:
C
C	NGCEXP_L = NGCEXP( INSTR_C*:I, OUTSTR_C*:O, COD_J(*):O, PLT_J(*):O,
C			NPLT_J:O)
C				Analyze expression given in INSTR,
C				and return executable program in COD.
C				NPLT will return the number of different plots
C				used, PLT(NPLT) will then contain a reference
C				to these plots. OUTSTR gives the string
C				analyzed without errors.
C
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'NGC_DEF'
C
C  Parameters:
C
	INTEGER NFUNCT			!# OF FUNCTIONS DEFINED
	  PARAMETER (NFUNCT=35)
C
C  Arguments:
C
	CHARACTER*(*) INSTR		!EXPRESSION
	CHARACTER*(*) OUTSTR		!ANALYZED PART OF EXPRESSION
	INTEGER COD(*)			!EXECUTABLE
	INTEGER PLT(*)			!PLOTS USED
	INTEGER NPLT			!# OF PLOTS USED
C
C  Function references:
C
	LOGICAL NGCEX1			!SET CODE IN RPS
	LOGICAL NGCEX2			!STRING UPDATE
	LOGICAL WNCATD			!TEST IF DIGIT
	LOGICAL WNCATA			!TEST IF ALPHA
	LOGICAL WNCACU			!GET UNSIGNED INTEGER VALUE
	LOGICAL WNCAFN			!GET NAME
C
C  Data declarations:
C
C CODED AS: FUNCTION #, PRIORITY, # OF ARGUMENTS, # OF ARGUMENTS USED UP
C
	CHARACTER*6 UN2				!2 CHAR UNARY
	  DATA UN2/'<>,><,'/
	INTEGER UN2C(2)
	  BYTE LUN2C(4,2)
	  EQUIVALENCE (UN2C,LUN2C)
	  DATA LUN2C/	14,28,1,0,14,28,1,0/
	CHARACTER*4 UN1				!1 CHAR UNARY
	  DATA UN1/'+,-,'/
	INTEGER UN1C(2)
	  BYTE LUN1C(4,2)
	  EQUIVALENCE (UN1C,LUN1C)
	  DATA LUN1C/	1,48,1,0,2,48,1,0/
	CHARACTER*15 BIN2			!2 CHAR BINARY
	  DATA BIN2/'**,>=,<=,<>,><,'/
	INTEGER BIN2C(5)
	  BYTE LBIN2C(4,5)
	  EQUIVALENCE (BIN2C,LBIN2C)
	  DATA LBIN2C/	3,44,2,1,8,32,2,1,9,32,2,1,13,32,2,1,13,32,2,1/
	CHARACTER*20 BIN1			!1 CHAR BINARY
	  DATA BIN1/'+,-,*,/,<,>,=,!,&,^,'/
	INTEGER BIN1C(10)
	  BYTE LBIN1C(4,10)
	  EQUIVALENCE (BIN1C,LBIN1C)
	  DATA LBIN1C/	6,36,2,1,7,36,2,1,4,40,2,1,5,40,2,1,11,32,2,1,
	1			12,32,2,1,10,32,2,1,16,20,2,1,15,20,2,1,
	1			3,44,2,1/
	INTEGER PLTC				!PLOT
	  BYTE LPLTC(4)
	  EQUIVALENCE (PLTC,LPLTC)
	  DATA LPLTC/	17,0,0,-1/
	INTEGER VALC				!CONSTANT VALUE
	  BYTE LVALC(4)
	  EQUIVALENCE (VALC,LVALC)
	  DATA LVALC/	18,0,0,-1/
	INTEGER BRC				!(
	  BYTE LBRC(4)
	  EQUIVALENCE (BRC,LBRC)
	  DATA LBRC/	40,60,0,0/
	INTEGER RBRC				!)
	  BYTE LRBRC(4)
	  EQUIVALENCE (RBRC,LRBRC)
	  DATA LRBRC/	32,0,0,0/
	INTEGER COMC				!,
	  BYTE LCOMC(4)
	  EQUIVALENCE (COMC,LCOMC)
	  DATA LCOMC/	30,0,0,0/
	INTEGER FINC				!FINISH
	  BYTE LFINC(4)
	  EQUIVALENCE (FINC,LFINC)
	  DATA LFINC/	31,0,0,0/
	CHARACTER*6 NAML(NFUNCT)
	  DATA NAML/'SIN','COS','ATAN','ASIN','ACOS',
	1		'EXP','EXP10','EXP2','LOG','LOG10','LOG2',
	1		'PI','EE','ABS','FLOOR','CEIL','ROUND',
	1		'INT','FRACT','REAL','IMAG','AMPL','PHASE',
	1		'SQRT','HA','UT','IMUL','CC','DRAD',
	1		'FQ','BL','UU','VV','RA','DEC'/
	INTEGER NAMC(NFUNCT)
	  BYTE LNAMC(4,NFUNCT)
	  EQUIVALENCE (NAMC,LNAMC)
C
C CODED AS: FUNCTION NUMBER, PRIORITY, # OF ARGUMENTS NECESSARY, # OF VALUES
C		PRODUCED
C
	  DATA LNAMC/		52,60,1,1,53,60,1,1,50,60,1,1,	!SIN,COS,ATAN
	1			54,60,1,1,55,60,1,1,56,60,1,1,	!ASIN,ACOS,EXP
	1			57,60,1,1,58,60,1,1,59,60,1,1,	!EXP10,EXP2,LOG
	1			60,60,1,1,61,60,1,1,62,60,0,1,	!LOG10,LOG2,PI
	1			63,60,0,1,64,60,1,1,65,60,1,1,	!EE,ABS,FLOOR
	1			66,60,1,1,67,60,1,1,68,60,1,1,	!CEIL,ROUND,INT
	1			69,60,1,1,70,60,1,1,71,60,1,1,	!FRACT,REAL,IMAG
	1			72,60,1,1,73,60,1,1,74,60,1,1,	!AMPL,PHASE,SQRT
	1			75,60,0,1,76,60,0,1,77,60,1,1,	!HA,UT,IMUL
	1			78,60,0,1,79,60,0,1,80,60,0,1,	!CC,DRAD,FQ
	1			81,60,0,1,82,60,0,1,83,60,0,1,	!BL,UU,VV
	1			84,60,0,1,85,60,0,1/		!RA,DEC
C
	CHARACTER*256 STR			!EXPRESSION STRING
	CHARACTER*6 NAM				!FUNCTION NAME
	INTEGER TCOD				!STACK CODE
	  BYTE LTCOD(4)
	  EQUIVALENCE (TCOD,LTCOD)
	INTEGER STP				!STRING POINTER
	INTEGER CDP				!CODE POINTER
	INTEGER RPS(512)			!REVERSE POLISH STACK
	  BYTE LRPS(4,512)
	  EQUIVALENCE (RPS,LRPS)
	INTEGER RPP				!RPS POINTER
	INTEGER NVAL				!# OF VALUES ON STACK
	INTEGER LRPP				!CURRENT LOW RPP
	INTEGER JJ1,JJ2
C-
C
C INIT OUTPUT
C
	NGCEXP=.TRUE.				!ASSUME OK
	OUTSTR=' '				!ANALYZED STRING
	NPLT=0					!PLOTS PRODUCED
	STR=INSTR				!MAKE SURE ALL USABLE
	STR(LEN(STR)-1:)=' '
C
C COMPRESS ETC. STRING
C
 10	CONTINUE
	J=INDEX(STR,'	')			!DELETE TABS
	IF (J.GT.0) THEN
	  STR(J:J)=' '
	  GOTO 10
	END IF
 12	CONTINUE
	J=INDEX(STR,'"')			!DELETE "
	IF (J.GT.0) THEN
	  STR(J:J)=' '
	  GOTO 12
	END IF
	DO I=1,LEN(STR)				!DELETE SPACES
	  IF (STR(I:).EQ.' ') GOTO 11		!READY
	  DO WHILE (STR(I:I).EQ.' ')
	    DO I1=I,LEN(STR)-1
	      STR(I1:I1)=STR(I1+1:I1+1)
	    END DO
	  END DO
	END DO
 11	CONTINUE
	CALL WNCAUC(STR)			!CONVERT TO CAPITAL
C
C INIT
C
	STP=1					!STRING POINTER
	NVAL=0					!# OF VALUES ON STACK
	RPP=0					!RPS POINTER
	LRPP=0					!LOW CURRENT RPP
	CDP=0					!CODE POINTER
C
C UNARY OPERATORS
C
 20	CONTINUE
	J=INDEX(UN2,STR(STP:STP+1)//',')	!LOOK
	IF (J.GT.0) THEN
	  J1=2					!LENGTH OPERATOR
	  TCOD=UN2C((J+2)/3)			!EXECUTE CODE
 21	  CONTINUE
	  IF (.NOT.NGCEX1(TCOD,LTCOD,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL))
	1			GOTO 23		!SET CODE
 22	  CONTINUE
	  IF (NGCEX2(J1,STR,STP)) THEN
	    GOTO 20				!MORE
	  ELSE
 23	    CONTINUE
	    NGCEXP=.FALSE.			!ERROR
 25	    CONTINUE
	    OUTSTR=STR(:STP)			!ANALYZED PART OF INPUT
C
	    RETURN
C
	  END IF
	END IF
C
	J=INDEX(UN1,STR(STP:STP)//',')		!1 CHAR. UNARY
	IF (J.GT.0) THEN
	  J1=1					!LENGTH OPERATOR
	  TCOD=UN1C((J+1)/2)			!EXECUTE CODE
	  GOTO 21				!SET CODE
	END IF
C
C (
C
	IF (STR(STP:STP).EQ.'(') THEN
 24	  CONTINUE
	  IF (.NOT.NGCEX1(BRC,LBRC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL))
	1			GOTO 23		!SET CODE
 26	  CONTINUE
	  J1=1					!SKIP
	  GOTO 22
	END IF
C
C VALUE
C
	IF (STR(STP:STP).EQ.'#') THEN		!PLOT
	  IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!ERROR
	  IF (STR(STP:STP).EQ.'#') THEN		!SKIP DO LOOP
	    IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!SKIP #
	    J2=NGCSDL				!INDICATE SKIP
	  ELSE
	    J2=0				!ACCEPT DO LOOP
	  END IF
	  IF (.NOT.WNCATD(STR,STP)) GOTO 23	!ERROR
	  IF (.NOT.WNCACU(STR,STP,10,D0,D1)) GOTO 23 !GET PLOT #
	  JJ1=NINT(D0)
	  JJ1=JJ1+J2
	  JJ2=1
	  DO WHILE(JJ2.LE.NPLT .AND. PLT(JJ2).NE.JJ1)
	    JJ2=JJ2+1
	  END DO
	  IF (JJ2.GT.NPLT) THEN
	    NPLT=NPLT+1				!NEW PLOT
	    PLT(NPLT)=JJ1			!REFERENCE
	    J1=NPLT
	  ELSE
	    J1=JJ2				!REFERENCE
	  END IF
 30	  CONTINUE
	  CALL NGCEX4(PLTC,LPLTC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL) !PLOT CODE
	  CALL NGCEX4(J1,J1,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL) !PLOT NUMBER
	ELSE IF (WNCATD(STR,STP) .OR. STR(STP:STP).EQ.'.') THEN !VALUE
	  IF (.NOT.WNCACU(STR,STP,10,D0,D1)) GOTO 23 !INTEGER PART
	  R0=NINT(D0)
	  IF (STR(STP:STP).EQ.'.') THEN		!FRACTION
	    IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!SKIP .
	    J=STP				!FOR FRACTION
	    IF(.NOT.WNCACU(STR,STP,10,D0,D1)) GOTO 23 !FRACTION
	    J1=NINT(D0)
	    R0=R0+J1*(10.**(J-STP))		!VALUE
	  END IF
	  IF (STR(STP:STP).EQ.'E') THEN		!EXPONENT
	    J=0					!SIGN
 31	    CONTINUE
	    IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!SKIP E,+,-
	    IF (STR(STP:STP).EQ.'+') THEN	!+
	      GOTO 31
	    ELSE IF (STR(STP:STP).EQ.'-') THEN	!-
	      J=MOD(J+1,2)			!SET SIGN
	      GOTO 31
	    END IF
	    IF (.NOT.WNCATD(STR,STP)) GOTO 23	!ERROR
	    IF (.NOT.WNCACU(STR,STP,10,D0,D1)) GOTO 23 !EXPONENT
	    J1=NINT(D0)
	    IF (J1.NE.0) J1=-J1			!SIGN
	    R0=R0*(10.**MIN(38,J1))		!VALUE
	  END IF
	  CALL NGCEX4(VALC,LVALC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL) !VALUE CODE
	  CALL NGCEX4(R0,R0,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL) !VALUE
	ELSE IF(WNCATA(STR,STP)) THEN		!NAME
	  IF (.NOT.WNCAFN(STR,STP,NAM)) GOTO 23	!GET NAME
	  DO I=1,NFUNCT				!SEE IF OK
	    IF (NAML(I).EQ.NAM) THEN		!FOUND
	      J=I
	      GOTO 32
	    END IF
	  END DO
	  GOTO 23				!NAME NOT FOUND
 32	  CONTINUE
	  IF (.NOT.NGCEX1(NAMC(J),LNAMC(1,J),COD,CDP,RPS,LRPS,RPP,
	1		LRPP,NVAL)) GOTO 23	!SET NAME
	  IF (STR(STP:STP).NE.'(') GOTO 41	!FINISH FUNCTION
	  GOTO 26				!SKIP (
	ELSE
	  GOTO 23				!ERROR
	END IF
	NVAL=NVAL+1				!COUNT VALUES
C
C BINARY OPERATOR
C
 40	CONTINUE
	IF (STR(STP:).EQ.' ') THEN		!END
	  IF (.NOT.NGCEX1(FINC,LFINC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL))
	1			GOTO 23		!SET FINAL CODE
	  GOTO 25				!READY
	ELSE IF (STR(STP:STP).EQ.')') THEN	!FINISH SUBEXPRESSION
	  IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!SKIP )
 41	  CONTINUE
	  IF (.NOT.NGCEX1(RBRC,LRBRC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL))
	1			GOTO 23		!SET CODE FOR )
	  GOTO 40				!CONTINUE
	ELSE IF (STR(STP:STP).EQ.',') THEN	!ARGUMENT SUBEXPRESSION
	  IF (.NOT.NGCEX2(1,STR,STP)) GOTO 23	!SKIP ,
	  IF (.NOT.NGCEX1(COMC,LCOMC,COD,CDP,RPS,LRPS,RPP,LRPP,NVAL))
	1			GOTO 23		!SET CODE FOR ,
	ELSE IF (INDEX(BIN2,STR(STP:STP+1)//',').GT.0) THEN !2 CHAR BINARY
	  J=INDEX(BIN2,STR(STP:STP+1)//',')	!LOCATE
	  J1=2
	  TCOD=BIN2C((J+2)/3)			!EXECUTE CODE
	  GOTO 21				!SET CODE
	ELSE IF (INDEX(BIN1,STR(STP:STP)//',').GT.0) THEN !1 CHAR BINARY
	  J=INDEX(BIN1,STR(STP:STP)//',')	!LOCATE
	  J1=1
	  TCOD=BIN1C((J+1)/2)			!EXECUTE CODE
	  GOTO 21				!SET CODE
	ELSE
	  GOTO 23				!ERROR
	END IF
C
	GOTO 20					!NEXT SUBEXPRESSION
C
C
	END

C+ WNCATA.FOR
C  WNB 890427
C
C  Revisions:
C	WNB 911118	DW DATA statement problems
C	WNB 911118	DW split into ATA and AT0
C	HjV 920520	HP does not allow extended source lines
C
	LOGICAL FUNCTION WNCATA(STR,PT)
C
C  Get type of character
C
C  Result:
C
C	WNCATA_L = WNCATA( STR_C*:I, PT_J:I)  Test if character STR(PT:PT)
C					      alpha (a-zA-Z)
C	WNCASA_L = WNCASA( STR_C*:I, PT_J:IO) Same, but PT+1 if true
C	WNCATD_L = WNCATD( STR_C*:I, PT_J:I)  Test for digit (0-9)
C	WNCASD_L = WNCASD( STR_C*:I, PT_J:IO) Same but PT+1 if true
C	WNCATN_L = WNCATN( STR_C*:I, PT_J:I)  Test name char. (a-zA-Z_$)
C	WNCASN_L = WNCASN( STR_C*:I, PT_J:IO) Same but PT+1 if true
C	WNCATS_L = WNCATS( STR_C*:I, PT_J:I)  Test separator (, followed blank)
C	WNCASS_L = WNCASS( STR_C*:I, PT_J:IO) Same but PT+n if true
C	WNCATB_L = WNCATB( STR_C*:I, PT_J:I)  Test blanks
C	WNCASB_L = WNCASB( STR_C*:I, PT_J:IO) Same but PT+n if true
C	WNCATC_L = WNCATC( STR_C*:I, PT_J:I, CH_C*:I) Test for character CH(1:1)
C	WNCASC_L = WNCASC( STR_C*:I, PT_J:IO,CH_C*:I) Same but PT+1 if true
C	WNCATM_L = WNCATM( STR_C*:I, PT_J:I, CH_C*:I) Test for characters CH
C	WNCASM_L = WNCASM( STR_C*:I, PT_J:IO,CH_C*:I) Same but PT+1 if true
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	CHARACTER*(*) STR				!INPUT STRING
	INTEGER PT					!STRING POINTER
	CHARACTER *(*) CH				!CHECK CHARACTER
C
C  Entry points:
C
	LOGICAL WNCASA,WNCATD,WNCASD,WNCATN,WNCASN	!CHARACTER TESTS
	LOGICAL WNCATB,WNCASB,WNCATC,WNCASC,WNCATS,WNCASS !CHARACTER TESTS
	LOGICAL WNCATM,WNCASM
C
C  Function references:
C
C
C  Data declarations:
C
	CHARACTER*52 ALPH
	CHARACTER*10 DIG
	CHARACTER*2 XALPH
	CHARACTER*1 SEP
	  DATA ALPH(01:26)/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
	  DATA ALPH(27:52)/'abcdefghijklmnopqrstuvwxyz'/
	  DATA DIG/'0123456789'/
	  DATA XALPH/'_$'/
	  DATA SEP/','/
C-
C
C WNCATA
C
	WNCATA=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATA=INDEX(ALPH,STR(PT:PT)).GT.0
	END IF
C
	RETURN
C
C WNCASA
C
	ENTRY WNCASA(STR,PT)
C
	WNCASA=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  I=INDEX(ALPH,STR(PT:PT))
	  IF (I.GT.0) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASA=.TRUE.
	  END IF
	END IF
C
	RETURN
C
C WNCATD
C
	ENTRY WNCATD(STR,PT)
C
	WNCATD=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATD=INDEX(DIG,STR(PT:PT)).GT.0
	END IF
C
	RETURN
C
C WNCASD
C
	ENTRY WNCASD(STR,PT)
C
	WNCASD=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  I=INDEX(DIG,STR(PT:PT))
	  IF (I.GT.0) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASD=.TRUE.
	  END IF
	END IF
C
	RETURN
C
C WNCATN
C
	ENTRY WNCATN(STR,PT)
C
	WNCATN=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATN=INDEX(ALPH//XALPH,STR(PT:PT)).GT.0
	END IF
C
	RETURN
C
C WNCASN
C
	ENTRY WNCASN(STR,PT)
C
	WNCASN=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  I=INDEX(ALPH//XALPH,STR(PT:PT))
	  IF (I.GT.0) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASN=.TRUE.
	  END IF
	END IF
C
	RETURN
C
C WNCATB
C
	ENTRY WNCATB(STR,PT)
C
	WNCATB=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATB=ICHAR(STR(PT:PT)).LE.ICHAR(' ')
	END IF
C
	RETURN
C
C WNCASB
C
	ENTRY WNCASB(STR,PT)
C
	WNCASB=.FALSE.					!ASSUME ERROR
	DO WHILE (PT.LE.LEN(STR))
	  IF (ICHAR(STR(PT:PT)).LE.ICHAR(' ')) THEN
	    WNCASB=.TRUE.
	    PT=PT+1
	  ELSE
	    GOTO 10					!READY
	  END IF
	END DO
 10	CONTINUE
C
	RETURN
C
C WNCATS
C
	ENTRY WNCATS(STR,PT)
C
	WNCATS=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATS=INDEX(SEP,STR(PT:PT)).GT.0
	END IF
C
	RETURN
C
C WNCASS
C
	ENTRY WNCASS(STR,PT)
C
	WNCASS=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  I=INDEX(SEP,STR(PT:PT))
	  IF (I.GT.0) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASS=.TRUE.
	  END IF
	END IF
	DO WHILE (PT.LE.LEN(STR))			!SKIP BLANKS
	  IF (ICHAR(STR(PT:PT)).GT.ICHAR(' ')) GOTO 20
	  PT=PT+1
	END DO
 20	CONTINUE
C
	RETURN
C
C WNCATC
C
	ENTRY WNCATC(STR,PT,CH)
C
	WNCATC=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATC=STR(PT:PT).EQ.CH(1:1)
	END IF
C
	RETURN
C
C WNCASC
C
	ENTRY WNCASC(STR,PT,CH)
C
	WNCASC=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  IF (STR(PT:PT).EQ.CH(1:1)) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASC=.TRUE.
	  END IF
	END IF
C
	RETURN
C
C WNCATM
C
	ENTRY WNCATM(STR,PT,CH)
C
	WNCATM=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  WNCATM=INDEX(CH,STR(PT:PT)).GT.0
	END IF
C
	RETURN
C
C WNCASM
C
	ENTRY WNCASM(STR,PT,CH)
C
	WNCASM=.FALSE.					!ASSUME ERROR
	IF (PT.LE.LEN(STR)) THEN			!CAN DO
	  IF (INDEX(CH,STR(PT:PT)).GT.0) THEN
	    PT=PT+1					!SKIP CHARACTER
	    WNCASM=.TRUE.
	  END IF
	END IF
C
	RETURN
C
C
	END

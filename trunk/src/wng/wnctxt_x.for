C+ WNCTXT_X.FOR
C  WNB 880725
C
C  Revisions:
C	WNB 911115	DW: CHARACTER DATA problem; \ problem
C	HjV 920520	HP does not allow extended source lines
C	WNB 930520	Remove %VAL
C	CMV 940315	Actually implement !AF format
C	CMV 940516	Change AF test from CHAR to ICHAR (bug on sw)
C	JPH 960531	Expand description of ", " array-element separator and
C			!Q1 specifier
C	JPH 960612	Expand description of EHc specifier
C
C
	SUBROUTINE WNCTXT_X(CODE,TXT,ARGL)
C
C  Print/type string with formatting (FAO with extensions) information.
C
C  Result:
C
C	CALL WNCTXT_X( CODE_J:I, TXT_C*:I, ARGL_J(-*:*):I)
C				Print (bit1=1 of CODE) and/or type (bit0=1)
C				and/or output to file (bit8-31=1)
C				the string, using the arguments specified
C				in the ARGL argument list, as interpreted
C				by the TXT string (see later for codes).
C	CALL WNCTXS_X( OST_C*:O, TXT_C*:I, ARGL_J(-*:*):I) Write to string OST
C
C	The WNCTXT and WNCTXS calls are in WNCTXT.FOR
C
C	The TXT string will be copied to the specified output(s) without
C	modification, unless formatting information is present. A format
C	item has the form:
C		![w$][r]cd[v][.s][\]	where each field specifies:
C			!	start of format item
C			w	width of output field. An output string will
C				be right (w>=0) or left (w<0) justified in
C				field with width |w|. Default: 0, i.e.
C				depending on output generated by cd.
C				w should be an optionally signed integer.
C			r	repeat factor. Each cd is repeated r times
C				assuming the possibly corresponding argument
C				to be an array.	r should be an unsigned integer.
C				Default: r=0, i.e. one value is output.
C				Multiple fields generated with r>1 will be 
C				separated by ", ". This separator may be
C				suppressed by a !Q1 specifier, see below.
C			v	optional cd modifier. Default: 0.
C				v should be an unsigned integer
C			s	optional cd specifier. Default: 0.
C				s should be an unsigned integer
C			\	optional format end indicator. Produces no
C				output, but necessary if next character in
C				TXT could be interpreted as part of current
C				format item.
C				MAY ALSO BE A /
C			#	the values w, r, v and s can be specified
C				as # i.s.o. an integer. The corresponding
C				value is then taken from the next argument
C				in the ARGL, interpreting it as an INTEGER
C				value.
C			##	As #, but interpretation will be an INTEGER*2.
C				NOTE: Order of arguments taken in list:
C					w,r,v,s,cd. If argument not present
C					for cd, it is an error, and conversion
C					stops. In the other cases 0 assumed.
C			cd	the operational code. It can be one of the
C				following format codes:
C				!		output !
C				*c		output character c
C				-		backskip argument in ARGL
C				+		forward skip argument in ARGL
C				/		insert new line (<CR><LF> TXS)
C				_		insert TAB (stops at 9,17...)
C				^		insert new page
C				%D		set date as dd-mmm-yy
C				%T		set time as hh:mm:ss
C				%DF		set date as dd-mmm-yyyy
C				%TF		set time as hh:mm:ss.ss
C				%DN		set date as yymmdd
C				%TN		set time as hhmmss
C				AC AD AF AZ AS	ASCII string: counted (AC),
C					    A	descriptor (AD), descriptor
C						with conversion to . of
C						non-printables and spaces (AF),
C						address of descriptor (AS), 
C						ASCIZ (AZ).
C						AS is the standard Fortran
C						string, AC=nnnncccc... with
C						n length string following,
C						AD,AD+1=cccc...,n(J), AF same,
C						AZ=ccccc....0.
C				ALv		ASCII string of length v at
C						specified address
C				SB SI SJ SK 	convert next arg of byte, word
C				   SW S	 SL	or longword type to signed
C				      		decimal
C				UB UI UJ UK	convert next arg to unsigned
C				   UW U  UL	decimal
C				      
C				OB OI OJ OK	convert next arg to octal
C				   OW O  OL
C				      
C				XB XI XJ XK	convert next arg to hexadecimal
C				   XW X  XL
C				      
C				ZB ZI ZJ ZK	convert next argument to zero
C				   ZW Z  ZL	filled decimal number
C				      
C				LB LI LJ LK	convert next arg to YES or NO
C				   LW L  LL	low order bit=0: no, =1:yes
C				      
C				E[v]		interprete next argument as
C						REAL, and convert it to G-like
C						format with v significant
C						digits. If v=0 enough digits
C						given to indicate real value.
C				E[[v].s]	interprete next argument as
C						REAL, and convert it to F-like
C						format with s digits after
C						decimal ., and v total digits.
C				D[v] D[[v].s]	convert next double precision
C						arg.
C				EC[v] EC[[v].s]	convert next COMPLEX arg.
C				DC[v] DC[[v].s]	convert next DOUBLE COMPLEX arg.
C				EAc[[v][.s]]	convert an angle of type c
C						to degrees (-180<angle<180)
C						and do as E.
C						c can be F (fraction of circles)
C						R (radians), D (degrees) or
C						empty (radians).
C				EPc[[v][.s]]	as EA but 0<=angle<360.
C				EDc[v]		convert an angle to d.m.s.tt...,
C						and round to d (v<3), m (v<5),
C						s (v<7) or tenths. (Def: v=6)
C				EHc[v]		convert an angle to h:m:s.tt...,
C						rounding as ED. v is the number
C						of digits, not counting the
C						colons and dots; thus v-6 is the
C						number of fraction digits tt...
C					
C				DAc[[v][.s]]	double precision angles
C				DPc[[v][.s]]
C				DDc[v]
C				DHc[v]
C				F...		identical to all E formats
C				[r]C		Position at column r. (Def: r=1)
C				[w$][r]Q[v]	Format: Limit repeats to line
C						width w, and offset next line at
C						r. 
C						If v=1: the ", " separator
C						between array elements is
C						suppressed
C
C				Note: TAB, CR, LF, FF etc are not acted upon if
C				      embedded in TXT.
C
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
C
C  Parameters:
C
	INTEGER OUTLEN				!MAX. OUTPUT LINE LENGTH
	  PARAMETER (OUTLEN=512)
	CHARACTER*1 FF				!FF
C	  PARAMETER (FF=ICHAR(12))               !Not allowed anymore
	CHARACTER*1 CR				!CR
C	  PARAMETER (CR=CHAR(13))               !Not allowed anymore
	CHARACTER*1 LF				!LF
C	  PARAMETER (LF=CHAR(10))               !Not allowed anymore
	CHARACTER*1 BACKS			!\
C	  PARAMETER (BACKS=CHAR(92))            !Not allowed anymore
C
C  Arguments:
C
	INTEGER CODE				!PRINT/TYPE CODE
	CHARACTER*(*) TXT			!TEXT TO BE CONVERTED, OUTPUT
	CHARACTER*(*) OST			!OUTPUT STRING FOR WNCTXS
	INTEGER ARGL(0:*)			!ARGUMENTS LIST
C
C  Function references:
C
	INTEGER WNCAL0				!ACTUAL LENGTH STRING
	INTEGER WNCALZ				!ACTUAL LENGTH ASCIZ STRING
	INTEGER WNCAJA				!GET INTEGER FROM STRING
	CHARACTER*1 WNCAUP			!CONVERT TO UC
	INTEGER WNGASA				!ADDRESS OF STRING
	INTEGER WNGASL				!LENGTH OF STRING
C
C  Data declarations:
C
	CHARACTER*(OUTLEN) CHLP			!INTERNAL CONVERSION
	CHARACTER*(OUTLEN) OUT			!OUTPUT STRING
	LOGICAL OPS				!SWITCH WRCTXT TYPE
	INTEGER LARG,PARG			!LENGTH/POINTER ARGUMENT LIST
	INTEGER LTXT,PTXT			!LENGTH/POINTER TXT
	INTEGER LOUT,POUT			!LENGTH/POINTER OUTPUT LINE
	INTEGER LOST,POST			!LENGTH/POINTER OST STRING
	INTEGER WVAL				!FIELD WIDTH
	INTEGER RVAL				!REPEAT VALUE
	INTEGER VVAL				!MODIFIER VALUE
	INTEGER SVAL				!SUBJECT VALUE
	LOGICAL DOT				!. SEEN
	INTEGER MIND				!MAIN TYPE INDEX
	INTEGER SIND,SIND2			!SECONDARY INDICES
	INTEGER LSPEC(4)			!Q FORMAT
	CHARACTER*21 GCOD			!MAIN CODE LIST
	CHARACTER*6 ASCOD			!A CODE LIST
	CHARACTER*6 SSCOD			!S,U,O,X,Z,L CODE LIST
	CHARACTER*5 ESCOD			!E,F,D CODE LIST
	CHARACTER*3 DSCOD			!ANGLE CODE LIST
	CHARACTER*2 CRLF			!CR AND LF
	  DATA GCOD/'!*-+/_^%CASUOXZLEFDQ@'/
C		     123456789012345678901
	  DATA ASCOD/'CDFSZL'/
C		      123456
	  DATA SSCOD/'BWLIJK'/
C		      123456
	  DATA ESCOD/'CADHP'/
C		      12345
	  DATA DSCOD/'FRD'/
C		      123
C
C  Equivalences:
C
C
C  Commons:
C
C-
C
C WNCTXT_X
C
	OPS=.FALSE.				!NOT OUTPUT STRING
	IF (IAND(F_ALL,CODE).EQ.0) RETURN	!NO OUTPUT WANTED
	GOTO 10
C
C WNCTXS_X
C
	ENTRY WNCTXS_X(OST,TXT,ARGL)
C
	OPS=.TRUE.				!OUTPUT STRING
	LOST=LEN(OST)				!LENGTH
	I=WNGASL(1,ARGL(0))			!INDICATE STRING FOR CONVEX
	POST=0					!POINTER
	OST=' '					!EMPTY STRING	
	GOTO 10
C
C Initialize
C
 10	CONTINUE
C
        FF = CHAR(12)
        CR = CHAR(13)
        CRLF(1:1) = CR
        LF = CHAR(10)
        CRLF(2:2) = LF
        BACKS = CHAR(92)
C
	I=WNGASL(2,ARGL(0))			!INDICATE STRING FOR CONVEX
	LARG=ARGL(0)				!# OF ARGUMENTS
	PARG=2					!POINTER IN ARGL
	LTXT=WNCAL0(TXT)			!LENGTH TEXT
	PTXT=0					!POINTER
	LSPEC(1)=0				!Q WIDTH
	LSPEC(2)=1				!Q OFFSET
	LSPEC(3)=0				!Q , SEPARATION
	LSPEC(4)=0
C
C Scan text
C
 20	LOUT=OUTLEN				!LENGTH OUTPUT LINE
	POUT=0					!POINTER
	OUT=' '					!EMPTY LINE
C
C If end
C
 23	IF (PTXT.GE.LTXT) THEN			!NO MORE
	  IF (OPS) THEN				!OUTPUT STRING
	    CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	  ELSE					!WRITE LINE
	    CALL WNCOUT(CODE,OUT,1,POUT)
	  END IF
C
	  RETURN				!READY
	END IF
C
C Find format
C
	J=INDEX(TXT(PTXT+1:LTXT),'!')		!FIND FORMAT
	IF (J.EQ.0) THEN			!NO MORE FORMAT
 21	  CALL WNCSAD(TXT,PTXT+1,LTXT,OUT,LOUT,POUT) !WRITE LAST PART
	  PTXT=LTXT
	  GOTO 23				!FINISH
	END IF
C
C Analyze code
C
	CALL WNCSAD(TXT,PTXT+1,PTXT+J-1,OUT,LOUT,POUT) !SET TILL !
	PTXT=PTXT+J				!! PTR
	J1=PTXT-1				!SAVE POSITION !
	J2=PARG					!SAVE ARG POSITION
	WVAL=WNCAJA(TXT,LTXT,PTXT,ARGL(0),LARG,PARG) !GET WIDTH
	IF (PTXT.LT.LTXT) THEN			!CAN BE OK
	  IF (TXT(PTXT+1:PTXT+1).EQ.'$') THEN	!REAL WIDTH
	    PTXT=PTXT+1				!SKIP $
	    RVAL=WNCAJA(TXT,LTXT,PTXT,ARGL(0),LARG,PARG) !GET REPEAT
	  ELSE
	    RVAL=WVAL				!SET REPEAT VALUE
	    WVAL=0
	  END IF
	ELSE
 22	  PTXT=J1				!RESTORE FOR FORMAT ERROR
	  PARG=J2
	  GOTO 21
	END IF
	RVAL=MIN(OUTLEN,MAX(1,RVAL))		!CORRECT REPEAT FACTOR
	WVAL=MAX(-OUTLEN,MIN(OUTLEN,WVAL))	!CORRECT WIDTH
	IF (PTXT.GE.LTXT) GOTO 22		!FORMAT ERROR
	MIND=INDEX(GCOD,WNCAUP(TXT(PTXT+1:PTXT+1))) !GET CODE
	IF (MIND.EQ.0) GOTO 22			!UNKNOWN CODE
	PTXT=PTXT+1				!SKIP CODE
	IF (MIND.EQ.1 .OR.			!!
	1		MIND.EQ.3 .OR.		!-
	2		MIND.EQ.4 .OR.		!+
	3		MIND.EQ.5 .OR.		!/
	4		MIND.EQ.6 .OR.		!_
	5		MIND.EQ.7 .OR.		!^
	6		MIND.EQ.20 .OR.		!Q
	8		MIND.EQ.21 .OR.		!@
	7		MIND.EQ.9) THEN		!C READY
	ELSE IF (MIND.EQ.2) THEN		!*
	  IF (PTXT.GE.LTXT) GOTO 22		!FORMAT ERROR
	  PTXT=PTXT+1
	  SIND=ICHAR(TXT(PTXT:PTXT))		!SAVE CHARACTER
	ELSE IF (MIND.EQ.8) THEN		!%
	  IF (PTXT.GE.LTXT) GOTO 22		!FORMAT ERROR
	  PTXT=PTXT+1
	  IF (WNCAUP(TXT(PTXT:PTXT)).EQ.'D') THEN !%D
	    SIND=0
	  ELSE IF (WNCAUP(TXT(PTXT:PTXT)).EQ.'T') THEN !%T
	    SIND=3
	  ELSE
	    GOTO 22				!FORMAT ERROR
	  END IF
	  IF (PTXT.LT.LTXT) THEN
	    IF (WNCAUP(TXT(PTXT+1:PTXT+1)).EQ.'F') THEN
	      SIND=SIND+1
	      PTXT=PTXT+1
	    ELSE IF (WNCAUP(TXT(PTXT+1:PTXT+1)).EQ.'N') THEN
	      SIND=SIND+2
	      PTXT=PTXT+1
	    END IF
	  END IF
	ELSE IF (MIND.EQ.10) THEN		!A
	  SIND=0
	  IF (PTXT.LT.LTXT) THEN
	    SIND=INDEX(ASCOD,WNCAUP(TXT(PTXT+1:PTXT+1)))
	    IF (SIND.NE.0) PTXT=PTXT+1
	  END IF
	ELSE IF (MIND.EQ.11 .OR.		!S
	1		MIND.EQ.12 .OR.		!U
	2		MIND.EQ.13 .OR.		!O
	3		MIND.EQ.14 .OR.		!X
	4		MIND.EQ.15 .OR.		!Z
	5		MIND.EQ.16) THEN	!L
	  SIND=0
	  IF (PTXT.LT.LTXT) THEN
	    SIND=INDEX(SSCOD,WNCAUP(TXT(PTXT+1:PTXT+1)))
	    IF (SIND.NE.0) PTXT=PTXT+1
	  END IF
	ELSE IF (MIND.EQ.17 .OR.		!E
	1		MIND.EQ.18 .OR.		!F
	2		MIND.EQ.19) THEN	!D
	  SIND=0
	  IF (PTXT.LT.LTXT) THEN
	    SIND=INDEX(ESCOD,WNCAUP(TXT(PTXT+1:PTXT+1)))
	    IF (SIND.NE.0) PTXT=PTXT+1
	    IF (SIND.GT.1) THEN
	      SIND2=0
	      IF (PTXT.LT.LTXT) THEN
		SIND2=INDEX(DSCOD,WNCAUP(TXT(PTXT+1:PTXT+1)))
		IF (SIND2.NE.0) PTXT=PTXT+1
	      END IF
	    END IF
	  END IF
	ELSE
	  GOTO 22				!PROGRAMMING ERROR
	END IF
	VVAL=WNCAJA(TXT,LTXT,PTXT,ARGL(0),LARG,PARG) !GET MODIFIER
	DOT=.FALSE.
	IF (PTXT.LT.LTXT) THEN
	  IF (TXT(PTXT+1:PTXT+1).EQ.'.') THEN
	    DOT=.TRUE.				!SET . SEEN
	    PTXT=PTXT+1
	  END IF
	END IF
	SVAL=WNCAJA(TXT,LTXT,PTXT,ARGL(0),LARG,PARG) !GET SECONDARY MODIFIER
	VVAL=MAX(0,MIN(OUTLEN,VVAL))		!LIMIT VALUES
	SVAL=MAX(0,MIN(OUTLEN,SVAL))
	IF (PTXT.LT.LTXT) THEN
	  IF (TXT(PTXT+1:PTXT+1).EQ.BACKS.OR.
	1	TXT(PTXT+1:PTXT+1).EQ.'$') PTXT=PTXT+1 !SKIP TERMINATOR
	END IF
	IF (MIND.GE.10 .AND. MIND.NE.20.
	1  .AND. MIND.NE.21) THEN	!USE ARGUMENT
	  IF (PARG.GE.LARG) GOTO 22		!FORMAT ERROR
	  PARG=PARG+1				!POINT TO CORRECT ARGUMENT
	  IF (ARGL(PARG).EQ.0) GOTO 22		!FORMAT ERROR
	  IF (MIND.EQ.10 .AND. (SIND.EQ.2 .OR. SIND.EQ.3)) THEN !NEED 2 ARGS
	    IF (PARG.GE.LARG) GOTO 22		!FORMAT ERROR
	    PARG=PARG+1				!POINT TO CORRECT ARGUMENT
	    IF (ARGL(PARG).EQ.0) GOTO 22	!FORMAT ERROR
	  END IF
	END IF
C
C Do actual output
C
	GOTO (110,120,130,140,150,160,170,180,190,
	1		200,210,210,210,210,210,210,
	1		270,270,290,300,125) MIND
	GOTO 22					!PROGRAM ERROR
C !
 110	J=RVAL
	DO I=1,J				!SET !
	  CHLP(I:I)='!'
	END DO
 111	CALL WNCFAD(CHLP,WVAL,OUTLEN,J)		!ADJUST FIELD
	CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	GOTO 23					!GET NEXT FORMAT
C *
 120	J=RVAL
	DO I=1,J				!SET CHARACTERS
	  CHLP(I:I)=CHAR(SIND)
	END DO
	GOTO 111
C @
 125	J=RVAL
	DO I=1,J
	  CHLP(I:I)=CHAR(9)
	END DO
	CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	GOTO 23
C -
 130	IF (PARG.LE.2) GOTO 22			!FORMAT ERROR
	PARG=PARG-1				!RESET ARGUMENT
	GOTO 23					!NEXT FORMAT
C +
 140	IF (PARG.GE.LARG) GOTO 22		!FORMAT ERROR
	PARG=PARG+1				!RESET ARGUMENT
	GOTO 23					!NEXT FORMAT
C /
 150	IF (OPS) THEN				!STRING OUTPUT
	  CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	  DO I=1,RVAL
	    CALL WNCSAD(CRLF,1,2,OST,LOST,POST)	!SET CR/LF
	  END DO
	ELSE
	  CALL WNCOUT(CODE,OUT,1,POUT)		!WRITE LINE
	  DO I=1,RVAL-1				!WRITE EMPTY LINES
	    CALL WNCOUT(CODE,OUT,1,0)
	  END DO
	END IF
	GOTO 20					!NEW LINE
C _
 160	POUT=MIN(LOUT,8*((POUT/8)+RVAL))	!SET TAB
	GOTO 23
C ^
 170	IF (OPS) THEN				!STRING OUTPUT
	  CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	  DO I=1,RVAL
	    CALL WNCSAD(FF,1,1,OST,LOST,POST)	!SET FF
	  END DO
	ELSE
	  CALL WNCOUT(CODE,OUT,1,POUT)
	  DO I=1,RVAL				!OUTPUT FF
	    CALL WNCOUT(CODE,FF,1,1)
	  END DO
	END IF
	GOTO 20					!NEW LINE
C %
 180	IF (SIND.EQ.0) THEN			!SET DATE
	  CALL WNCDAT(CHLP,J)
	ELSE IF (SIND.EQ.1) THEN
	  CALL WNCDAF(CHLP,J)
	ELSE IF (SIND.EQ.2) THEN
	  CALL WNCDAN(CHLP,J)
	ELSE IF (SIND.EQ.3) THEN
	  CALL WNCTIM(CHLP,J)
	ELSE IF (SIND.EQ.4) THEN
	  CALL WNCTIF(CHLP,J)
	ELSE IF (SIND.EQ.5) THEN
	  CALL WNCTIN(CHLP,J)
	ELSE
	  GOTO 22				!PROGRAM ERROR
	END IF
	CALL WNCFAD(CHLP,WVAL,OUTLEN,J)		!ADJUST FIELD
	CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!OUTPUT FIELD
	DO I=1,RVAL-1
	  IF (LSPEC(3).EQ.0) CALL WNCSAD(', ',1,2,OUT,LOUT,POUT) !REPEAT
	  IF (LSPEC(1).GT.0 .AND. J+POUT.GT.LSPEC(1)) THEN !TOO LONG
	    IF (OPS) THEN			!STRING OUTPUT
	      CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	    ELSE
	      CALL WNCOUT(CODE,OUT,1,POUT)	!WRITE LINE
	    END IF
	    LOUT=OUTLEN				!LENGTH OUTPUT LINE
	    OUT=' '				!EMPTY LINE
	    POUT=MIN(LOUT,LSPEC(2)-1)		!SET COLUMN POINTER
	  END IF
	  CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)
	END DO
	GOTO 23					!NEXT FORMAT
C C
 190	J=POUT
	POUT=MIN(LOUT,RVAL-1)			!SET COLUMN
	IF (POUT.LT.LOUT .AND. POUT.LT.J) OUT(POUT+1:LOUT)=' '
	GOTO 23					!NEXT FORMAT
C A
 200	IF (SIND.EQ.0 .OR. SIND.EQ.4) THEN	!AS
	  I1=WNGASA(PARG,ARGL(0))		!STRING ADDRESS
	  I2=WNGASL(PARG,ARGL(0))		!STRING LENGTH
	ELSE IF (SIND.EQ.1) THEN		!AC
	  I1=ARGL(PARG)+4			!STRING ADDRESS
	  CALL WNGMV(4,A_B(ARGL(PARG)-A_OB),I2)	!STRING LENGTH
	ELSE IF (SIND.EQ.2 .OR. SIND.EQ.3) THEN	!AD, AF
	  I1=ARGL(PARG-1)			!STRING ADDRESS
	  CALL WNGMV(4,A_B(ARGL(PARG)-A_OB),I2)	!STRING LENGTH
	ELSE IF (SIND.EQ.5) THEN		!AZ
	  I1=ARGL(PARG)				!STRING ADDRESS
	  I2=WNCALZ(A_B(ARGL(PARG)-A_OB))	!STRING LENGTH
	ELSE IF (SIND.EQ.6) THEN		!AL
	  I1=ARGL(PARG)				!STRING ADDRESS
	  I2=VVAL				!STRING LENGTH
	ELSE
	  GOTO 22				!PROGRAM ERROR
	END IF
	CALL WNCCAS(CHLP,J,A_B(I1-A_OB),I2)	!MAKE STRING
	IF (SIND.EQ.3) THEN			!AF
	   DO I4=1,I2				!CHECK ALL CHARACTERS
	      IF (ICHAR(CHLP(I4:I4)).LE.32.OR.
	1	  ICHAR(CHLP(I4:I4)).GE.128) CHLP(I4:I4)='.' !REPLACE
	   END DO
	   J=I2
	END IF
	CALL WNCFAD(CHLP,WVAL,OUTLEN,J)		!FIELD ADJUST
	CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	DO I=1,RVAL-1				!REPEAT
	  IF (SIND.EQ.0 .OR. SIND.EQ.4) THEN	!AS
	    I1=I1+I2				!STRING ADDRESS
	  ELSE IF (SIND.EQ.1) THEN		!AC
	    I1=I1+I2+4				!STRING ADDRESS
	    CALL WNGMV(4,A_B(I1-4-A_OB),I2)	!STRING LENGTH
	  ELSE IF (SIND.EQ.2 .OR. SIND.EQ.3) THEN !AD, AF
	    I1=I1+I2				!STRING ADDRESS
	  ELSE IF (SIND.EQ.5) THEN		!AZ
	    I1=I1+I2+1				!STRING ADDRESS
	    I2=WNCALZ(A_B(I1-A_OB))		!STRING LENGTH
	  ELSE IF (SIND.EQ.6) THEN		!AL
	    I1=I1+I2				!STRING ADDRESS
	  END IF
	  CALL WNCCAS(CHLP,J,A_B(I1-A_OB),I2)	!MAKE STRING
	  IF (SIND.EQ.3) THEN			!AF
	    DO I4=1,I2				!CHECK ALL CHARACTERS
	      IF (ICHAR(CHLP(I4:I4)).LE.32.OR.
	1	  ICHAR(CHLP(I4:I4)).GE.128) CHLP(I4:I4)='.' !REPLACE
	    END DO
	    J=I2
	  END IF
	  CALL WNCFAD(CHLP,WVAL,OUTLEN,J)	!FIELD ADJUST
	  IF (LSPEC(3).EQ.0) CALL WNCSAD(', ',1,2,OUT,LOUT,POUT) !SET SEPARATOR
	  IF (LSPEC(1).GT.0 .AND. J+POUT.GT.LSPEC(1)) THEN !TOO LONG
	    IF (OPS) THEN			!STRING OUTPUT
	      CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	    ELSE
	      CALL WNCOUT(CODE,OUT,1,POUT)	!WRITE LINE
	    END IF
	    LOUT=OUTLEN				!LENGTH OUTPUT LINE
	    OUT=' '				!EMPTY LINE
	    POUT=MIN(LOUT,LSPEC(2)-1)		!SET COLUMN POINTER
	  END IF
	  CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	END DO
	GOTO 23					!NEXT FORMAT
C SUOXZL
 210	I1=ARGL(PARG)				!DATA POINTER
	IF (SIND.EQ.0 .OR. SIND.EQ.5) THEN	!J
	  I2=L_J/L_B				!DATA LENGTH
	ELSE IF (SIND.EQ.2 .OR. SIND.EQ.4) THEN	!I
	  I2=L_I/L_B
	ELSE IF (SIND.EQ.3 .OR. SIND.EQ.6) THEN	!K
	  I2=L_K/L_B
	ELSE					!B
	  I2=L_B/L_B
	END IF
	DO I=1,RVAL				!REPEAT
	  IF (I2.EQ.4) THEN			!K
	    CALL WNCCKS(CHLP,J,A_B(I1-A_OB),MIND-10)
	  ELSE IF (I2.EQ.2) THEN		!I
	    CALL WNCCIS(CHLP,J,A_B(I1-A_OB),MIND-10)
	  ELSE IF (I2.EQ.1) THEN		!B
	    CALL WNCCBS(CHLP,J,A_B(I1-A_OB),MIND-10)
	  ELSE					!J
	    CALL WNCCJS(CHLP,J,A_B(I1-A_OB),MIND-10)
	  END IF
	  I1=I1+I2				!NEXT POINTER
	  CALL WNCFAD(CHLP,WVAL,OUTLEN,J)	!ADJUST FIELD
	  IF (I.GT.1 .AND. LSPEC(3).EQ.0) 
	1		CALL WNCSAD(', ',1,2,OUT,LOUT,POUT)
	  IF (LSPEC(1).GT.0 .AND. I.GT.1 .AND. J+POUT.GT.LSPEC(1)) THEN !LONG
	    IF (OPS) THEN			!STRING OUTPUT
	      CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	    ELSE
	      CALL WNCOUT(CODE,OUT,1,POUT)	!WRITE LINE
	    END IF
	    LOUT=OUTLEN				!LENGTH OUTPUT LINE
	    OUT=' '				!EMPTY LINE
	    POUT=MIN(LOUT,LSPEC(2)-1)		!SET COLUMN POINTER
	  END IF
	  CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	END DO
	GOTO 23					!NEXT FORMAT
C EF
 270	I1=ARGL(PARG)				!DATA ADDRESS
	IF (DOT) THEN				!SET FORMAT
	  I2=SVAL
	ELSE
	  I2=-1
	END IF
	DO I=1,RVAL				!REPEAT
	  IF (SIND.EQ.0) THEN			!NORMAL
	    CALL WNCCES(CHLP,J,A_B(I1-A_OB),VVAL,I2)
	  ELSE IF (SIND.EQ.1) THEN		!COMPLEX
	    CALL WNCCXS(CHLP,J,A_B(I1-A_OB),VVAL,I2)
	    I1=I1+4				!NEXT POINTER
	  ELSE					!ANGLE
	    IF (SIND2.EQ.0) SIND2=2
	    CALL WNCCAE(CHLP,J,SIND2,SIND,A_B(I1-A_OB),VVAL,I2)
	  END IF
	  I1=I1+4				!NEXT POINTER
	  CALL WNCFAD(CHLP,WVAL,OUTLEN,J)	!ADJUST FIELD
	  IF (I.GT.1 .AND. LSPEC(3).EQ.0) 
	1		CALL WNCSAD(', ',1,2,OUT,LOUT,POUT)
	  IF (LSPEC(1).GT.0 .AND. I.GT.1 .AND. J+POUT.GT.LSPEC(1)) THEN !LONG
	    IF (OPS) THEN			!STRING OUTPUT
	      CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	    ELSE
	      CALL WNCOUT(CODE,OUT,1,POUT)	!WRITE LINE
	    END IF
	    LOUT=OUTLEN				!LENGTH OUTPUT LINE
	    OUT=' '				!EMPTY LINE
	    POUT=MIN(LOUT,LSPEC(2)-1)		!SET COLUMN POINTER
	  END IF
	  CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	END DO
	GOTO 23					!NEXT FORMAT
C D
 290	I1=ARGL(PARG)				!DATA ADDRESS
	IF (DOT) THEN				!SET FORMAT
	  I2=SVAL
	ELSE
	  I2=-1
	END IF
	DO I=1,RVAL				!REPEAT
	  IF (SIND.EQ.0) THEN			!NORMAL
	    CALL WNCCDS(CHLP,J,A_B(I1-A_OB),VVAL,I2)
	  ELSE IF (SIND.EQ.1) THEN		!COMPLEX
	    CALL WNCCYS(CHLP,J,A_B(I1-A_OB),VVAL,I2)
	    I1=I1+8				!NEXT POINTER
	  ELSE					!ANGLE
	    IF (SIND2.EQ.0) SIND2=2
	    CALL WNCCAD(CHLP,J,SIND2,SIND,A_B(I1-A_OB),VVAL,I2)
	  END IF
	  I1=I1+8				!NEXT POINTER
	  CALL WNCFAD(CHLP,WVAL,OUTLEN,J)	!ADJUST FIELD
	  IF (I.GT.1 .AND. LSPEC(3).EQ.0) 
	1		CALL WNCSAD(', ',1,2,OUT,LOUT,POUT)
	  IF (LSPEC(1).GT.0 .AND. I.GT.1 .AND. J+POUT.GT.LSPEC(1)) THEN !LONG
	    IF (OPS) THEN			!STRING OUTPUT
	      CALL WNCSAD(OUT,1,POUT,OST,LOST,POST)
	    ELSE
	      CALL WNCOUT(CODE,OUT,1,POUT)	!WRITE LINE
	    END IF
	    LOUT=OUTLEN				!LENGTH OUTPUT LINE
	    OUT=' '				!EMPTY LINE
	    POUT=MIN(LOUT,LSPEC(2)-1)		!SET COLUMN POINTER
	  END IF
	  CALL WNCSAD(CHLP,1,J,OUT,LOUT,POUT)	!SET FIELD
	END DO
	GOTO 23					!NEXT FORMAT
C Q
 300	LSPEC(1)=WVAL				!LINE WIDTH
	LSPEC(2)=RVAL				!LINE OFFSET
	LSPEC(3)=VVAL				!, SEPARATION ON/OFF
	LSPEC(4)=SVAL				!SPARE
	GOTO 23					!NEXT FORMAT
C
C
	END

C+ WNFIO_X.FVX
C  WNB 930804
C
C  Revisions:
C	WNB 930824	Change EOF/HIBLK test to cater for -1; embedded EOF
C	HjV 930824	Change EOF/HIBLK test (use .GE.0 iso. .GT.0)
C			Change arguments for ISHFT-function
C	WNB 930825	Change another HIBLK test; wrong label
C	CMV 930827	Cater for unsigned integer values in WNF_EOF
C	HjV 930830	Change variables in loop for READ
C	WNB 931006	Typo
C
	INTEGER FUNCTION WNFIO_X(FCAJ,FELJ)
C
C  Do basic disk/tape I/O
C
C
C  Result:
C
C	WNFIO_X_J = WNFIO_X( FCAJ_J(0:*):I, FELJ_J(*):I)
C				Start a read/write as described in element
C	WNFPUR_X_J= WNFPUR_X(FCAJ_J(0:*):I)
C				Purge all buffers
C	CALL WNF_EOF( FCAJ_J(0:*):I)	Convert EOF to VMS style
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE '($SSDEF)'		!ERROR CODES
	INCLUDE 'FCA_O_DEF'		!FCA
	INCLUDE 'MCA_O_DEF'		!MCA
	INCLUDE 'FEL_O.DEF'		!FEL
	INCLUDE 'FBC_O_DEF'		!FBC
C
C  Entry points:
C
	INTEGER WNFPUR_X
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER FCAJ(0:*)	!FCA BLOCK
	INTEGER FELJ(0:*)	!I/O REQUEST ELEMENT
C
C  Function references:
C
	INTEGER SYS$WAITFR
	LOGICAL WNGSQI,WNGSQR	!INSERT/REMOVE QUEUE
	INTEGER WNF_RWAHEAD	!READ/WRITE AHEAD
	INTEGER WNF_INWRITEW	!WRITE SOME
C
C  Data declarations:
C
	INTEGER ECOD		!LOCAL ERROR CODE
	INTEGER LFELJ(0:FEL__L-1) !FEL
C-
C
C INIT
C
	ECOD=SS$_NORMAL				!ASSUME OK
C
C CHECK READ/WRITE
C
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	  IF (FELJ(FEL_BITS_J)) THEN			!READ
	    IF (IAND(FCAJ(FCA_BITS_J),FCA_M_WRTAPE).NE.0) THEN !NOT ALLOWED
	      ECOD=SS$_ILLIOFUNC
	      GOTO 900
	    END IF
	  ELSE					!WRITE
	    IF (IAND(FCAJ(FCA_BITS_J),FCA_M_WRTAPE).EQ.0) THEN !NOT ALLOWED
	      ECOD=SS$_ILLIOFUNC
	      GOTO 900
	    END IF
	  END IF
	END IF
C
C CHECK DISK ADDRESS
C
	J=FELJ(FEL_DKAD_J)			!DISK ADDRESS
	IF (J.EQ.-1) THEN			!SEQUENTIAL
	  IF (FELJ(FEL_BITS_J)) THEN		!READ
	    J=FCAJ(FCA_RAD_J)
	  ELSE					!WRITE
	    J=FCAJ(FCA_EOF_J)
	  END IF
	END IF
C
C DISTRIBUTE TYPE
C
	IF (FELJ(FEL_BUFAD_J).EQ.0) THEN	!READ/WRITE AHEAD/AFTER
	  ECOD=WNF_RWAHEAD(FCAJ,J,FELJ)
	  GOTO 900
	END IF
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_ACT).NE.0) THEN !SOME ACTIVE
	  ECOD=SYS$WAITFR(%VAL(FCAJ(FCA_EF_J)))	!AWAIT IO
	  IF (.NOT.ECOD) THEN
	    FCAJ(FCA_ERR_J)=ECOD
	    GOTO 800
	  END IF
	END IF
	FCAJ(FCA_ERR_J)=SS$_NORMAL		!NO ERROR
	FCAJ(FCA_DAD_J)=J			!START DISK ADDRESS
	FCAJ(FCA_BAD_J)=FELJ(FEL_BUFAD_J)	!BUFFER ADDRESS
	FCAJ(FCA_ACLEN_J)=0			!LENGTH READ/WRITTEN
	FCAJ(FCA_LEN_J)=FELJ(FEL_BUFLEN_J)	!LENGTH TO READ/WRITE
C
C READ/WRITE
C
	IF (FELJ(FEL_BITS_J)) THEN		!READ
 10	  CONTINUE
	  J2=FCAJ(FCA_DAD_J)+FCAJ(FCA_LEN_J)	!LAST ADDRESS
	  IF (FCAJ(FCA_EOF_J).GE.0 .AND.
	1	J2.GT.FCAJ(FCA_EOF_J)) THEN	!BEYOND EOF
	    FCAJ(FCA_ACLEN_J)=IOR(FCAJ(FCA_ACLEN_J),'80000000'X) !EMBEDDED EOF
	    FCAJ(FCA_LEN_J)=FCAJ(FCA_EOF_J)-FCAJ(FCA_DAD_J) !PROPER LENGTH
	  END IF
	  IF (FCAJ(FCA_LEN_J).LE.0) GOTO 800	!READY
	  J0=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J	!BUF HEAD PTR
	  J=(A_J(J0)-A_OB)/LB_J			!FIRST BUF
	  DO WHILE (J.NE.J0)			!SCAN BUFFERS
	    IF (FCAJ(FCA_DAD_J).LT.
	1		A_J(J+FBC_DISK_J-FBC_BQA_J)) THEN !NOT IN CORE
	      GOTO 13
	    ELSE IF (FCAJ(FCA_DAD_J).LT.
	1		A_J(J+FBC_DISKND_J-FBC_BQA_J)) THEN !THIS BUF
	      J=J-FBC_BQA_J			!CORRECT POINTER
	      J2=MIN(A_J(J+FBC_DISKND_J)-
	1		FCAJ(FCA_DAD_J),FCAJ(FCA_LEN_J)) !LENGTH TO DO
	      J3=FCAJ(FCA_DAD_J)-A_J(J+FBC_DISK_J) !OFFSET START BUF
	      CALL WNGMV(J2,%VAL(A_J(J+FBC_ADDR_J)+J3),
	1		%VAL(FCAJ(FCA_BAD_J)))	!MOVE DATA
	      IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).EQ.0) THEN !DISK
		JS=WNGSQR(%VAL(A_J(J+FBC_BQT_J)),J3) !SET TIME ORDER
		JS=WNGSQI(%VAL(J3),%VAL(FCAJ(FCA_BQT_J)))
	      END IF
	      FCAJ(FCA_DAD_J)=FCAJ(FCA_DAD_J)+J2 !NEXT DISK ADDRESS
	      FCAJ(FCA_RAD_J)=FCAJ(FCA_DAD_J)	!LAST ADDRESS READ
	      FCAJ(FCA_BAD_J)=FCAJ(FCA_BAD_J)+J2 !NEXT BUF ADDRESS
	      FCAJ(FCA_ACLEN_J)=FCAJ(FCA_ACLEN_J)+J2 !LENGTH READ
	      FCAJ(FCA_LEN_J)=FCAJ(FCA_LEN_J)-J2 !LENGTH STILL TO DO
	      IF (FCAJ(FCA_LEN_J).LE.0) GOTO 800 !READY
	      IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
		J2=FCAJ(FCA_MCA_J)		!MCA
		IF (IAND(A_J((J2-A_OB)/LB_J+MCA_BITS_J),MCA_M_BLK).NE.0)
	1		GOTO 800		!BLOCK MODE; READY
	      END IF
	    END IF				!MAYBE IN CORE
	    J=(A_J(J)-A_OB)/LB_J		!NEXT BCB
	  END DO				!END BUFFERS
C
C READ IN DATA
C
 13	  CONTINUE
	  LFELJ(FEL_DKAD_J)=FCAJ(FCA_DAD_J)	!MAKE AN ELEMENT
	  LFELJ(FEL_BUFAD_J)=0			!READ AHEAD
	  IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	    LFELJ(FEL_BUFLEN_J)=1		!LIMIT TAPE TO 1 BLOCK
	  ELSE					!DISK
	    LFELJ(FEL_BUFLEN_J)=MIN(FCAJ(FCA_LEN_J),
	1		FCAJ(FCA_BLEN_J)*2)	!LIMIT INFINITE LOOP
	  END IF
	  LFELJ(FEL_BITS_J)=1			!READ
	  ECOD=WNF_RWAHEAD(FCAJ,LFELJ(FEL_DKAD_J),LFELJ) !READ AHEAD
	  IF (ECOD) THEN			!STARTED
	    IF (IAND(FCAJ(FCA_BITS_J),FCA_M_ACT).NE.0) THEN !ACTIVE
	      ECOD=SYS$WAITFR(%VAL(FCAJ(FCA_EF_J))) !WAIT
	      IF (.NOT.ECOD) FCAJ(FCA_ERR_J)=ECOD !SAVE ERROR
	    END IF
	  ELSE
	    FCAJ(FCA_ERR_J)=ECOD		!SAVE ERROR
	  END IF
	  IF (.NOT.FCAJ(FCA_ERR_J)) GOTO 800	!READY
	  GOTO 10				!MORE
C
C WRITE
C
	ELSE					!WRITE
 21	  CONTINUE
	  J2=FCAJ(FCA_DAD_J)+FCAJ(FCA_LEN_J)	!LAST ADDRESS
	  IF (FCAJ(FCA_HIBLK_J).GE.0 .AND.
	1	J2.GT.FCAJ(FCA_HIBLK_J)) GOTO 20 !CANNOT FIT IN ALLOCATION
	  IF (FCAJ(FCA_LEN_J).LE.0) GOTO 810	!NONE TO DO
 22	  CONTINUE
	  J0=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J	!BUF HEAD PTR
	  J=(A_J(J0)-A_OB)/LB_J			!FIRST BUF
	  DO WHILE (J.NE.J0)			!ALL BUFFERS
	    IF (FCAJ(FCA_DAD_J).LT.A_J(J+FBC_DISK_J-FBC_BQA_J)) THEN
	      GOTO 20				!NOT IN CORE
	    ELSE IF (FCAJ(FCA_DAD_J).LT.
	1		A_J(J+FBC_DISKND_J-FBC_BQA_J)) THEN !PARTLY IN CORE
	      J=J-FBC_BQA_J			!CORRECT POINTER
	      J2=MIN(A_J(J+FBC_DISKND_J)-
	1		FCAJ(FCA_DAD_J),FCAJ(FCA_LEN_J)) !LENGTH TO DO
	      J3=FCAJ(FCA_DAD_J)-A_J(J+FBC_DISK_J) !OFFSET TO BUF START
	      CALL WNGMV(J2,%VAL(FCAJ(FCA_BAD_J)),
	1		%VAL(A_J(J+FBC_ADDR_J)+J3)) !MOVE DATA
	      A_J(J+FBC_BITS_J)=IOR(A_J(J+FBC_BITS_J),
	1		FBC_M_WRITE)		!SET REWRITE
	      IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).EQ.0) THEN !DISK
	        JS=WNGSQR(%VAL(A_J(J+FBC_BQT_J)),J3) !SET TIME ORDER
	        JS=WNGSQI(%VAL(J3),%VAL(FCAJ(FCA_BQT_J)))
	      END IF
	      FCAJ(FCA_DAD_J)=FCAJ(FCA_DAD_J)+J2 !NEXT DISK ADDRESS
	      FCAJ(FCA_BAD_J)=FCAJ(FCA_BAD_J)+J2 !NEXT BUF ADDRESS
	      FCAJ(FCA_ACLEN_J)=FCAJ(FCA_ACLEN_J)+J2 !LENGTH WRITTEN
	      FCAJ(FCA_LEN_J)=FCAJ(FCA_LEN_J)-J2 !LENGTH STILL TO DO
	      IF (FCAJ(FCA_LEN_J).LE.0) GOTO 810 !READY
	    END IF				!PARTLY
	    J=(A_J(J)-A_OB)/LB_J		!NEXT BUFFER
	  END DO
C
C READ IN NEXT BUFFER
C
 20	  CONTINUE
	  LFELJ(FEL_DKAD_J)=FCAJ(FCA_DAD_J)	!DISK ADDRESS
	  LFELJ(FEL_BUFAD_J)=0			!WRITE AFTER
	  IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	    LFELJ(FEL_BUFLEN_J)=1		!LIMIT TO ONE BLOCK
	  ELSE					!DISK
	    LFELJ(FEL_BUFLEN_J)=MIN(FCAJ(FCA_LEN_J),
	1		FCAJ(FCA_BLEN_J)*2)	!LIMIT INFINITE LOOP
	  END IF
	  LFELJ(FEL_BITS_J)=0			!INDICATE WRITE
	  ECOD=WNF_RWAHEAD(FCAJ,LFELJ(FEL_DKAD_J),LFELJ) !WRITE AFTER
	  IF (ECOD) THEN			!STARTED
	    IF (IAND(FCA_M_ACT,FCAJ(FCA_BITS_J)).NE.0) THEN !ACTIVE
	      ECOD=SYS$WAITFR(%VAL(FCAJ(FCA_EF_J))) !AWAIT IO
	      IF (.NOT.ECOD) FCAJ(FCA_ERR_J)=ECOD !SAVE ERROR
	    END IF
	  ELSE
	    FCAJ(FCA_ERR_J)=ECOD		!SAVE ERROR
	  END IF
	  IF (.NOT.FCAJ(FCA_ERR_J)) GOTO 810	!STOP IF ERROR
	  GOTO 22				!DO MORE
	END IF					!READ/WRITE
C
C READY READ
C
 800	CONTINUE
	ECOD=FCAJ(FCA_ERR_J)			!ERROR
	IF (ECOD) THEN				!NOT YET ERROR
	  IF (IAND(FCAJ(FCA_ACLEN_J),'80000000'X).NE.0)
	1		ECOD=SS$_ENDOFFILE	!EMBEDDED EOF
	END IF
	FCAJ(FCA_ACLEN_J)=IAND(FCAJ(FCA_ACLEN_J),'7FFFFFFF'X) !PROPER LENGTH
	GOTO 900
C
C READY WRITE
C
 810	CONTINUE
	ECOD=FCAJ(FCA_ERR_J)			!ERROR
	IF (FCAJ(FCA_ACLEN_J).NE.0) THEN	!SOMETHING WRITTEN
	  FCAJ(FCA_EOF_J)=MAX(FCAJ(FCA_EOF_J),FCAJ(FCA_DAD_J)) !NEW EOF
	END IF
	GOTO 900
C
C ERROR
C
 900	CONTINUE
	WNFIO_X=IAND('0000FFFF'X,ECOD)		!RETURN ERROR
C
	RETURN
C
C WNFPUR_X(FCAJ)		Purge all buffers
C
	ENTRY WNFPUR_X(FCAJ)
C
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_ACT).NE.0) THEN !ACTIVE IO
	  JS=SYS$WAITFR(%VAL(FCAJ(FCA_EF_J)))	!AWAIT IO
	  IF (NOT(JS)) THEN
	    FCAJ(FCA_ERR_J)=JS
	    GOTO 810				!FINISH
	  END IF
	END IF
	FCAJ(FCA_ERR_J)=SS$_NORMAL		!NO ERROR
	FCAJ(FCA_ACLEN_J)=0			!NOTHING WRITTEN
C
C PURGE
C
 200	CONTINUE
	J1=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J	!BUF HEAD PTR
	J=(A_J(J1)-A_OB)/LB_J			!FIRST BUF
	DO WHILE (J.NE.J1)			!ALL BUFFERS
	  J=J-FBC_BQA_J				!CORRECT POINTER
	  IF (IAND(A_J(J+FBC_BITS_J),FBC_M_WRITE).NE.0) THEN !REWRITE
	    A_J(J+FBC_BITS_J)=IAND(
	1	A_J(J+FBC_BITS_J),NOT(FBC_M_WRITE)) !RESET
	    JS=WNF_INWRITEW(FCAJ,A_J(J))	!WRITE
	    IF (.NOT.JS) THEN			!ERROR
	      FCAJ(FCA_ERR_J)=JS
	      GOTO 810
	    END IF
	    IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	      I1=IAND('0000FFFF'X,ISHFT(FCAJ(FCA_IOSB_J),-16)) !BYTES WRITTEN
	      FCAJ(FCA_MAP_J)=FCAJ(FCA_MAP_J)+I1 !TAPE POSITION
	      FCAJ(FCA_MAB_J)=FCAJ(FCA_MAB_J)+1	!TAPE BLOCK
	    END IF
	    IF (.NOT.FCAJ(FCA_IOSB_J))
	1		FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J) !SAVE ERROR
	  ELSE
	    A_J(J+FBC_DISK_J)=0			!SET EMPTY
	    A_J(J+FBC_DISKND_J)=0
	    A_J(J+FBC_BITS_J)=0
	  END IF
	  J=(A_J(J)-A_OB)/LB_J			!NEXT BCB
	END DO
	GOTO 810				!FINISH
C
C
	END

C+
C WNF_RWAHEAD(FCAJ,DKAD,FELJ)		Read/write ahead
C
	INTEGER FUNCTION WNF_RWAHEAD(FCAJ,DKAD,FELJ)
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'FCA_O_DEF'
	INCLUDE 'FEL_O_DEF'
C
	INTEGER FCAJ(0:*)	!FCA
	INTEGER DKAD		!DISK ADDRESS
	INTEGER FELJ(0:*)	!ELEMENT TO DO
C
	INTEGER SYS$CLREF
	INTEGER SYS$WAITFR
	INTEGER SYS$DCLAST
	LOGICAL WNGSQR,WNGSQI
	EXTERNAL WNF_IAST
C-
 10	CONTINUE
	WNF_RWAHEAD=SYS$CLREF(%VAL(FCAJ(FCA_EFA_J))) !CLEAR ELEMENT AVAILABLE
	IF (.NOT.WNF_RWAHEAD) RETURN		!CANNOT DO
	IF (.NOT.WNGSQR(%VAL(FCAJ(FCA_FEE_J)),J)) THEN !GET ELEMENT
	  WNF_RWAHEAD=SYS$WAITFR(%VAL(FCAJ(FCA_EFA_J))) !AWAIT ONE
	  IF (.NOT.WNF_RWAHEAD) RETURN		!ERROR
	  GOTO 10				!RETRY
	END IF
	J=(J-A_OB)/LB_J				!ELEMENT POINTER
	A_J(J+FEL_DKAD_J)=DKAD			!START DISK ADDRESS
	A_J(J+FEL_BUFAD_J)=0			!BUFFER ADDRESS
	A_J(J+FEL_BUFLEN_J)=FELJ(FEL_BUFLEN_J)	!LENGTH TO READ/WRITE
	A_J(J+FEL_BITS_J)=FELJ(FEL_BITS_J)	!READ/WRITE
	JS=WNGSQI(A_J(J),%VAL(FCAJ(FCA_FEA_J+1))) !SET IN ACTIVE QUEUE
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_ACT).EQ.0) THEN !NOT YET ACTIVE
	  FCAJ(FCA_BITS_J)=IOR(FCAJ(FCA_BITS_J),FCA_M_ACT) !SET ACTIVE
	  WNF_RWAHEAD=SYS$CLREF(%VAL(FCAJ(FCA_EF_J))) !CLEAR EF
	  IF (WNF_RWAHEAD) THEN			!OK
	    WNF_RWAHEAD=SYS$DCLAST(WNF_IAST,FCAJ,) !START IO
	    IF (WNF_RWAHEAD) RETURN		!BACK TO USER
	  END IF
	  JS=WNGSQR(%VAL(FCAJ(FCA_FEA_J+1)),J)	!REMOVE FROM ACTIVE
	  JS=WNGSQI(%VAL(J),%VAL(FCAJ(FCA_FEE_J+1))) !RE-INSERT IN EMPTY
	  FCAJ(FCA_BITS_J)=IAND(FCAJ(FCA_BITS_J),NOT(FCA_M_ACT)) !SET NOT STARTED
	END IF
C
	RETURN
C
C
	END

C+
C  The following are internal routines to WNFIO_X
C
C WNF_EOF(FCA)	Convert disk address to EOF
C
	SUBROUTINE WNF_EOF(FCAJ)
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'FCA_O_DEF'
C
	INTEGER LIB$EXTZV
C
	INTEGER FCAJ(0:*)	!FCA
C-
	I1=FCAJ(FCA_EOF_J)+512			!MAKE VIRTUAL BLOCKS
	I2=LIB$EXTZV(9,16,I1)			!EOF BLOCK
	IF (I2.GT.32767) I2=IOR(I2,'FFFF0000'X) !OVERFLOW PROBLEM
	A_I((%LOC(FCAJ)-A_OB+FCA_RECATR_1+FAT_EFBLKL_1)/LB_I)=I2
	I2=LIB$EXTZV(25,7,I1)
	IF (I2.GT.32767) I2=IOR(I2,'FFFF0000'X) !OVERFLOW PROBLEM
	A_I((%LOC(FCAJ)-A_OB+FCA_RECATR_1+FAT_EFBLKH_1)/LB_I)=I2
	CALL LIB$INSV(I1,0,9,			!EOF BYTE
	1	A_I((%LOC(FCAJ)-A_OB+FCA_RECATR_1+FAT_FFBYTE_1)/LB_I))
C
	RETURN
C
C
	END
C+
C WNF_INWRITEW(FCAJ,FBCJ)	Initialise a write and wait
C
	INTEGER FUNCTION WNF_INWRITEW(FCAJ,FBCJ)
C
	INCLUDE 'WNG_DEF'
	INCLUDE '($IODEF)'
	INCLUDE 'FCA_O_DEF'
	INCLUDE 'FBC_O_DEF'
C
	INTEGER FCAJ(0:*)	!FCA
	INTEGER FBCJ(0:*)	!FBC
C
	INTEGER SYS$QIOW
	INTEGER LIB$EXTZV
C-
	I=IO$_WRITEVBLK				!INDICATE WRITE
	I1=LIB$EXTZV(9,23,FBCJ(FBC_DISK_J))+1	!VIRTUAL BLOCK #
	I3=MIN(FCAJ(FCA_BLEN_J),FCAJ(FCA_HIBLK_J)-
	1		FBCJ(FBC_DISK_J))	!LENGTH TO DO
	WNF_INWRITEW=SYS$QIOW(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(I),
	1		FCAJ(FCA_IOSB_J),,,
	1		%VAL(FBCJ(FBC_ADDR_J)),%VAL(I3),%VAL(I1),,,)
C
	RETURN
C
C
	END
C+
C WNF_INWRITE(FCAJ,FBCJ,AST)	Initialise a write
C WNF_INREAD(FCAJ,FBCJ,AST)	Initialise a read
C WNF_EXTEND(FCAJ,FBCJ,AST)	Extend file
C
	INTEGER FUNCTION WNF_INWRITE(FCAJ,FBCJ,AST)
C
	INCLUDE 'WNG_DEF'
	INCLUDE '($IODEF)'
	INCLUDE 'FCA_O_DEF'
	INCLUDE 'FBC_O_DEF'
C
	INTEGER FCAJ(0:*)	!FCA
	INTEGER FBCJ(0:*)	!FBC
	INTEGER AST		!AST CODE
C
	INTEGER WNF_INREAD,WNF_EXTEND
C
	INTEGER SYS$QIO
	INTEGER LIB$EXTZV
	EXTERNAL WNF_WASTW,WNF_WAST,WNF_WASTX
	EXTERNAL WNF_RAST,WNF_RASTW
C-
C
C INWRITE
C
	I=IO$_WRITEVBLK				!INDICATE WRITE
	GOTO 10
C
C INREAD
C
	ENTRY WNF_INREAD(FCAJ,FBCJ,AST)
C
	I=IO$_READVBLK
 10	CONTINUE
	I1=LIB$EXTZV(9,23,FBCJ(FBC_DISK_J))+1	!VIRTUAL BLOCK #
	IF (FCAJ(FCA_HIBLK_J).GE.0 .AND.
	1	FBCJ(FBC_DISKND_J).GT.FCAJ(FCA_HIBLK_J)) THEN !NOT IN EXTEND
	  I3=FCAJ(FCA_HIBLK_J)-FBCJ(FBC_DISK_J)	!LENGTH TO DO
	ELSE					!BEYOND EXTEND
	  I3=FCAJ(FCA_BLEN_J)			!STANDARD LENGTH
	END IF
	GOTO 20
C
C EXTEND
C
	ENTRY WNF_EXTEND(FCAJ,FBCJ,AST)
C
 20	CONTINUE
	IF (AST.EQ.1) THEN
	  WNF_INWRITE=SYS$QIO(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(I),
	1		FCAJ(FCA_IOSB_J),WNF_WASTW,FCAJ,
	1		%VAL(FBCJ(FBC_ADDR_J)),%VAL(I3),%VAL(I1),,,)
	ELSE IF (AST.EQ.2) THEN
	  WNF_INWRITE=SYS$QIO(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(I),
	1		FCAJ(FCA_IOSB_J),WNF_WAST,FCAJ,
	1		%VAL(FBCJ(FBC_ADDR_J)),%VAL(I3),%VAL(I1),,,)
	ELSE IF (AST.EQ.3) THEN
	  WNF_INWRITE=SYS$QIO(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(IO$_MODIFY),
	1		FCAJ(FCA_IOSB_J),WNF_WASTX,FCAJ,
	1		FCAJ(FCA_FIBDES_J),FCAJ(FCA_ATRJ_J),,,,)
	ELSE IF (AST.EQ.4) THEN
	  WNF_INWRITE=SYS$QIO(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(I),
	1		FCAJ(FCA_IOSB_J),WNF_RAST,FCAJ,
	1		%VAL(FBCJ(FBC_ADDR_J)),%VAL(I3),%VAL(I1),,,)
	ELSE
	  WNF_INWRITE=SYS$QIO(,%VAL(FCAJ(FCA_CHAN_J)),%VAL(I),
	1		FCAJ(FCA_IOSB_J),WNF_RASTW,FCAJ,
	1		%VAL(FBCJ(FBC_ADDR_J)),%VAL(I3),%VAL(I1),,,)
	END IF
C
	RETURN
C
C
	END
C+
C WNF_SETAQ(FCAJ,FBCJ)		Set in address queue
C
	SUBROUTINE WNF_SETAQ(FCAJ,FBCJ)
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'FCA_O_DEF'
	INCLUDE 'FBC_O_DEF'
C
	LOGICAL WNGSQI,WNGSQR
C
	INTEGER FCAJ(0:*)	!FCA
	INTEGER FBCJ(0:*)	!FBC
C
C-
	JS=WNGSQR(FBCJ(FBC_BQA_J),I1)			!FIND WHERE TO PUT
	I2=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J		!IN ADDRESS QUEUE
	I3=(A_J(I2)-A_OB)/LB_J				!FIRST BUF
	DO WHILE (I3.NE.I2)				!NOT END
	  IF (FBCJ(FBC_DISK_J).LT.
	1	A_J(I3+FBC_DISK_J-FBC_BQA_J)) GOTO 10	!HERE
	  I3=(A_J(I3)-A_OB)/LB_J			!TRY NEXT
	END DO
 10	CONTINUE
	JS=WNGSQI(%VAL(I1),%VAL(A_J(I3+1)))		!INSERT
C
	RETURN
C
C
	END

C+
C The following are all the AST routines
C
C WNF_IAST(FCAJ)		General I/O AST
C WNF_WASTW(FCAJ)		Rewrite AST
C WNF_WAST(FCAJ)		Standard  write AST
C WNF_WASTX(FCAJ)		Write extend AST
C WNF_RAST(FCAJ)		Standard read AST
C WNF_RASTW(FCAJ)		Rewrite read AST
C
	SUBROUTINE WNF_IAST(FCAJ)
C
	INCLUDE 'WNG_DEF'
	INCLUDE '($SSDEF)'
	INCLUDE '($IODEF)'
	INCLUDE 'FCA_O_DEF'
	INCLUDE 'FEL_O_DEF'
	INCLUDE 'FBC_O_DEF'
	INCLUDE 'MCA_O_DEF'
C
	INTEGER FCAJ(0:*)	!FCA
C
	INTEGER SYS$SETEF
	INTEGER WNFTSF
	INTEGER WNF_INWRITE
	INTEGER WNF_INREAD
	INTEGER WNF_EXTEND
	LOGICAL WNGSQI,WNGSQR
C
C-
	FCAJ(FCA_ERR_J)=SS$_NORMAL		!ASSUME OK
	GOTO 310
C
	ENTRY WNF_WASTW(FCAJ)
C
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	  I1=A_I((%LOC(FCAJ)-A_OB+FCA_IOSB_1+LB_I)/LB_I) !BYTES WRITTEN
	  FCAJ(FCA_MAP_J)=FCAJ(FCA_MAP_J)+I1	!TAPE POSITION
	  FCAJ(FCA_MAB_J)=FCAJ(FCA_MAB_J)+1	!TAPE BLOCK
	END IF
	IF (.NOT.FCAJ(FCA_IOSB_J)) THEN		!ERROR
	  FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J)	!SAVE ERROR
	  GOTO 300				!FINISH
	END IF
	GOTO 440				!FILL BUFFER
C
	ENTRY WNF_WAST(FCAJ)
C
	IF (FCAJ(FCA_IOSB_J)) GOTO 430		!CONTINUE
	FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J)	!SAVE ERROR
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	FCAJ(FCA_EOF_J)=MAX(FCAJ(FCA_EOF_J),
	1	A_J(J+FEL_DKAD_J))		!SET NEW EOF
	GOTO 300				!FINISH
C
	ENTRY WNF_WASTX(FCAJ)
C
	CALL WNFIO_X0(FCAJ,FCAJ(FCA_FIBJ_J))	!RESET BIT
	IF (.NOT.FCAJ(FCA_IOSB_J)) THEN		!ERROR
	  FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J)	!SAVE ERROR
	  GOTO 300				!FINISH
	END IF
	CALL WNFIO_X1(FCAJ,FCAJ(FCA_FIBJ_J),I)	!GET NEW SIZE
	FCAJ(FCA_HIBLK_J)=(I-1)*512		!AS ADDRESS
	GOTO 420				!RETRY
C
	ENTRY WNF_RAST(FCAJ)
C
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	  I1=A_I((%LOC(FCAJ)-A_OB+FCA_IOSB_1+LB_I)/LB_I) !BYTES READ
	  FCAJ(FCA_MAP_J)=FCAJ(FCA_MAP_J)+I1	!TAPE POSITION
	  FCAJ(FCA_MAB_J)=FCAJ(FCA_MAB_J)+1	!TAPE BLOCK
	  J=(FCAJ(FCA_BQT_J)-FBC_BQT_1-A_OB)/LB_J !CURRENT BUF POINTER
	  A_J(J+FBC_DISKND_J)=A_J(J+FBC_DISK_J)+I1 !END POS. BUFFER
	  IF (I1.LE.100 .OR.			!!ASSUME EOF
	1	IAND(FCAJ(FCA_IOSB_J),'0000FFFF'X).EQ.
	1		SS$_ENDOFFILE) THEN
	    FCAJ(FCA_EOF_J)=FCAJ(FCA_MAP_J)	!SAVE EOF
	    JS=WNFTSF(%VAL(FCAJ(FCA_MCA_J)),-1)	!SKIP BACK FILE
	    FCAJ(FCA_MAB_J)=FCAJ(FCA_MAB_J)-1	!RESET BLOCK COUNT
	  END IF
	END IF
	IF (IAND(FCAJ(FCA_IOSB_J),'0000FFFF'X).EQ.
	1		SS$_ENDOFFILE) GOTO 320 !ACCEPT EOF
	IF (FCAJ(FCA_IOSB_J)) GOTO 320		!OK STATUS
	FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J)	!SAVE ERROR
	GOTO 300				!NEXT ELEMENT
C
	ENTRY WNF_RASTW(FCAJ)
C
	IF (FCAJ(FCA_IOSB_J)) GOTO 340		!FILL BUFFER
	FCAJ(FCA_ERR_J)=FCAJ(FCA_IOSB_J)	!SAVE ERROR
	GOTO 300				!NEXT ELEMENT
C
C RESET ELEMENT EMPTY QUEUE
C
 300	CONTINUE				!IANXT
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	JS=WNGSQI(A_J(J),%VAL(FCAJ(FCA_FEE_J+1))) !SET IN EMPTY QUEUE
	IF (JS) THEN				!FIRST
	  JS=SYS$SETEF(%VAL(FCAJ(FCA_EFA_J)))	!NOTIFY EMPTY AVAILABLE
	END IF
C
C GET NEXT ELEMENT
C
 310	CONTINUE				!IANEW
	IF (.NOT.WNGSQR(%VAL(FCAJ(FCA_FEA_J)),J)) THEN !GET ELEMENT TO DO
	  FCAJ(FCA_BITS_J)=IAND(FCAJ(FCA_BITS_J),NOT(FCA_M_ACT)) !SET READY
	  JS=SYS$SETEF(%VAL(FCAJ(FCA_EF_J)))	!NOTIFY WORLD
C
	  RETURN				!ALL READY
	END IF
	J=(J-A_OB)/LB_J				!CURRENT ELEMENT
C
C ACT ON ELEMENT
C
	FCAJ(FCA_FEL_J)=%LOC(A_J(J))		!SET CURRENT
	IF (.NOT.FCAJ(FCA_ERR_J)) GOTO 300	!ALREADY ERROR ENCOUNTERED
	IF (A_J(J+FEL_BUFLEN_J).LE.0) GOTO 300	!READY
	IF (A_J(J+FEL_BITS_J)) GOTO 320		!READ
	GOTO 420				!WRITE
C
C READ AHEAD
C
 320	CONTINUE				!IAREAD
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	I=A_J(J+FEL_DKAD_J)+A_J(J+FEL_BUFLEN_J)	!END DISK ADDRESS
	IF (FCAJ(FCA_EOF_J).GE.0 .AND.
	1	I.GT.FCAJ(FCA_EOF_J)) THEN	!NOT ALL PRESENT
	  A_J(J+FEL_BUFLEN_J)=FCAJ(FCA_EOF_J)-A_J(J+FEL_DKAD_J) !MAX. LENGTH
	  IF (A_J(J+FEL_BUFLEN_J).LE.0) GOTO 300 !NO MORE, NEXT ELEMENT
	END IF
C
C START BUFFER MOVE
C
 330	CONTINUE
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	J0=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J	!BUF HEAD PTR
	J1=(A_J(J0)-A_OB)/LB_J			!FIRST BUF
	DO WHILE (J1.NE.J0)			!CHECK BUFFERS
	  IF (A_J(J+FEL_DKAD_J).LT.
	1	A_J(J1+FBC_DISK_J-FBC_BQA_J)) GOTO 332 !NOT IN CORE
	  IF (A_J(J+FEL_DKAD_J).LT.
	1	A_J(J1+FBC_DISKND_J-FBC_BQA_J)) THEN !PARTLY
	    J1=J1-FBC_BQA_J			!CORRECT POINTER
	    I=A_J(J1+FBC_DISKND_J)-A_J(J+FEL_DKAD_J) !MAX. POSSIBLE
	    A_J(J+FEL_DKAD_J)=A_J(J+FEL_DKAD_J)+I !UPDATE
	    A_J(J+FEL_BUFLEN_J)=A_J(J+FEL_BUFLEN_J)-I
	    IF (A_J(J+FEL_BUFLEN_J).LE.0) GOTO 300 !READY; DO NEXT
	    IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	      J2=FCAJ(FCA_MCA_J)		!TAPE MCA
	      IF (IAND(A_J((J2-A_OB)/LB_J+MCA_BITS_J),MCA_M_BLK).NE.0)
	1		GOTO 300		!BLOCK MODE, READY
	    END IF
	    J1=J1+FBC_BQA_J			!CORRECT POINTER
	  END IF
	  J1=(A_J(J1)-A_OB)/LB_J		!NEXT FBC
	END DO
C
C GET NEW BUFFER
C
 332	CONTINUE
	JS=WNGSQR(%VAL(FCAJ(FCA_BQT_J+1)),J)	!REMOVE OLDEST ENTRY
	JS=WNGSQI(%VAL(J),FCAJ(FCA_BQT_J))	!SET AT BEGIN
	J=(J-FBC_BQT_1-A_OB)/LB_J		!CORRECT POINTER
	IF (IAND(A_J(J+FBC_BITS_J),FBC_M_WRITE).EQ.0) GOTO 340 !NO REWRITE
	A_J(J+FBC_BITS_J)=IAND(A_J(J+FBC_BITS_J),NOT(FBC_M_WRITE)) !RESET
	JS=WNF_INWRITE(FCAJ,A_J(J),5)		!START WRITE
	IF (.NOT.JS) THEN
	  FCAJ(FCA_ERR_J)=JS			!SAVE ERROR
	  GOTO 300
	END IF
C
	RETURN					!WAIT
C
C FILL NEW BUFFER
C
 340	CONTINUE				!IARFBUF
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	J1=(FCAJ(FCA_BQT_J)-FBC_BQT_1-A_OB)/LB_J !TO BE READ
	I1=A_J(J+FEL_DKAD_J)			!START ADDRESS BUFFER
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).EQ.0) THEN !DISK
	  I1=I1/FCAJ(FCA_BLEN_J)		!WHOLE # OF BUFFERS
	  A_J(J1+FBC_DISK_J)=I1*FCAJ(FCA_BLEN_J)
 341	  CONTINUE
	  A_J(J1+FBC_DISKND_J)=FCAJ(FCA_BLEN_J)+A_J(J1+FBC_DISK_J) !BUF END
	  CALL WNF_SETAQ(FCAJ,A_J(J1))		!SET IN ADDRESS QUEUE
	  JS=WNF_INREAD(FCAJ,A_J(J1),4)		!START READ
	  IF (.NOT.JS) THEN
 342	    CONTINUE
	    FCAJ(FCA_ERR_J)=JS
	    GOTO 300
	  END IF
	ELSE					!TAPE
	  IF (I1.LT.FCAJ(FCA_MAP_J)) THEN	!CANNOT READ BACKWARDS
	    JS=SS$_IVADDR
	    GOTO 342
	  END IF
	  A_J(J1+FBC_DISK_J)=FCAJ(FCA_MAP_J)	!BUFFER TAPE ADDRESS
	  GOTO 341
	END IF
C
	RETURN					!WAIT
C
C WRITE AHEAD
C
 420	CONTINUE				!IAWRITE
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	IF (FCAJ(FCA_HIBLK_J).GE.0 .AND.
	1	A_J(J+FEL_DKAD_J)+A_J(J+FEL_BUFLEN_J).GT.
	1	FCAJ(FCA_HIBLK_J)) GOTO 410	!CANNOT FIT IN ALLOCATION:EXTEND
	GOTO 430				!START ACTUAL WRITE
C
C EXTEND FILE
C
 410	CONTINUE
	CALL WNFIO_X2(FCAJ,FCAJ(FCA_FIBJ_J))	!SET NUMBER WANTED
	CALL WNF_EOF(FCAJ)			!SET CORRECT EOF
	JS=WNF_EXTEND(FCAJ,0,3)			!EXTEND
	IF (.NOT.JS) THEN			!SUBMIT ERROR
	  CALL WNFIO_X0(FCAJ,FCAJ(FCA_FIBJ_J))	!RESET EXTEND
	  FCAJ(FCA_ERR_J)=JS			!TRANSMIT ERROR
	  GOTO 300				!FINISH
	END IF
C
	RETURN					!AWAIT EXTEND
C
C WRITE BUFFER MOVE
C
 430	CONTINUE				!IAWBUF
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	J0=(%LOC(FCAJ)+FCA_BQA_1-A_OB)/LB_J	!BUF HEAD
	J1=(A_J(J0)-A_OB)/LB_J			!FIRST BUF
	DO WHILE (J1.NE.J0)			!CHECK BUFFERS
	  IF (A_J(J+FEL_DKAD_J).LT.
	1	A_J(J1+FBC_DISK_J-FBC_BQA_J)) GOTO 432 !NOT IN CORE
	  IF (A_J(J+FEL_DKAD_J).LT.
	1	A_J(J1+FBC_DISKND_J-FBC_BQA_J)) THEN !PARTLY
	    J1=J1-FBC_BQA_J			!CORRECT POINTER
	    I=A_J(J1+FBC_DISKND_J)-A_J(J+FEL_DKAD_J) !MAX. POSSIBLE
	    A_J(J+FEL_DKAD_J)=A_J(J+FEL_DKAD_J)+I !UPDATE
	    A_J(J+FEL_BUFLEN_J)=A_J(J+FEL_BUFLEN_J)-I
	    IF (A_J(J+FEL_BUFLEN_J).LE.0) GOTO 300 !READY; DO NEXT
	    J1=J1+FBC_BQA_J			!CORRECT POINTER
	  END IF
	  J1=(A_J(J1)-A_OB)/LB_J		!NEXT FBC
	END DO
	GOTO 434
C
C GET NEW BUF
C
 432	CONTINUE
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0) THEN !TAPE
	  JS=SS$_IVADDR				!CANNOT BE RANDOM
	  GOTO 433
	END IF
 434	CONTINUE
	JS=WNGSQR(%VAL(FCAJ(FCA_BQT_J+1)),J)	!REMOVE OLDEST ENTRY
	JS=WNGSQI(%VAL(J),FCAJ(FCA_BQT_J))	!SET AT BEGIN
	J=(J-FBC_BQT_1-A_OB)/LB_J		!CORRECT POINTER
	IF (IAND(A_J(J+FBC_BITS_J),FBC_M_WRITE).EQ.0) GOTO 440 !NO REWRITE
	A_J(J+FBC_BITS_J)=IAND(A_J(J+FBC_BITS_J),NOT(FBC_M_WRITE)) !RESET
	JS=WNF_INWRITE(FCAJ,A_J(J),1)		!START WRITE
	IF (.NOT.JS) THEN
 433	  CONTINUE
	  FCAJ(FCA_ERR_J)=JS			!SAVE ERROR
	  GOTO 300
	END IF
C
	RETURN					!WAIT
C
C FILL WRITE BUFFER
C
 440	CONTINUE				!IAWFBUF
	J=(FCAJ(FCA_FEL_J)-A_OB)/LB_J		!CURRENT ELEMENT
	J1=(FCAJ(FCA_BQT_J)-FBC_BQT_1-A_OB)/LB_J !TO BE READ
	I1=A_J(J+FEL_DKAD_J)			!START ADDRESS BUFFER
	IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).EQ.0) THEN !DISK
 443	  CONTINUE
	  I1=I1/FCAJ(FCA_BLEN_J)		!WHOLE # OF BUFFERS
	  A_J(J1+FBC_DISK_J)=I1*FCAJ(FCA_BLEN_J)
	  A_J(J1+FBC_DISKND_J)=FCAJ(FCA_BLEN_J)+A_J(J1+FBC_DISK_J) !BUF END
	  CALL WNF_SETAQ(FCAJ,A_J(J1))		!SET IN ADDRESS QUEUE
	  IF (A_J(J1+FBC_DISK_J).GE.FCAJ(FCA_EOF_J)) THEN !NOT YET WRITTEN
 442	    CONTINUE
	    CALL WNGMVZ(FCAJ(FCA_BLEN_J),%VAL(A_J(J1+FBC_ADDR_J))) !EMPTY BUF
	    GOTO 430				!DO WRITE
	  END IF
	  IF (IAND(FCAJ(FCA_BITS_J),FCA_M_MAG).NE.0)
	1		GOTO 442		!NEVER READ TAPE
	  IF (A_J(J+FEL_DKAD_J).EQ.A_J(J1+FBC_DISK_J)) THEN !MAYBE FULL BUF
	    IF (A_J(J+FEL_BUFLEN_J).GE.FCAJ(FCA_BLEN_J)) GOTO 442 !FULL BUF
	  END IF
	  JS=WNF_INREAD(FCAJ,A_J(J1),2)		!START READ
	  IF (.NOT.JS) THEN
	    CONTINUE
	    FCAJ(FCA_ERR_J)=JS
	    GOTO 300
	  END IF
	ELSE					!TAPE
	  I1=FCAJ(FCA_MAW_J)			!TAPE ADDRESS
	  FCAJ(FCA_MAW_J)=FCAJ(FCA_MAW_J)+FCAJ(FCA_BLEN_J) !MAKE SURE CONTIGUOUS
	  A_J(J1+FBC_BITS_J)=IOR(A_J(J1+FBC_BITS_J),FBC_M_WRITE) !ALWAYS WRITE
	  GOTO 443
	END IF
C
	RETURN					!WAIT
C
C
	END

C+
C FIB handling
C
C WNFIO_X0(FCAJ,FIB)		Reset extend bit
C
	SUBROUTINE WNFIO_X0(FCAJ,FIB)
C
	INCLUDE 'WNG_DEF'
	INCLUDE '($FIBDEF)'
	INCLUDE 'FCA_O_DEF'
C
	INTEGER FCAJ(0:*)
	RECORD /FIBDEF/ FIB
	INTEGER JVAL
C
	FIB.FIB$W_EXCTL=IAND(FIB.FIB$W_EXCTL,NOT(FIB$M_EXTEND))
C
	RETURN
C
C WNFIO_X1(FCAJ,FIB,JVAL)	Get new size
C
	ENTRY WNFIO_X1(FCAJ,FIB,JVAL)
C
	JVAL=FIB.FIB$L_EXVBN+FIB.FIB$L_EXSZ 		!NEW SIZE
C
	RETURN
C
C WNFIO_X2(FCAJ,FIB)		Set extend size
C	
	ENTRY WNFIO_X2(FCAJ,FIB)
C
	FIB.FIB$W_EXCTL=IOR(FIB.FIB$W_EXCTL,FIB$M_EXTEND) !ASK EXTEND
	FIB.FIB$L_EXVBN=0				!NUMBER EXTENDED
C
	RETURN
C
C
	END

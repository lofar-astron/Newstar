C+ WNGARG.FVX
C  WNB 930817
C
C  Revisions:
C
	INTEGER FUNCTION WNGARG()
C
C  Adrress handling
C
C  Result:
C
C	WNGARG_J = WNGARG()		Address of argument list (point at
C					# of arguments) of containing routine
C	WNGART_L = WNGART( N_J:I)	.TRUE. if argument N present
C					in enclosing routine
C	WNGARN_J = WNGARN()		# of arguments in enclosing routine
C	WNGARQ_X = WNGARQ( ROUT_ENTRY:I, ALIST_J(0:*):I)
C					Call routine ROUT with argument list
C					ALIST
C	WNGARA_J = WNGARA( N_J:I)	Return address of N
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER N		!ARGUMENT NUMBER
	EXTERNAL ROUT		!ROUTINE TO CALL
	INTEGER ALIST(0:*)	!ARGUMENT LIST
C
C  Entry points:
C
	LOGICAL WNGART
	INTEGER WNGARN,WNGARQ,WNGARA
C
C  Function references:
C
	INTEGER LIB$CALLG
	INTEGER WNGARG_X	!ADDRESS ARGUMENT LIST ENCLOSING ROUTINE
C
C  Data declarations:
C
C-
C
C WNGARG
C
	WNGARG=WNGARG_X()			!ARGUMENT LIST ADDRESS
C
	RETURN
C
C WNGART
C
	ENTRY WNGART(N)
C
	WNGART=.FALSE.				!ASSUME NOT PRESENT
	J=WNGARG_X()				!PREVIOUS AP
	IF (J.EQ.0) RETURN			!NONE
	J=(J-A_OB)/LB_J				!PREVIOUS AP PTR
	IF (N.LE.0 .OR. N.GT.255) RETURN	!NO SUCH ARGUMENT
	IF (N.GT.IAND(A_J(J),'000000FF'X)) RETURN !NO SUCH ARGUMENT
	IF (A_J(J+N).EQ.0) RETURN		!EMPTY ARGUMENT
	WNGART=.TRUE.				!PRESENT
C
	RETURN
C
C WNGARN
C
	ENTRY WNGARN()
C
	WNGARN=0				!RESULT
	J=WNGARG_X()				!PREVIOUS AP
	IF (J.EQ.0) RETURN			!ERROR
	J=(J-A_OB)/LB_J				!PREVIOUS AP PTR
	WNGARN=IAND(A_J(J),'000000FF'X)		!# OF ARGUMENTS
C
	RETURN
C
C WNGARQ
C
	ENTRY WNGARQ(ROUT,ALIST)
C
	WNGARQ=LIB$CALLG(ALIST,ROUT)		!CALL ROUTINE
C
	RETURN
C
C WNGARA
C
	ENTRY WNGARA(N)
C
	WNGARA=%LOC(N)
C
	RETURN
C
C
	END

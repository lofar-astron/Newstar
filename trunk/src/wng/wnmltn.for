C+ WNMLTN.FOR
C  WNB 950330
C
C  Revisions:
C       WNB 950615	Typo
C
	LOGICAL FUNCTION WNMLTN(MAR)
C
C  Triangularize normal equations
C
C  Result:
C
C	WNMLTN_L = WNMLTN( MAR_J:I)
C				Triangularize normal equations: FALSE if
C				non-invertable normal array
C	WNMLTR_L = WNMLTR( MAR_J:O, NR_J:O)
C				Triangularize normal equations and determine
C				the rank NR and the constraint equations.
C				Note: in the case of complex equations,
C				the rank NR can be up to 2N
C	WNMLNN_L = WNMLNN( MAR_J:I, 0, SOL_E(0:*):IO, MU_E:O, FIT_E:O) 
C				Do non-linear loop . SOL will
C				be updated. MU returns the error per weight
C				(as in WNMLSN); and FIT a loop indication.
C				If FIT>0 should always loop further; if
C				abs(FIT)<0.001 you cannot do better.
C	WNMLNR_L = WNMLNR( MAR_J:O, NR_J:O, SOL_E(0:*):IO, MU_E:O, FIT_E:O) 
C				As WNMLNN, but for dependent equations
C				Note that both non-linears can only have M=1
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'LSQ_O_DEF'
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER MAR				!AREA POINTER
	INTEGER NR				!RANK OF NORMAL
						!EQUATIONS
	REAL SOL(0:*)				!INPUT/OUTPUT SOLUTION
	REAL MU					!ERROR PER WEIGHT
	REAL FIT				!GOODNESS OF FIT
C
C  Entry points:
C
	LOGICAL WNMLTR
	LOGICAL WNMLNN,WNMLNR
C
C  Function references:
C
	INTEGER WNMLGR				!GET ROW POINTER
	INTEGER WNMLGK				!GET KNOWN COLUMN POINTER
	LOGICAL WNMLGA				!GET AREA
	LOGICAL WNMLIN				!INVERT MATRIX
	LOGICAL WNGGVA				!GET MEMORY
	LOGICAL WNMLMT,WNMLMF			!COPY PART OF LSQ AREA
C
C  Data declarations:
C
	INTEGER N
	LOGICAL RANK				!DETERMINE RANK
	DOUBLE PRECISION FAC			!NON-LIN FACTOR
	DOUBLE PRECISION PREC			!PRECISION TEST
	INTEGER CAR				!COPY AREA
C-
C
C WNMLTN
C
	RANK=.FALSE.					!NO RANK
	A_J(MAR+LSQ_BITS_J)=IAND(A_J(MAR+LSQ_BITS_J),NOT(LSQ_U_NONLIN)) !LINEAR
	WNMLTN=.TRUE.
	GOTO 10
C
C WNMLNN (NON-LINEAR)
C
	ENTRY WNMLNN(MAR,NR,SOL,MU,FIT)
C
	RANK=.FALSE.					!NO RANK
	GOTO 11
C
C WNMLTR
C
	ENTRY WNMLTR(MAR,NR)
C
	RANK=.TRUE.					!RANK
	A_J(MAR+LSQ_BITS_J)=IAND(A_J(MAR+LSQ_BITS_J),NOT(LSQ_U_NONLIN)) !LINEAR
	WNMLTN=.TRUE.
	GOTO 10
C
C WNMLNR (NON-LINEAR)
C
	ENTRY WNMLNR(MAR,NR,SOL,MU,FIT)
C
	RANK=.TRUE.					!RANK
	GOTO 11
C
C INTRO
C
 11	CONTINUE
	WNMLTN=.TRUE.
	IF (A_J(MAR+LSQ_NAR_J).EQ.0) THEN		!GET SAVE AREA
	  IF (A_J(MAR+LSQ_M_J).NE.1) THEN		!ONLY ALLOWED
							!FOR M=1
	    WNMLTN=.FALSE.
	    GOTO 800
	  END IF
	  WNMLTN=WNMLGA(A_J(MAR+LSQ_NAR_J),LSQ_T_NOINIT,
	1		A_J(MAR+LSQ_N_J))		!GET AREA
	  IF (.NOT.WNMLTN) GOTO 800			!ERROR
	END IF
	CAR=A_J(MAR+LSQ_NAR_J)				!COPY AREA
	IF (IAND(A_J(MAR+LSQ_BITS_J),LSQ_U_NONLIN).EQ.0) THEN !FIRST TIME
	  WNMLTN=WNMLMF(MAR,CAR)			!SAVE AREA INFO
	  FIT=1.					!LOOP MORE
	ELSE
	  D0=ABS(A_D(A_J(MAR+LSQ_ERROR_J)+LERR_LL_D)+
	1     A_D(A_J(CAR+LSQ_ERROR_J)+LERR_LL_D))/2.
	  IF (D0.GT.0) THEN
	    FIT=(A_D(A_J(MAR+LSQ_ERROR_J)+LERR_LL_D)-
	1	A_D(A_J(CAR+LSQ_ERROR_J)+LERR_LL_D))/D0
	  ELSE
	    FIT=-1E-8					!DUMMY FIT
	  END IF
	  IF (FIT.LT.0) THEN				!BETTER ESTIMATE
	    A_D(A_J(MAR+LSQ_DBL_J)+LSQ_NONLIN_D)=
	1	A_D(A_J(MAR+LSQ_DBL_J)+LSQ_NONLIN_D)*0.1 !NEW FACTOR
	    WNMLTN=WNMLMF(MAR,CAR)			!SAVE AREA INFO
	  ELSE						!NO FIT
	    A_D(A_J(MAR+LSQ_DBL_J)+LSQ_NONLIN_D)=
	1	A_D(A_J(MAR+LSQ_DBL_J)+LSQ_NONLIN_D)*10. !NEW FACTOR
	    I0=A_J(CAR+LSQ_SOL_J)*LB_D/LB_E
	    DO I=0,A_J(MAR+LSQ_NUN_J)-1
	      SOL(I)=SOL(I)-A_E(I0+I)			!OLD SOLUTION
	    END DO
	    WNMLTN=WNMLMT(MAR,CAR)			!RESTORE AREA INFO
	  END IF
	END IF
	A_J(MAR+LSQ_BITS_J)=IOR(A_J(MAR+LSQ_BITS_J),LSQ_U_NONLIN) !SET NON-LIN
	FAC=1D0+A_D(A_J(MAR+LSQ_DBL_J)+LSQ_NONLIN_D)	!FACTOR
	CALL WNMLIF(MAR,FAC)				!MAKE DIAGONAL
C
C LINEAR
C
 10	CONTINUE
	CALL WNMLID(MAR)				!NON-ZERO DIAGONAL
	PREC=A_D(A_J(MAR+LSQ_DBL_J)+LSQ_FACTOR_D)	!TEST FACTOR
	N=A_J(MAR+LSQ_N_J)				!# TO SOLVE
C
C WITH CONSTRAINTS
C
	IF (A_J(MAR+LSQ_NUN_J).NE.A_J(MAR+LSQ_N_J)) THEN
	  WNMLTN=WNMLIN(MAR)				!DO LU INVERSION
	  GOTO 800					!READY
	END IF
C
C DECOMPOSE
C
	DO I=0,N-1					!DECOMPOSE
	  IF (I.LT.A_J(MAR+LSQ_R_J)) THEN		!STILL RANK LEFT
	    I3=WNMLGR(MAR,I)				!ROW POINTER
 20	    CONTINUE
	    D0=A_D(I3+I)				!GET COLLINEARITY
	    DO I2=0,I-1
	      I4=WNMLGR(MAR,I2)				!ROW POINTER
	      D0=D0-A_D(I4+I)*A_D(I4+I)/A_D(I4+I2)
	    END DO
	    IF (D0*D0/A_D(I3+I).LE.PREC) THEN 		!DEPENDANCY
	      IF (.NOT.RANK) THEN			!SHOULD BE OK
		WNMLTN=.FALSE.
		GOTO 800
	      END IF
	      IF (I.LT.A_J(MAR+LSQ_R_J)-1) THEN		!RANK LEFT
		J0=A_J(MAR+LSQ_R_J)-1			!RANK POINTER
		DO I2=0,I-1				!SHIFT PIVOT
		  I4=WNMLGR(MAR,I2)			!ROW POINTER
		  D1=A_D(I4+I)
		  A_D(I4+I)=A_D(I4+J0)
		  A_D(I4+J0)=D1
		END DO
		D1=A_D(I3+I)
		I4=WNMLGR(MAR,J0)			!ROW POINTER
		A_D(I3+I)=A_D(I4+J0)
		A_D(I4+J0)=D1
		DO I2=I+1,J0-1
		  I4=WNMLGR(MAR,I2)			!ROW POINTER
		  D1=A_D(I3+I2)
		  A_D(I3+I2)=A_D(I4+J0)
		  A_D(I4+J0)=D1
		END DO
		I4=WNMLGR(MAR,J0)			!ROW POINTER
		DO I2=J0+1,N-1				!SHIFT PIVOT
		  D1=A_D(I3+I2)
		  A_D(I3+I2)=A_D(I4+I2)
		  A_D(I4+I2)=D1
		END DO
		A_J(MAR+LSQ_R_J)=A_J(MAR+LSQ_R_J)-1	!DECREASE RANK
		J2=A_J(MAR+LSQ_PIV_J)			!PIVOT TABLE
		I1=A_J(J2+I)				!SWITCH PIVOTS
		A_J(J2+I)=A_J(J2+J0)
		A_J(J2+J0)=I1
		GOTO 20					!RETRY
	      ELSE
		A_J(MAR+LSQ_R_J)=I			!SET RANK
	      END IF
	    END IF
	    A_D(I3+I)=D0				!DIAGONAL
	    DO I1=I+1,N-1				!LU DECOMPOSITION
	      DO I2=0,I-1
		I4=WNMLGR(MAR,I2)			!ROW POINTER
		A_D(I3+I1)=A_D(I3+I1)-A_D(I4+I)*A_D(I4+I1)/A_D(I4+I2)
	      END DO
	    END DO
	  END IF
	END DO
C       
C CONSTRAINTS
C
	J0=A_J(MAR+LSQ_R_J)				!RANK
	DO I1=J0,N-1
	  DO I=J0-1,0,-1
	    I3=WNMLGR(MAR,I)				!ROW POINTER
	    DO I2=I+1,J0-1
	      I4=WNMLGR(MAR,I2)				!ROW POINTER
	      A_D(I3+I1)=A_D(I3+I1)+A_D(I3+I2)*A_D(I4+I1)
	    END DO
	    A_D(I3+I1)=-A_D(I3+I1)/A_D(I3+I)
	  END DO
	END DO
C
C RANK BASIS (A=I+G1'*.G1')
C
	DO I=J0,N-1
	  I3=WNMLGR(MAR,I)				!ROW POINTER
	  DO I1=I,N-1
	    A_D(I3+I1)=0
	    DO I2=0,J0-1
	      I4=WNMLGR(MAR,I2)				!ROW POINTER
	      A_D(I3+I1)=A_D(I3+I1)+A_D(I4+I)*A_D(I4+I1)
	    END DO
	  END DO
	  A_D(I3+I)=1+A_D(I3+I)
	END DO
C
C TRIANGULAR A
C
	DO I=J0,N-1
	  I3=WNMLGR(MAR,I)				!ROW POINTER
	  DO I1=I,N-1
	    DO I2=J0,I-1
	      I4=WNMLGR(MAR,I2)				!ROW POINTER
	      A_D(I3+I1)=A_D(I3+I1)-A_D(I4+I)*A_D(I4+I1)/A_D(I4+I2)
	    END DO
	  END DO
	END DO
C
	IF (RANK) NR=A_J(MAR+LSQ_R_J)			!RANK
C
C READY
C
 800	CONTINUE
	IF (.NOT.WNMLTN) THEN				!ERROR
	  A_J(MAR+LSQ_BITS_J)=IAND(A_J(MAR+LSQ_BITS_J),
	1		NOT(LSQ_U_TRIANGLE+LSQ_U_NONLIN))
	ELSE
	  A_J(MAR+LSQ_BITS_J)=IOR(A_J(MAR+LSQ_BITS_J),LSQ_U_TRIANGLE)
C
C SOLVE NON-LINEAR
C
	  IF (IAND(A_J(MAR+LSQ_BITS_J),LSQ_U_NONLIN).NE.0) THEN
	    I0=A_J(CAR+LSQ_SOL_J)*LB_D/LB_E
	    CALL WNMLSN(MAR,A_E(I0),MU,R0)
	    DO I=0,A_J(MAR+LSQ_NUN_J)-1
	      SOL(I)=SOL(I)+A_E(I0+I)			!NEW SOLUTION
	    END DO
	    CALL WNMLIA(MAR,LSQ_I_SOL)			!RESET AREA
	  END IF
	END IF
C
	RETURN
C
C
	END

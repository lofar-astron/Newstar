C+ WNPEX1.FOR
C  WNB 911213
C
C  Revisions:
C	GvD 920501	Use J5 iso. JS
C	WNB 930414	Correct device clipping
C
C  Extra routines WNP package
C
	LOGICAL FUNCTION WQ_BOX(N,POS,DPOS,INT,FAIX)
C
C  Result:
C
C	CALL WQ_BOX( N_J:I, POS_E(0:1):I, DPOS_E(0:3):I, INT_E(0:*):I,
C					FAIX_J:I)
C				Fill areas. N intensities INT given starting at
C				POS (centre). Intensities between 0 and 1
C				One area has point and line step DPOS.
C				FAIX is index (0:random, 1:regular, 2:pattern)
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WQG_DEF'		!GENERAL AREA
	INCLUDE 'WQD_O_DEF'		!DEVICE AREA
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER N		!# OF INTENSITIES
	REAL POS(0:1)		!FIRST POSITION
	REAL DPOS(0:3)		!DX, DY POINT, LINE
	REAL INT(0:*)		!INTENSITIES
	INTEGER FAIX		!FILL TYPE
C
C  Function references:
C
	LOGICAL WNP_ALLOC	!ALLOCATE WORK AREA
	INTEGER WNGARA		!ADDRESS
C
C  Data declarations:
C
	INTEGER VP(5)		!PLOT DATA
	REAL LDPOS(0:9,0:1)	!LOCAL DX, DY POINTS
	REAL LBOX(0:3)		!TOTAL BOX
C-
C
C INIT
C
	WQ_BOX=.TRUE.				!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5					!WRONG STATE
 11	  CONTINUE
	  WQ_BOX=.FALSE.
	  RETURN
	END IF
	IF (N.LT.1) THEN
	  E_C=100				!ERROR
	  GOTO 11
	END IF
	DO I=0,1
	  LDPOS(I+0,0)=0			!FOR OFFSET POSITION
	  LDPOS(I+2,0)=DPOS(I)			!DX, DY POSITION
	  LDPOS(I+4,0)=DPOS(I)+DPOS(I+2)	!DX, DY BOX
	  LDPOS(I+6,0)=POS(I)			!START POSITION
	  LDPOS(I+8,0)=POS(I)+0.5*DPOS(I)	!CENTRE POSITION
	END DO
	J=4*N+4					!MULTIPLE LIST LENGTH
	IF (.NOT.WNP_ALLOC(J)) THEN		!GET AREAS
	  E_C=100
	  GOTO 11
	END IF
C
C GET INTENSITIES
C
	J1=(WQG_OUT3-A_OB)/LB_E
	DO I=0,N-1
	  A_E(J1+I)=INT(I)			!INT
	END DO
C
C CHECK BOXES
C
	DO I=0,1
	  IF (LDPOS(4+I,0).LT.0) THEN		!D < 0
	    LDPOS(4+I,0)=ABS(LDPOS(4+I,0))	!MAKE > 0
	    LDPOS(6+I,0)=LDPOS(6+I,0)-LDPOS(4+I,0)
	  END IF
	END DO
C
C GET POSITIONS
C
	J0=(WQG_OUT2-A_OB)/LB_E			!WORK POINTERS
	DO I=0,N-1				!MAKE CENTRE POSITIONS
	  DO I1=0,1
	    A_E(J0+2*I+I1)=LDPOS(I1+8,0)+I*LDPOS(I1+2,0) !X,Y
	  END DO
	END DO
C
C TRANSFORM
C
	CALL WNP_MAKL(N,A_B(WQG_OUT2-A_OB),
	1		A_B(WQG_OUT1-A_OB))	!MAKE MULTIPLE LIST
	IF (IAND(1,WQG_CLIP).NE.0) THEN
	  CALL WNP_NTRG(A_B(WQG_OUT1-A_OB),
	1		A_B(WQG_OUT2-A_OB))	!NORM. TRANSFORM
	  CALL WNP_SHCLP(A_B(WQG_OUT2-A_OB),
	1		A_B(WQG_OUT3-A_OB),
	1		WQG_NTR(0,2,WQG_CTR))	!CLIP VIEW
	ELSE
	  CALL WNP_NTRG(A_B(WQG_OUT1-A_OB),
	1		A_B(WQG_OUT2-A_OB))	!NORM. TRANSFORM
	END IF
	CALL WNP_NTR0(4,LDPOS(0,0),J5,LDPOS(0,1)) !TRANSFORM BOX
C
C ON ALL ACTIVE DEVICES
C
	J=WQG_QOP				!START LIST
	DO WHILE (J.NE.0)
	  J0=(J-A_OB)/LB_J			!PTR
	  IF (A_J(J0+WQD_ACT_J).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),1).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),4).EQ.0) THEN !OUTPUT DEVICE
	    J2=(WQG_OUT3-A_OB)/LB_E		!SAVE CLIPPED INT.
	    J3=(WQG_OUT1-A_OB)/LB_E
	    DO I=0,N-1
	      A_E(J3+I)=A_E(J2+I)		!INT
	    END DO
	    CALL WNP_SHCLP(A_B(WQG_OUT2-A_OB),
	1		A_B(WQG_OUT1-A_OB),
	1		A_E(J0+WQD_NTR_E+4))	!CLIP
	    CALL WNP_DNTR0(4,LDPOS(0,1),J5,LDPOS(0,0),J) !TRANSFORM BOX
	    DO I=0,1
	      LDPOS(I+2,0)=LDPOS(I+2,0)-LDPOS(I,0) !DIFFERENCE POS.
	      LDPOS(I+4,0)=LDPOS(I+4,0)-LDPOS(I,0)
	    END DO
	    J1=FAIX				!CURRENT INDEX
	    IF (J1.GT.2) J1=0			!DEFAULT
	    J1=MAX(0,J1)			!MAKE INDEX
C
C DRAW BOXES
C
	    DO I=0,1
	      LBOX(I+0)=LDPOS(6+I,0)		!LLHC BOX
	      LBOX(I+2)=LBOX(I+0)+N*LDPOS(I+2,0)+LDPOS(I+4,0) !URHC
	      IF (LBOX(I+0).GT.LBOX(I+2)) THEN	!MAKE CORRECT SIZE
		I1=LBOX(I+0)
		LBOX(I+0)=LBOX(I+2)
		LBOX(I+2)=I1
	      END IF
	    END DO
	    VP(1)=J1				!INDEX
	    VP(2)=WQG_OUT1			!INTENSITY LIST
	    VP(4)=N-1				!# OF POINTS
	    VP(3)=WNGARA(LBOX)			!TOTAL BOX
	    VP(5)=WNGARA(LDPOS(2,0))		!DX, DY , BOX, POS
	    CALL WNPDEX(6,J,VP)			!DRAW
	  END IF
 20	  CONTINUE
	  J=A_J((J-A_OB)/LB_J)			!NEXT DEVICE
	END DO
C
C READY
C
 900	CONTINUE
C
	RETURN
C
C
	END

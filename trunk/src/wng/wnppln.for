C+ WNPPLN.FOR
C  WNB 910624
C
C  Revisions:
C
C  Polyline routine
C
	LOGICAL FUNCTION WQPOLL(N,POS)
C
C  Result:
C
C	WQPOLL_L = WQPOLL( N_J:I, POS_E(2,N):I)
C	WQPOLL_IX_L = WQPOLL_IX( N_J:I, POS_E(2,N):I, IX_J:I)
C	WQPOLL_LIST_L = WQPOLL_LIST( PLIST_J(*):I)
C				Draw polylines from given list; and set
C				polyline index IX.
C
C  Include files:
C
	INCLUDE 'WNG_DEF'
	INCLUDE 'WQG_DEF'		!GENERAL AREA
	INCLUDE 'WQD_O_DEF'		!DEVICE AREA
C
C  Parameters:
C
C
C  Arguments:
C
	INTEGER N			!NUMBER OF POINTS
	REAL POS(2,*)			!X,Y POSITIONS
	INTEGER IX			!LINE INDEX
	INTEGER PLIST(*)		!SPECIAL POLYLINE LIST
C
C  Entry points:
C
	LOGICAL WQPOLL_IX		!SET ALSO INDEX
	LOGICAL WQPOLL_LIST		!SPECIAL POLY LINE
C
C  Function references:
C
	LOGICAL WQSPLI			!SET POLYLINE INDEX
	LOGICAL WNP_ALLOC		!GET AREAS
C
C  Data declarations:
C
	INTEGER VP(2)			!ARGUMENT LIST
C-
	WQPOLL=.TRUE.				!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5					!WRONG STATE
 11	  CONTINUE
	  WQPOLL=.FALSE.
	  RETURN
	END IF
	GOTO 10
C
C POLL_IX
C
	ENTRY WQPOLL_IX(N,POS,IX)
C
	WQPOLL_IX=.TRUE.			!ASSUME OK
	IF (WQG_STATE.LT.3) THEN
	  E_C=5					!WRONG STATE
	  GOTO 11
	END IF
	IF (.NOT.WQSPLI(IX)) GOTO 11		!SET INDEX
	GOTO 10
C
C INIT
C
 10	CONTINUE
	IF (N.LT.2) THEN
	  E_C=100				!ERROR
	  GOTO 11
	END IF
	J=15*N+2				!MULTIPLE LIST LENGTH
	IF (.NOT.WNP_ALLOC(J)) THEN		!GET AREAS
	  E_C=100
	  GOTO 11
	END IF
	CALL WNP_MAKL(N,POS,A_B(WQG_OUT1-A_OB))	!MAKE MULTIPLE LIST
	IF (IAND(1,WQG_CLIP).NE.0) THEN
	  CALL WNP_NTRG(A_B(WQG_OUT1-A_OB),
	1		A_B(WQG_OUT3-A_OB))	!NORM. TRANSFORM
	  CALL WNP_PLCLP(A_B(WQG_OUT3-A_OB),
	1		A_B(WQG_OUT2-A_OB),
	1		WQG_NTR(0,2,WQG_CTR))	!CLIP VIEW
	  IF (A_J((WQG_OUT2-A_OB)/LB_J).LE.0) GOTO 900 !NONE LEFT
	ELSE
	  CALL WNP_NTRG(A_B(WQG_OUT1-A_OB),
	1		A_B(WQG_OUT2-A_OB))	!NORM. TRANSFORM
	END IF
	GOTO 100
C
C WQPOLL_LIST
C
	ENTRY WQPOLL_LIST(PLIST)
C
	WQPOLL_LIST=.TRUE.			!ASSUME OK
	J1=PLIST(1)
	J0=1
	J=0
	DO WHILE (J1.NE.0)
	  J=J+J1
	  J0=J0+2*J1+1
	  J1=PLIST(J0)
	END DO
	J=15*J+2				!MULTIPLE LIST LENGTH
	IF (.NOT.WNP_ALLOC(J)) THEN		!GET AREAS
	  E_C=100
	  GOTO 11
	END IF
	IF (IAND(1,WQG_CLIP).NE.0) THEN
	  CALL WNP_NTRG(PLIST,
	1		A_B(WQG_OUT3-A_OB))	!NORM. TRANSFORM
	  CALL WNP_PLCLP(A_B(WQG_OUT3-A_OB),
	1		A_B(WQG_OUT2-A_OB),
	1		WQG_NTR(0,2,WQG_CTR))	!CLIP VIEW
	  IF (A_J((WQG_OUT2-A_OB)/LB_J).LE.0) GOTO 900 !NONE LEFT
	ELSE
	  CALL WNP_NTRG(PLIST,
	1		A_B(WQG_OUT2-A_OB))	!NORM. TRANSFORM
	END IF
C
C ON ALL ACTIVE DEVICES
C
 100	CONTINUE
	J=WQG_QOP				!START LIST
	DO WHILE (J.NE.0)
	  J0=(J-A_OB)/LB_J			!PTR
	  IF (A_J(J0+WQD_ACT_J).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),1).NE.0 .AND.
	1		IAND(A_J(J0+WQD_TYP_J),4).EQ.0) THEN !OUTPUT DEVICE
	    CALL WNP_PLCLP(A_B(WQG_OUT2-A_OB),
	1		A_B(WQG_OUT3-A_OB),
	1		A_E(J0+WQD_NTR_E+4))	!CLIP
	    IF (A_J((WQG_OUT3-A_OB)/LB_J).LE.0) GOTO 20 !NONE LEFT
	    CALL WNP_DNTRG(A_B(WQG_OUT3-A_OB),
	1		A_B(WQG_OUT1-A_OB),J)	!DEVICE TRANSF.
	    J1=WQG_CPOLLIX-1			!CURRENT INDEX
	    IF (J1.GT.A_J(J0+WQD_NPLIX_J)) J1=0	!DEFAULT
	    J1=MAX(0,J1)			!MAKE INDEX
	    VP(1)=J1				!INDEX
	    VP(2)=WQG_OUT1			!LIST ADDRESS
	    CALL WNPDEX(3,J,VP)			!DRAW
	  END IF
 20	  CONTINUE
	  J=A_J((J-A_OB)/LB_J)			!NEXT DEVICE
	END DO
C
 900	CONTINUE
C
	RETURN
C
C
	END
	
